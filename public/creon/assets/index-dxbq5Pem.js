var bf = Object.defineProperty; var md = t => { throw TypeError(t) }; var Cf = (t, e, o) => e in t ? bf(t, e, { enumerable: !0, configurable: !0, writable: !0, value: o }) : t[e] = o; var wt = (t, e, o) => Cf(t, typeof e != "symbol" ? e + "" : e, o), gd = (t, e, o) => e.has(t) || md("Cannot " + o); var Te = (t, e, o) => (gd(t, e, "read from private field"), o ? o.call(t) : e.get(t)), to = (t, e, o) => e.has(t) ? md("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, o), Yi = (t, e, o, n) => (gd(t, e, "write to private field"), n ? n.call(t, o) : e.set(t, o), o); (function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i); new MutationObserver(i => { for (const r of i) if (r.type === "childList") for (const a of r.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && n(a) }).observe(document, { childList: !0, subtree: !0 }); function o(i) { const r = {}; return i.integrity && (r.integrity = i.integrity), i.referrerPolicy && (r.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? r.credentials = "include" : i.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r } function n(i) { if (i.ep) return; i.ep = !0; const r = o(i); fetch(i.href, r) } })(); const wf = "modulepreload", If = function (t, e) { return new URL(t, e).href }, hd = {}, yd = function (e, o, n) { let i = Promise.resolve(); if (o && o.length > 0) { let a = function (p) { return Promise.all(p.map(v => Promise.resolve(v).then(T => ({ status: "fulfilled", value: T }), T => ({ status: "rejected", reason: T })))) }; const c = document.getElementsByTagName("link"), f = document.querySelector("meta[property=csp-nonce]"), u = (f == null ? void 0 : f.nonce) || (f == null ? void 0 : f.getAttribute("nonce")); i = a(o.map(p => { if (p = If(p, n), p in hd) return; hd[p] = !0; const v = p.endsWith(".css"), T = v ? '[rel="stylesheet"]' : ""; if (!!n) for (let $ = c.length - 1; $ >= 0; $--) { const N = c[$]; if (N.href === p && (!v || N.rel === "stylesheet")) return } else if (document.querySelector(`link[href="${p}"]${T}`)) return; const R = document.createElement("link"); if (R.rel = v ? "stylesheet" : wf, v || (R.as = "script"), R.crossOrigin = "", R.href = p, u && R.setAttribute("nonce", u), document.head.appendChild(R), v) return new Promise(($, N) => { R.addEventListener("load", $), R.addEventListener("error", () => N(new Error(`Unable to preload CSS for ${p}`))) }) })) } function r(a) { const c = new Event("vite:preloadError", { cancelable: !0 }); if (c.payload = a, window.dispatchEvent(c), !c.defaultPrevented) throw a } return i.then(a => { for (const c of a || []) c.status === "rejected" && r(c.reason); return e().catch(r) }) };/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */let Sf, Lf; function _f() { return { geminiUrl: Sf, vertexUrl: Lf } } function Af(t, e, o, n) { var i, r; if (!(t != null && t.baseUrl)) { const a = _f(); return e ? (i = a.vertexUrl) !== null && i !== void 0 ? i : o : (r = a.geminiUrl) !== null && r !== void 0 ? r : n } return t.baseUrl }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class So { } function ie(t, e) { const o = /\{([^}]+)\}/g; return t.replace(o, (n, i) => { if (Object.prototype.hasOwnProperty.call(e, i)) { const r = e[i]; return r != null ? String(r) : "" } else throw new Error(`Key '${i}' not found in valueMap.`) }) } function l(t, e, o) { for (let r = 0; r < e.length - 1; r++) { const a = e[r]; if (a.endsWith("[]")) { const c = a.slice(0, -2); if (!(c in t)) if (Array.isArray(o)) t[c] = Array.from({ length: o.length }, () => ({})); else throw new Error(`Value must be a list given an array path ${a}`); if (Array.isArray(t[c])) { const f = t[c]; if (Array.isArray(o)) for (let u = 0; u < f.length; u++) { const p = f[u]; l(p, e.slice(r + 1), o[u]) } else for (const u of f) l(u, e.slice(r + 1), o) } return } else if (a.endsWith("[0]")) { const c = a.slice(0, -3); c in t || (t[c] = [{}]); const f = t[c]; l(f[0], e.slice(r + 1), o); return } (!t[a] || typeof t[a] != "object") && (t[a] = {}), t = t[a] } const n = e[e.length - 1], i = t[n]; if (i !== void 0) { if (!o || typeof o == "object" && Object.keys(o).length === 0 || o === i) return; if (typeof i == "object" && typeof o == "object" && i !== null && o !== null) Object.assign(i, o); else throw new Error(`Cannot set value for an existing key. Key: ${n}`) } else n === "_self" && typeof o == "object" && o !== null && !Array.isArray(o) ? Object.assign(t, o) : t[n] = o } function s(t, e, o = void 0) { try { if (e.length === 1 && e[0] === "_self") return t; for (let n = 0; n < e.length; n++) { if (typeof t != "object" || t === null) return o; const i = e[n]; if (i.endsWith("[]")) { const r = i.slice(0, -2); if (r in t) { const a = t[r]; return Array.isArray(a) ? a.map(c => s(c, e.slice(n + 1), o)) : o } else return o } else t = t[i] } return t } catch (n) { if (n instanceof TypeError) return o; throw n } } function xf(t, e) { for (const [o, n] of Object.entries(e)) { const i = o.split("."), r = n.split("."), a = new Set; let c = -1; for (let f = 0; f < i.length; f++)if (i[f] === "*") { c = f; break } if (c !== -1 && r.length > c) for (let f = c; f < r.length; f++) { const u = r[f]; u !== "*" && !u.endsWith("[]") && !u.endsWith("[0]") && a.add(u) } Ir(t, i, r, 0, a) } } function Ir(t, e, o, n, i) { if (n >= e.length || typeof t != "object" || t === null) return; const r = e[n]; if (r.endsWith("[]")) { const a = r.slice(0, -2), c = t; if (a in c && Array.isArray(c[a])) for (const f of c[a]) Ir(f, e, o, n + 1, i) } else if (r === "*") { if (typeof t == "object" && t !== null && !Array.isArray(t)) { const a = t, c = Object.keys(a).filter(u => !u.startsWith("_") && !i.has(u)), f = {}; for (const u of c) f[u] = a[u]; for (const [u, p] of Object.entries(f)) { const v = []; for (const T of o.slice(n)) T === "*" ? v.push(u) : v.push(T); l(a, v, p) } for (const u of c) delete a[u] } } else { const a = t; r in a && Ir(a[r], e, o, n + 1, i) } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Nr(t) { if (typeof t != "string") throw new Error("fromImageBytes must be a string"); return t }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function kf(t) { const e = {}, o = s(t, ["operationName"]); o != null && l(e, ["operationName"], o); const n = s(t, ["resourceName"]); return n != null && l(e, ["_url", "resourceName"], n), e } function Rf(t) { const e = {}, o = s(t, ["name"]); o != null && l(e, ["name"], o); const n = s(t, ["metadata"]); n != null && l(e, ["metadata"], n); const i = s(t, ["done"]); i != null && l(e, ["done"], i); const r = s(t, ["error"]); r != null && l(e, ["error"], r); const a = s(t, ["response", "generateVideoResponse"]); return a != null && l(e, ["response"], Nf(a)), e } function Df(t) { const e = {}, o = s(t, ["name"]); o != null && l(e, ["name"], o); const n = s(t, ["metadata"]); n != null && l(e, ["metadata"], n); const i = s(t, ["done"]); i != null && l(e, ["done"], i); const r = s(t, ["error"]); r != null && l(e, ["error"], r); const a = s(t, ["response"]); return a != null && l(e, ["response"], Pf(a)), e } function Nf(t) { const e = {}, o = s(t, ["generatedSamples"]); if (o != null) { let r = o; Array.isArray(r) && (r = r.map(a => Mf(a))), l(e, ["generatedVideos"], r) } const n = s(t, ["raiMediaFilteredCount"]); n != null && l(e, ["raiMediaFilteredCount"], n); const i = s(t, ["raiMediaFilteredReasons"]); return i != null && l(e, ["raiMediaFilteredReasons"], i), e } function Pf(t) { const e = {}, o = s(t, ["videos"]); if (o != null) { let r = o; Array.isArray(r) && (r = r.map(a => Ff(a))), l(e, ["generatedVideos"], r) } const n = s(t, ["raiMediaFilteredCount"]); n != null && l(e, ["raiMediaFilteredCount"], n); const i = s(t, ["raiMediaFilteredReasons"]); return i != null && l(e, ["raiMediaFilteredReasons"], i), e } function Mf(t) { const e = {}, o = s(t, ["video"]); return o != null && l(e, ["video"], qf(o)), e } function Ff(t) { const e = {}, o = s(t, ["_self"]); return o != null && l(e, ["video"], Vf(o)), e } function Uf(t) { const e = {}, o = s(t, ["operationName"]); return o != null && l(e, ["_url", "operationName"], o), e } function $f(t) { const e = {}, o = s(t, ["operationName"]); return o != null && l(e, ["_url", "operationName"], o), e } function qf(t) { const e = {}, o = s(t, ["uri"]); o != null && l(e, ["uri"], o); const n = s(t, ["encodedVideo"]); n != null && l(e, ["videoBytes"], Nr(n)); const i = s(t, ["encoding"]); return i != null && l(e, ["mimeType"], i), e } function Vf(t) { const e = {}, o = s(t, ["gcsUri"]); o != null && l(e, ["uri"], o); const n = s(t, ["bytesBase64Encoded"]); n != null && l(e, ["videoBytes"], Nr(n)); const i = s(t, ["mimeType"]); return i != null && l(e, ["mimeType"], i), e }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */var vd; (function (t) { t.OUTCOME_UNSPECIFIED = "OUTCOME_UNSPECIFIED", t.OUTCOME_OK = "OUTCOME_OK", t.OUTCOME_FAILED = "OUTCOME_FAILED", t.OUTCOME_DEADLINE_EXCEEDED = "OUTCOME_DEADLINE_EXCEEDED" })(vd || (vd = {})); var Td; (function (t) { t.LANGUAGE_UNSPECIFIED = "LANGUAGE_UNSPECIFIED", t.PYTHON = "PYTHON" })(Td || (Td = {})); var Ed; (function (t) { t.SCHEDULING_UNSPECIFIED = "SCHEDULING_UNSPECIFIED", t.SILENT = "SILENT", t.WHEN_IDLE = "WHEN_IDLE", t.INTERRUPT = "INTERRUPT" })(Ed || (Ed = {})); var Je; (function (t) { t.TYPE_UNSPECIFIED = "TYPE_UNSPECIFIED", t.STRING = "STRING", t.NUMBER = "NUMBER", t.INTEGER = "INTEGER", t.BOOLEAN = "BOOLEAN", t.ARRAY = "ARRAY", t.OBJECT = "OBJECT", t.NULL = "NULL" })(Je || (Je = {})); var bd; (function (t) { t.HARM_CATEGORY_UNSPECIFIED = "HARM_CATEGORY_UNSPECIFIED", t.HARM_CATEGORY_HARASSMENT = "HARM_CATEGORY_HARASSMENT", t.HARM_CATEGORY_HATE_SPEECH = "HARM_CATEGORY_HATE_SPEECH", t.HARM_CATEGORY_SEXUALLY_EXPLICIT = "HARM_CATEGORY_SEXUALLY_EXPLICIT", t.HARM_CATEGORY_DANGEROUS_CONTENT = "HARM_CATEGORY_DANGEROUS_CONTENT", t.HARM_CATEGORY_CIVIC_INTEGRITY = "HARM_CATEGORY_CIVIC_INTEGRITY", t.HARM_CATEGORY_IMAGE_HATE = "HARM_CATEGORY_IMAGE_HATE", t.HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT = "HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT", t.HARM_CATEGORY_IMAGE_HARASSMENT = "HARM_CATEGORY_IMAGE_HARASSMENT", t.HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT = "HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT", t.HARM_CATEGORY_JAILBREAK = "HARM_CATEGORY_JAILBREAK" })(bd || (bd = {})); var Cd; (function (t) { t.HARM_BLOCK_METHOD_UNSPECIFIED = "HARM_BLOCK_METHOD_UNSPECIFIED", t.SEVERITY = "SEVERITY", t.PROBABILITY = "PROBABILITY" })(Cd || (Cd = {})); var wd; (function (t) { t.HARM_BLOCK_THRESHOLD_UNSPECIFIED = "HARM_BLOCK_THRESHOLD_UNSPECIFIED", t.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE", t.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE", t.BLOCK_ONLY_HIGH = "BLOCK_ONLY_HIGH", t.BLOCK_NONE = "BLOCK_NONE", t.OFF = "OFF" })(wd || (wd = {})); var Id; (function (t) { t.MODE_UNSPECIFIED = "MODE_UNSPECIFIED", t.MODE_DYNAMIC = "MODE_DYNAMIC" })(Id || (Id = {})); var Sd; (function (t) { t.AUTH_TYPE_UNSPECIFIED = "AUTH_TYPE_UNSPECIFIED", t.NO_AUTH = "NO_AUTH", t.API_KEY_AUTH = "API_KEY_AUTH", t.HTTP_BASIC_AUTH = "HTTP_BASIC_AUTH", t.GOOGLE_SERVICE_ACCOUNT_AUTH = "GOOGLE_SERVICE_ACCOUNT_AUTH", t.OAUTH = "OAUTH", t.OIDC_AUTH = "OIDC_AUTH" })(Sd || (Sd = {})); var Ld; (function (t) { t.API_SPEC_UNSPECIFIED = "API_SPEC_UNSPECIFIED", t.SIMPLE_SEARCH = "SIMPLE_SEARCH", t.ELASTIC_SEARCH = "ELASTIC_SEARCH" })(Ld || (Ld = {})); var _d; (function (t) { t.URL_RETRIEVAL_STATUS_UNSPECIFIED = "URL_RETRIEVAL_STATUS_UNSPECIFIED", t.URL_RETRIEVAL_STATUS_SUCCESS = "URL_RETRIEVAL_STATUS_SUCCESS", t.URL_RETRIEVAL_STATUS_ERROR = "URL_RETRIEVAL_STATUS_ERROR", t.URL_RETRIEVAL_STATUS_PAYWALL = "URL_RETRIEVAL_STATUS_PAYWALL", t.URL_RETRIEVAL_STATUS_UNSAFE = "URL_RETRIEVAL_STATUS_UNSAFE" })(_d || (_d = {})); var Ad; (function (t) { t.FINISH_REASON_UNSPECIFIED = "FINISH_REASON_UNSPECIFIED", t.STOP = "STOP", t.MAX_TOKENS = "MAX_TOKENS", t.SAFETY = "SAFETY", t.RECITATION = "RECITATION", t.LANGUAGE = "LANGUAGE", t.OTHER = "OTHER", t.BLOCKLIST = "BLOCKLIST", t.PROHIBITED_CONTENT = "PROHIBITED_CONTENT", t.SPII = "SPII", t.MALFORMED_FUNCTION_CALL = "MALFORMED_FUNCTION_CALL", t.IMAGE_SAFETY = "IMAGE_SAFETY", t.UNEXPECTED_TOOL_CALL = "UNEXPECTED_TOOL_CALL", t.IMAGE_PROHIBITED_CONTENT = "IMAGE_PROHIBITED_CONTENT", t.NO_IMAGE = "NO_IMAGE" })(Ad || (Ad = {})); var xd; (function (t) { t.HARM_PROBABILITY_UNSPECIFIED = "HARM_PROBABILITY_UNSPECIFIED", t.NEGLIGIBLE = "NEGLIGIBLE", t.LOW = "LOW", t.MEDIUM = "MEDIUM", t.HIGH = "HIGH" })(xd || (xd = {})); var kd; (function (t) { t.HARM_SEVERITY_UNSPECIFIED = "HARM_SEVERITY_UNSPECIFIED", t.HARM_SEVERITY_NEGLIGIBLE = "HARM_SEVERITY_NEGLIGIBLE", t.HARM_SEVERITY_LOW = "HARM_SEVERITY_LOW", t.HARM_SEVERITY_MEDIUM = "HARM_SEVERITY_MEDIUM", t.HARM_SEVERITY_HIGH = "HARM_SEVERITY_HIGH" })(kd || (kd = {})); var Rd; (function (t) { t.BLOCKED_REASON_UNSPECIFIED = "BLOCKED_REASON_UNSPECIFIED", t.SAFETY = "SAFETY", t.OTHER = "OTHER", t.BLOCKLIST = "BLOCKLIST", t.PROHIBITED_CONTENT = "PROHIBITED_CONTENT", t.IMAGE_SAFETY = "IMAGE_SAFETY", t.MODEL_ARMOR = "MODEL_ARMOR", t.JAILBREAK = "JAILBREAK" })(Rd || (Rd = {})); var Dd; (function (t) { t.TRAFFIC_TYPE_UNSPECIFIED = "TRAFFIC_TYPE_UNSPECIFIED", t.ON_DEMAND = "ON_DEMAND", t.PROVISIONED_THROUGHPUT = "PROVISIONED_THROUGHPUT" })(Dd || (Dd = {})); var St; (function (t) { t.MODALITY_UNSPECIFIED = "MODALITY_UNSPECIFIED", t.TEXT = "TEXT", t.IMAGE = "IMAGE", t.AUDIO = "AUDIO" })(St || (St = {})); var Nd; (function (t) { t.MEDIA_RESOLUTION_UNSPECIFIED = "MEDIA_RESOLUTION_UNSPECIFIED", t.MEDIA_RESOLUTION_LOW = "MEDIA_RESOLUTION_LOW", t.MEDIA_RESOLUTION_MEDIUM = "MEDIA_RESOLUTION_MEDIUM", t.MEDIA_RESOLUTION_HIGH = "MEDIA_RESOLUTION_HIGH" })(Nd || (Nd = {})); var Sr; (function (t) { t.JOB_STATE_UNSPECIFIED = "JOB_STATE_UNSPECIFIED", t.JOB_STATE_QUEUED = "JOB_STATE_QUEUED", t.JOB_STATE_PENDING = "JOB_STATE_PENDING", t.JOB_STATE_RUNNING = "JOB_STATE_RUNNING", t.JOB_STATE_SUCCEEDED = "JOB_STATE_SUCCEEDED", t.JOB_STATE_FAILED = "JOB_STATE_FAILED", t.JOB_STATE_CANCELLING = "JOB_STATE_CANCELLING", t.JOB_STATE_CANCELLED = "JOB_STATE_CANCELLED", t.JOB_STATE_PAUSED = "JOB_STATE_PAUSED", t.JOB_STATE_EXPIRED = "JOB_STATE_EXPIRED", t.JOB_STATE_UPDATING = "JOB_STATE_UPDATING", t.JOB_STATE_PARTIALLY_SUCCEEDED = "JOB_STATE_PARTIALLY_SUCCEEDED" })(Sr || (Sr = {})); var Pd; (function (t) { t.TUNING_MODE_UNSPECIFIED = "TUNING_MODE_UNSPECIFIED", t.TUNING_MODE_FULL = "TUNING_MODE_FULL", t.TUNING_MODE_PEFT_ADAPTER = "TUNING_MODE_PEFT_ADAPTER" })(Pd || (Pd = {})); var Md; (function (t) { t.ADAPTER_SIZE_UNSPECIFIED = "ADAPTER_SIZE_UNSPECIFIED", t.ADAPTER_SIZE_ONE = "ADAPTER_SIZE_ONE", t.ADAPTER_SIZE_TWO = "ADAPTER_SIZE_TWO", t.ADAPTER_SIZE_FOUR = "ADAPTER_SIZE_FOUR", t.ADAPTER_SIZE_EIGHT = "ADAPTER_SIZE_EIGHT", t.ADAPTER_SIZE_SIXTEEN = "ADAPTER_SIZE_SIXTEEN", t.ADAPTER_SIZE_THIRTY_TWO = "ADAPTER_SIZE_THIRTY_TWO" })(Md || (Md = {})); var Fd; (function (t) { t.TUNING_TASK_UNSPECIFIED = "TUNING_TASK_UNSPECIFIED", t.TUNING_TASK_I2V = "TUNING_TASK_I2V", t.TUNING_TASK_T2V = "TUNING_TASK_T2V" })(Fd || (Fd = {})); var Ud; (function (t) { t.FEATURE_SELECTION_PREFERENCE_UNSPECIFIED = "FEATURE_SELECTION_PREFERENCE_UNSPECIFIED", t.PRIORITIZE_QUALITY = "PRIORITIZE_QUALITY", t.BALANCED = "BALANCED", t.PRIORITIZE_COST = "PRIORITIZE_COST" })(Ud || (Ud = {})); var $d; (function (t) { t.UNSPECIFIED = "UNSPECIFIED", t.BLOCKING = "BLOCKING", t.NON_BLOCKING = "NON_BLOCKING" })($d || ($d = {})); var qd; (function (t) { t.MODE_UNSPECIFIED = "MODE_UNSPECIFIED", t.MODE_DYNAMIC = "MODE_DYNAMIC" })(qd || (qd = {})); var Vd; (function (t) { t.ENVIRONMENT_UNSPECIFIED = "ENVIRONMENT_UNSPECIFIED", t.ENVIRONMENT_BROWSER = "ENVIRONMENT_BROWSER" })(Vd || (Vd = {})); var Gd; (function (t) { t.MODE_UNSPECIFIED = "MODE_UNSPECIFIED", t.AUTO = "AUTO", t.ANY = "ANY", t.NONE = "NONE", t.VALIDATED = "VALIDATED" })(Gd || (Gd = {})); var Od; (function (t) { t.BLOCK_LOW_AND_ABOVE = "BLOCK_LOW_AND_ABOVE", t.BLOCK_MEDIUM_AND_ABOVE = "BLOCK_MEDIUM_AND_ABOVE", t.BLOCK_ONLY_HIGH = "BLOCK_ONLY_HIGH", t.BLOCK_NONE = "BLOCK_NONE" })(Od || (Od = {})); var Hd; (function (t) { t.DONT_ALLOW = "DONT_ALLOW", t.ALLOW_ADULT = "ALLOW_ADULT", t.ALLOW_ALL = "ALLOW_ALL" })(Hd || (Hd = {})); var Bd; (function (t) { t.auto = "auto", t.en = "en", t.ja = "ja", t.ko = "ko", t.hi = "hi", t.zh = "zh", t.pt = "pt", t.es = "es" })(Bd || (Bd = {})); var Jd; (function (t) { t.MASK_MODE_DEFAULT = "MASK_MODE_DEFAULT", t.MASK_MODE_USER_PROVIDED = "MASK_MODE_USER_PROVIDED", t.MASK_MODE_BACKGROUND = "MASK_MODE_BACKGROUND", t.MASK_MODE_FOREGROUND = "MASK_MODE_FOREGROUND", t.MASK_MODE_SEMANTIC = "MASK_MODE_SEMANTIC" })(Jd || (Jd = {})); var Wd; (function (t) { t.CONTROL_TYPE_DEFAULT = "CONTROL_TYPE_DEFAULT", t.CONTROL_TYPE_CANNY = "CONTROL_TYPE_CANNY", t.CONTROL_TYPE_SCRIBBLE = "CONTROL_TYPE_SCRIBBLE", t.CONTROL_TYPE_FACE_MESH = "CONTROL_TYPE_FACE_MESH" })(Wd || (Wd = {})); var zd; (function (t) { t.SUBJECT_TYPE_DEFAULT = "SUBJECT_TYPE_DEFAULT", t.SUBJECT_TYPE_PERSON = "SUBJECT_TYPE_PERSON", t.SUBJECT_TYPE_ANIMAL = "SUBJECT_TYPE_ANIMAL", t.SUBJECT_TYPE_PRODUCT = "SUBJECT_TYPE_PRODUCT" })(zd || (zd = {})); var Yd; (function (t) { t.EDIT_MODE_DEFAULT = "EDIT_MODE_DEFAULT", t.EDIT_MODE_INPAINT_REMOVAL = "EDIT_MODE_INPAINT_REMOVAL", t.EDIT_MODE_INPAINT_INSERTION = "EDIT_MODE_INPAINT_INSERTION", t.EDIT_MODE_OUTPAINT = "EDIT_MODE_OUTPAINT", t.EDIT_MODE_CONTROLLED_EDITING = "EDIT_MODE_CONTROLLED_EDITING", t.EDIT_MODE_STYLE = "EDIT_MODE_STYLE", t.EDIT_MODE_BGSWAP = "EDIT_MODE_BGSWAP", t.EDIT_MODE_PRODUCT_IMAGE = "EDIT_MODE_PRODUCT_IMAGE" })(Yd || (Yd = {})); var Kd; (function (t) { t.FOREGROUND = "FOREGROUND", t.BACKGROUND = "BACKGROUND", t.PROMPT = "PROMPT", t.SEMANTIC = "SEMANTIC", t.INTERACTIVE = "INTERACTIVE" })(Kd || (Kd = {})); var Xd; (function (t) { t.ASSET = "ASSET", t.STYLE = "STYLE" })(Xd || (Xd = {})); var Zd; (function (t) { t.INSERT = "INSERT", t.REMOVE = "REMOVE", t.REMOVE_STATIC = "REMOVE_STATIC", t.OUTPAINT = "OUTPAINT" })(Zd || (Zd = {})); var Qd; (function (t) { t.OPTIMIZED = "OPTIMIZED", t.LOSSLESS = "LOSSLESS" })(Qd || (Qd = {})); var jd; (function (t) { t.STATE_UNSPECIFIED = "STATE_UNSPECIFIED", t.PROCESSING = "PROCESSING", t.ACTIVE = "ACTIVE", t.FAILED = "FAILED" })(jd || (jd = {})); var ec; (function (t) { t.SOURCE_UNSPECIFIED = "SOURCE_UNSPECIFIED", t.UPLOADED = "UPLOADED", t.GENERATED = "GENERATED" })(ec || (ec = {})); var tc; (function (t) { t.TURN_COMPLETE_REASON_UNSPECIFIED = "TURN_COMPLETE_REASON_UNSPECIFIED", t.MALFORMED_FUNCTION_CALL = "MALFORMED_FUNCTION_CALL", t.RESPONSE_REJECTED = "RESPONSE_REJECTED", t.NEED_MORE_INPUT = "NEED_MORE_INPUT" })(tc || (tc = {})); var nc; (function (t) { t.MODALITY_UNSPECIFIED = "MODALITY_UNSPECIFIED", t.TEXT = "TEXT", t.IMAGE = "IMAGE", t.VIDEO = "VIDEO", t.AUDIO = "AUDIO", t.DOCUMENT = "DOCUMENT" })(nc || (nc = {})); var oc; (function (t) { t.START_SENSITIVITY_UNSPECIFIED = "START_SENSITIVITY_UNSPECIFIED", t.START_SENSITIVITY_HIGH = "START_SENSITIVITY_HIGH", t.START_SENSITIVITY_LOW = "START_SENSITIVITY_LOW" })(oc || (oc = {})); var ic; (function (t) { t.END_SENSITIVITY_UNSPECIFIED = "END_SENSITIVITY_UNSPECIFIED", t.END_SENSITIVITY_HIGH = "END_SENSITIVITY_HIGH", t.END_SENSITIVITY_LOW = "END_SENSITIVITY_LOW" })(ic || (ic = {})); var sc; (function (t) { t.ACTIVITY_HANDLING_UNSPECIFIED = "ACTIVITY_HANDLING_UNSPECIFIED", t.START_OF_ACTIVITY_INTERRUPTS = "START_OF_ACTIVITY_INTERRUPTS", t.NO_INTERRUPTION = "NO_INTERRUPTION" })(sc || (sc = {})); var ac; (function (t) { t.TURN_COVERAGE_UNSPECIFIED = "TURN_COVERAGE_UNSPECIFIED", t.TURN_INCLUDES_ONLY_ACTIVITY = "TURN_INCLUDES_ONLY_ACTIVITY", t.TURN_INCLUDES_ALL_INPUT = "TURN_INCLUDES_ALL_INPUT" })(ac || (ac = {})); var rc; (function (t) { t.SCALE_UNSPECIFIED = "SCALE_UNSPECIFIED", t.C_MAJOR_A_MINOR = "C_MAJOR_A_MINOR", t.D_FLAT_MAJOR_B_FLAT_MINOR = "D_FLAT_MAJOR_B_FLAT_MINOR", t.D_MAJOR_B_MINOR = "D_MAJOR_B_MINOR", t.E_FLAT_MAJOR_C_MINOR = "E_FLAT_MAJOR_C_MINOR", t.E_MAJOR_D_FLAT_MINOR = "E_MAJOR_D_FLAT_MINOR", t.F_MAJOR_D_MINOR = "F_MAJOR_D_MINOR", t.G_FLAT_MAJOR_E_FLAT_MINOR = "G_FLAT_MAJOR_E_FLAT_MINOR", t.G_MAJOR_E_MINOR = "G_MAJOR_E_MINOR", t.A_FLAT_MAJOR_F_MINOR = "A_FLAT_MAJOR_F_MINOR", t.A_MAJOR_G_FLAT_MINOR = "A_MAJOR_G_FLAT_MINOR", t.B_FLAT_MAJOR_G_MINOR = "B_FLAT_MAJOR_G_MINOR", t.B_MAJOR_A_FLAT_MINOR = "B_MAJOR_A_FLAT_MINOR" })(rc || (rc = {})); var lc; (function (t) { t.MUSIC_GENERATION_MODE_UNSPECIFIED = "MUSIC_GENERATION_MODE_UNSPECIFIED", t.QUALITY = "QUALITY", t.DIVERSITY = "DIVERSITY", t.VOCALIZATION = "VOCALIZATION" })(lc || (lc = {})); var Ti; (function (t) { t.PLAYBACK_CONTROL_UNSPECIFIED = "PLAYBACK_CONTROL_UNSPECIFIED", t.PLAY = "PLAY", t.PAUSE = "PAUSE", t.STOP = "STOP", t.RESET_CONTEXT = "RESET_CONTEXT" })(Ti || (Ti = {})); class Lr { constructor(e) { const o = {}; for (const n of e.headers.entries()) o[n[0]] = n[1]; this.headers = o, this.responseInternal = e } json() { return this.responseInternal.json() } } class Ki { get text() { var e, o, n, i, r, a, c, f; if (((i = (n = (o = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || o === void 0 ? void 0 : o.content) === null || n === void 0 ? void 0 : n.parts) === null || i === void 0 ? void 0 : i.length) === 0) return; this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning text from the first one."); let u = "", p = !1; const v = []; for (const T of (f = (c = (a = (r = this.candidates) === null || r === void 0 ? void 0 : r[0]) === null || a === void 0 ? void 0 : a.content) === null || c === void 0 ? void 0 : c.parts) !== null && f !== void 0 ? f : []) { for (const [k, R] of Object.entries(T)) k !== "text" && k !== "thought" && (R !== null || R !== void 0) && v.push(k); if (typeof T.text == "string") { if (typeof T.thought == "boolean" && T.thought) continue; p = !0, u += T.text } } return v.length > 0 && console.warn(`there are non-text parts ${v} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`), p ? u : void 0 } get data() { var e, o, n, i, r, a, c, f; if (((i = (n = (o = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || o === void 0 ? void 0 : o.content) === null || n === void 0 ? void 0 : n.parts) === null || i === void 0 ? void 0 : i.length) === 0) return; this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning data from the first one."); let u = ""; const p = []; for (const v of (f = (c = (a = (r = this.candidates) === null || r === void 0 ? void 0 : r[0]) === null || a === void 0 ? void 0 : a.content) === null || c === void 0 ? void 0 : c.parts) !== null && f !== void 0 ? f : []) { for (const [T, k] of Object.entries(v)) T !== "inlineData" && (k !== null || k !== void 0) && p.push(T); v.inlineData && typeof v.inlineData.data == "string" && (u += atob(v.inlineData.data)) } return p.length > 0 && console.warn(`there are non-data parts ${p} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`), u.length > 0 ? btoa(u) : void 0 } get functionCalls() { var e, o, n, i, r, a, c, f; if (((i = (n = (o = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || o === void 0 ? void 0 : o.content) === null || n === void 0 ? void 0 : n.parts) === null || i === void 0 ? void 0 : i.length) === 0) return; this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning function calls from the first one."); const u = (f = (c = (a = (r = this.candidates) === null || r === void 0 ? void 0 : r[0]) === null || a === void 0 ? void 0 : a.content) === null || c === void 0 ? void 0 : c.parts) === null || f === void 0 ? void 0 : f.filter(p => p.functionCall).map(p => p.functionCall).filter(p => p !== void 0); if ((u == null ? void 0 : u.length) !== 0) return u } get executableCode() { var e, o, n, i, r, a, c, f, u; if (((i = (n = (o = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || o === void 0 ? void 0 : o.content) === null || n === void 0 ? void 0 : n.parts) === null || i === void 0 ? void 0 : i.length) === 0) return; this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning executable code from the first one."); const p = (f = (c = (a = (r = this.candidates) === null || r === void 0 ? void 0 : r[0]) === null || a === void 0 ? void 0 : a.content) === null || c === void 0 ? void 0 : c.parts) === null || f === void 0 ? void 0 : f.filter(v => v.executableCode).map(v => v.executableCode).filter(v => v !== void 0); if ((p == null ? void 0 : p.length) !== 0) return (u = p == null ? void 0 : p[0]) === null || u === void 0 ? void 0 : u.code } get codeExecutionResult() { var e, o, n, i, r, a, c, f, u; if (((i = (n = (o = (e = this.candidates) === null || e === void 0 ? void 0 : e[0]) === null || o === void 0 ? void 0 : o.content) === null || n === void 0 ? void 0 : n.parts) === null || i === void 0 ? void 0 : i.length) === 0) return; this.candidates && this.candidates.length > 1 && console.warn("there are multiple candidates in the response, returning code execution result from the first one."); const p = (f = (c = (a = (r = this.candidates) === null || r === void 0 ? void 0 : r[0]) === null || a === void 0 ? void 0 : a.content) === null || c === void 0 ? void 0 : c.parts) === null || f === void 0 ? void 0 : f.filter(v => v.codeExecutionResult).map(v => v.codeExecutionResult).filter(v => v !== void 0); if ((p == null ? void 0 : p.length) !== 0) return (u = p == null ? void 0 : p[0]) === null || u === void 0 ? void 0 : u.output } } class dc { } class cc { } class Gf { } class Of { } class Hf { } class Bf { } class uc { } class fc { } class pc { } class Jf { } class Ps { _fromAPIResponse({ apiResponse: e, isVertexAI: o }) { const n = new Ps; let i; const r = e; return o ? i = Df(r) : i = Rf(r), Object.assign(n, i), n } } class mc { } class gc { } class hc { } class Wf { } class zf { } class Yf { } class yc { } class Kf { get text() { var e, o, n; let i = "", r = !1; const a = []; for (const c of (n = (o = (e = this.serverContent) === null || e === void 0 ? void 0 : e.modelTurn) === null || o === void 0 ? void 0 : o.parts) !== null && n !== void 0 ? n : []) { for (const [f, u] of Object.entries(c)) f !== "text" && f !== "thought" && u !== null && a.push(f); if (typeof c.text == "string") { if (typeof c.thought == "boolean" && c.thought) continue; r = !0, i += c.text } } return a.length > 0 && console.warn(`there are non-text parts ${a} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`), r ? i : void 0 } get data() { var e, o, n; let i = ""; const r = []; for (const a of (n = (o = (e = this.serverContent) === null || e === void 0 ? void 0 : e.modelTurn) === null || o === void 0 ? void 0 : o.parts) !== null && n !== void 0 ? n : []) { for (const [c, f] of Object.entries(a)) c !== "inlineData" && f !== null && r.push(c); a.inlineData && typeof a.inlineData.data == "string" && (i += atob(a.inlineData.data)) } return r.length > 0 && console.warn(`there are non-data parts ${r} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`), i.length > 0 ? btoa(i) : void 0 } } class Xf { get audioChunk() { if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0) return this.serverContent.audioChunks[0] } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Ae(t, e) { if (!e || typeof e != "string") throw new Error("model is required and must be a string"); if (t.isVertexAI()) { if (e.startsWith("publishers/") || e.startsWith("projects/") || e.startsWith("models/")) return e; if (e.indexOf("/") >= 0) { const o = e.split("/", 2); return `publishers/${o[0]}/models/${o[1]}` } else return `publishers/google/models/${e}` } else return e.startsWith("models/") || e.startsWith("tunedModels/") ? e : `models/${e}` } function $c(t, e) { const o = Ae(t, e); return o ? o.startsWith("publishers/") && t.isVertexAI() ? `projects/${t.getProject()}/locations/${t.getLocation()}/${o}` : o.startsWith("models/") && t.isVertexAI() ? `projects/${t.getProject()}/locations/${t.getLocation()}/publishers/google/${o}` : o : "" } function qc(t) { return Array.isArray(t) ? t.map(e => Ms(e)) : [Ms(t)] } function Ms(t) { if (typeof t == "object" && t !== null) return t; throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof t}`) } function Vc(t) { const e = Ms(t); if (e.mimeType && e.mimeType.startsWith("image/")) return e; throw new Error(`Unsupported mime type: ${e.mimeType}`) } function Gc(t) { const e = Ms(t); if (e.mimeType && e.mimeType.startsWith("audio/")) return e; throw new Error(`Unsupported mime type: ${e.mimeType}`) } function vc(t) { if (t == null) throw new Error("PartUnion is required"); if (typeof t == "object") return t; if (typeof t == "string") return { text: t }; throw new Error(`Unsupported part type: ${typeof t}`) } function Oc(t) { if (t == null || Array.isArray(t) && t.length === 0) throw new Error("PartListUnion is required"); return Array.isArray(t) ? t.map(e => vc(e)) : [vc(t)] } function _r(t) { return t != null && typeof t == "object" && "parts" in t && Array.isArray(t.parts) } function Tc(t) { return t != null && typeof t == "object" && "functionCall" in t } function Ec(t) { return t != null && typeof t == "object" && "functionResponse" in t } function ht(t) { if (t == null) throw new Error("ContentUnion is required"); return _r(t) ? t : { role: "user", parts: Oc(t) } } function Pr(t, e) { if (!e) return []; if (t.isVertexAI() && Array.isArray(e)) return e.flatMap(o => { const n = ht(o); return n.parts && n.parts.length > 0 && n.parts[0].text !== void 0 ? [n.parts[0].text] : [] }); if (t.isVertexAI()) { const o = ht(e); return o.parts && o.parts.length > 0 && o.parts[0].text !== void 0 ? [o.parts[0].text] : [] } return Array.isArray(e) ? e.map(o => ht(o)) : [ht(e)] } function zt(t) { if (t == null || Array.isArray(t) && t.length === 0) throw new Error("contents are required"); if (!Array.isArray(t)) { if (Tc(t) || Ec(t)) throw new Error("To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them"); return [ht(t)] } const e = [], o = [], n = _r(t[0]); for (const i of t) { const r = _r(i); if (r != n) throw new Error("Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them"); if (r) e.push(i); else { if (Tc(i) || Ec(i)) throw new Error("To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them"); o.push(i) } } return n || e.push({ role: "user", parts: Oc(o) }), e } function Zf(t, e) { t.includes("null") && (e.nullable = !0); const o = t.filter(n => n !== "null"); if (o.length === 1) e.type = Object.values(Je).includes(o[0].toUpperCase()) ? o[0].toUpperCase() : Je.TYPE_UNSPECIFIED; else { e.anyOf = []; for (const n of o) e.anyOf.push({ type: Object.values(Je).includes(n.toUpperCase()) ? n.toUpperCase() : Je.TYPE_UNSPECIFIED }) } } function Ei(t) { const e = {}, o = ["items"], n = ["anyOf"], i = ["properties"]; if (t.type && t.anyOf) throw new Error("type and anyOf cannot be both populated."); const r = t.anyOf; r != null && r.length == 2 && (r[0].type === "null" ? (e.nullable = !0, t = r[1]) : r[1].type === "null" && (e.nullable = !0, t = r[0])), t.type instanceof Array && Zf(t.type, e); for (const [a, c] of Object.entries(t)) if (c != null) if (a == "type") { if (c === "null") throw new Error("type: null can not be the only possible type for the field."); if (c instanceof Array) continue; e.type = Object.values(Je).includes(c.toUpperCase()) ? c.toUpperCase() : Je.TYPE_UNSPECIFIED } else if (o.includes(a)) e[a] = Ei(c); else if (n.includes(a)) { const f = []; for (const u of c) { if (u.type == "null") { e.nullable = !0; continue } f.push(Ei(u)) } e[a] = f } else if (i.includes(a)) { const f = {}; for (const [u, p] of Object.entries(c)) f[u] = Ei(p); e[a] = f } else { if (a === "additionalProperties") continue; e[a] = c } return e } function Mr(t) { return Ei(t) } function Fr(t) { if (typeof t == "object") return t; if (typeof t == "string") return { voiceConfig: { prebuiltVoiceConfig: { voiceName: t } } }; throw new Error(`Unsupported speechConfig type: ${typeof t}`) } function Ur(t) { if ("multiSpeakerVoiceConfig" in t) throw new Error("multiSpeakerVoiceConfig is not supported in the live API."); return t } function wi(t) { if (t.functionDeclarations) for (const e of t.functionDeclarations) e.parameters && (Object.keys(e.parameters).includes("$schema") ? e.parametersJsonSchema || (e.parametersJsonSchema = e.parameters, delete e.parameters) : e.parameters = Ei(e.parameters)), e.response && (Object.keys(e.response).includes("$schema") ? e.responseJsonSchema || (e.responseJsonSchema = e.response, delete e.response) : e.response = Ei(e.response)); return t } function Ii(t) { if (t == null) throw new Error("tools is required"); if (!Array.isArray(t)) throw new Error("tools is required and must be an array of Tools"); const e = []; for (const o of t) e.push(o); return e } function Qf(t, e, o, n = 1) { const i = !e.startsWith(`${o}/`) && e.split("/").length === n; return t.isVertexAI() ? e.startsWith("projects/") ? e : e.startsWith("locations/") ? `projects/${t.getProject()}/${e}` : e.startsWith(`${o}/`) ? `projects/${t.getProject()}/locations/${t.getLocation()}/${e}` : i ? `projects/${t.getProject()}/locations/${t.getLocation()}/${o}/${e}` : e : i ? `${o}/${e}` : e } function Fn(t, e) { if (typeof e != "string") throw new Error("name must be a string"); return Qf(t, e, "cachedContents") } function Hc(t) { switch (t) { case "STATE_UNSPECIFIED": return "JOB_STATE_UNSPECIFIED"; case "CREATING": return "JOB_STATE_RUNNING"; case "ACTIVE": return "JOB_STATE_SUCCEEDED"; case "FAILED": return "JOB_STATE_FAILED"; default: return t } } function oo(t) { return Nr(t) } function jf(t) { return t != null && typeof t == "object" && "name" in t } function ep(t) { return t != null && typeof t == "object" && "video" in t } function tp(t) { return t != null && typeof t == "object" && "uri" in t } function Bc(t) { var e; let o; if (jf(t) && (o = t.name), !(tp(t) && (o = t.uri, o === void 0)) && !(ep(t) && (o = (e = t.video) === null || e === void 0 ? void 0 : e.uri, o === void 0))) { if (typeof t == "string" && (o = t), o === void 0) throw new Error("Could not extract file name from the provided input."); if (o.startsWith("https://")) { const i = o.split("files/")[1].match(/[a-z0-9]+/); if (i === null) throw new Error(`Could not extract file name from URI ${o}`); o = i[0] } else o.startsWith("files/") && (o = o.split("files/")[1]); return o } } function Jc(t, e) { let o; return t.isVertexAI() ? o = e ? "publishers/google/models" : "models" : o = e ? "models" : "tunedModels", o } function Wc(t) { for (const e of ["models", "tunedModels", "publisherModels"]) if (np(t, e)) return t[e]; return [] } function np(t, e) { return t !== null && typeof t == "object" && e in t } function op(t, e = {}) { const o = t, n = { name: o.name, description: o.description, parametersJsonSchema: o.inputSchema }; return o.outputSchema && (n.responseJsonSchema = o.outputSchema), e.behavior && (n.behavior = e.behavior), { functionDeclarations: [n] } } function ip(t, e = {}) { const o = [], n = new Set; for (const i of t) { const r = i.name; if (n.has(r)) throw new Error(`Duplicate function name ${r} found in MCP tools. Please ensure function names are unique.`); n.add(r); const a = op(i, e); a.functionDeclarations && o.push(...a.functionDeclarations) } return { functionDeclarations: o } } function zc(t, e) { let o; if (typeof e == "string") if (t.isVertexAI()) if (e.startsWith("gs://")) o = { format: "jsonl", gcsUri: [e] }; else if (e.startsWith("bq://")) o = { format: "bigquery", bigqueryUri: e }; else throw new Error(`Unsupported string source for Vertex AI: ${e}`); else if (e.startsWith("files/")) o = { fileName: e }; else throw new Error(`Unsupported string source for Gemini API: ${e}`); else if (Array.isArray(e)) { if (t.isVertexAI()) throw new Error("InlinedRequest[] is not supported in Vertex AI."); o = { inlinedRequests: e } } else o = e; const n = [o.gcsUri, o.bigqueryUri].filter(Boolean).length, i = [o.inlinedRequests, o.fileName].filter(Boolean).length; if (t.isVertexAI()) { if (i > 0 || n !== 1) throw new Error("Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.") } else if (n > 0 || i !== 1) throw new Error("Exactly one of `inlinedRequests`, `fileName`, must be set for Gemini API."); return o } function sp(t) { if (typeof t != "string") return t; const e = t; if (e.startsWith("gs://")) return { format: "jsonl", gcsUri: e }; if (e.startsWith("bq://")) return { format: "bigquery", bigqueryUri: e }; throw new Error(`Unsupported destination: ${e}`) } function Yc(t) { if (typeof t != "object" || t === null) return {}; const e = t, o = e.inlinedResponses; if (typeof o != "object" || o === null) return t; const i = o.inlinedResponses; if (!Array.isArray(i) || i.length === 0) return t; let r = !1; for (const a of i) { if (typeof a != "object" || a === null) continue; const f = a.response; if (typeof f != "object" || f === null) continue; if (f.embedding !== void 0) { r = !0; break } } return r && (e.inlinedEmbedContentResponses = e.inlinedResponses, delete e.inlinedResponses), t } function Si(t, e) { const o = e; if (!t.isVertexAI()) { if (/batches\/[^/]+$/.test(o)) return o.split("/").pop(); throw new Error(`Invalid batch job name: ${o}.`) } if (/^projects\/[^/]+\/locations\/[^/]+\/batchPredictionJobs\/[^/]+$/.test(o)) return o.split("/").pop(); if (/^\d+$/.test(o)) return o; throw new Error(`Invalid batch job name: ${o}.`) } function Kc(t) { const e = t; return e === "BATCH_STATE_UNSPECIFIED" ? "JOB_STATE_UNSPECIFIED" : e === "BATCH_STATE_PENDING" ? "JOB_STATE_PENDING" : e === "BATCH_STATE_RUNNING" ? "JOB_STATE_RUNNING" : e === "BATCH_STATE_SUCCEEDED" ? "JOB_STATE_SUCCEEDED" : e === "BATCH_STATE_FAILED" ? "JOB_STATE_FAILED" : e === "BATCH_STATE_CANCELLED" ? "JOB_STATE_CANCELLED" : e === "BATCH_STATE_EXPIRED" ? "JOB_STATE_EXPIRED" : e }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function ap(t) { const e = {}, o = s(t, ["responsesFile"]); o != null && l(e, ["fileName"], o); const n = s(t, ["inlinedResponses", "inlinedResponses"]); if (n != null) { let r = n; Array.isArray(r) && (r = r.map(a => Up(a))), l(e, ["inlinedResponses"], r) } const i = s(t, ["inlinedEmbedContentResponses", "inlinedResponses"]); if (i != null) { let r = i; Array.isArray(r) && (r = r.map(a => a)), l(e, ["inlinedEmbedContentResponses"], r) } return e } function rp(t) { const e = {}, o = s(t, ["predictionsFormat"]); o != null && l(e, ["format"], o); const n = s(t, ["gcsDestination", "outputUriPrefix"]); n != null && l(e, ["gcsUri"], n); const i = s(t, ["bigqueryDestination", "outputUri"]); return i != null && l(e, ["bigqueryUri"], i), e } function lp(t) { const e = {}, o = s(t, ["format"]); o != null && l(e, ["predictionsFormat"], o); const n = s(t, ["gcsUri"]); n != null && l(e, ["gcsDestination", "outputUriPrefix"], n); const i = s(t, ["bigqueryUri"]); if (i != null && l(e, ["bigqueryDestination", "outputUri"], i), s(t, ["fileName"]) !== void 0) throw new Error("fileName parameter is not supported in Vertex AI."); if (s(t, ["inlinedResponses"]) !== void 0) throw new Error("inlinedResponses parameter is not supported in Vertex AI."); if (s(t, ["inlinedEmbedContentResponses"]) !== void 0) throw new Error("inlinedEmbedContentResponses parameter is not supported in Vertex AI."); return e } function Ds(t) { const e = {}, o = s(t, ["name"]); o != null && l(e, ["name"], o); const n = s(t, ["metadata", "displayName"]); n != null && l(e, ["displayName"], n); const i = s(t, ["metadata", "state"]); i != null && l(e, ["state"], Kc(i)); const r = s(t, ["metadata", "createTime"]); r != null && l(e, ["createTime"], r); const a = s(t, ["metadata", "endTime"]); a != null && l(e, ["endTime"], a); const c = s(t, ["metadata", "updateTime"]); c != null && l(e, ["updateTime"], c); const f = s(t, ["metadata", "model"]); f != null && l(e, ["model"], f); const u = s(t, ["metadata", "output"]); return u != null && l(e, ["dest"], ap(Yc(u))), e } function Ar(t) { const e = {}, o = s(t, ["name"]); o != null && l(e, ["name"], o); const n = s(t, ["displayName"]); n != null && l(e, ["displayName"], n); const i = s(t, ["state"]); i != null && l(e, ["state"], Kc(i)); const r = s(t, ["error"]); r != null && l(e, ["error"], r); const a = s(t, ["createTime"]); a != null && l(e, ["createTime"], a); const c = s(t, ["startTime"]); c != null && l(e, ["startTime"], c); const f = s(t, ["endTime"]); f != null && l(e, ["endTime"], f); const u = s(t, ["updateTime"]); u != null && l(e, ["updateTime"], u); const p = s(t, ["model"]); p != null && l(e, ["model"], p); const v = s(t, ["inputConfig"]); v != null && l(e, ["src"], dp(v)); const T = s(t, ["outputConfig"]); return T != null && l(e, ["dest"], rp(Yc(T))), e } function dp(t) { const e = {}, o = s(t, ["instancesFormat"]); o != null && l(e, ["format"], o); const n = s(t, ["gcsSource", "uris"]); n != null && l(e, ["gcsUri"], n); const i = s(t, ["bigquerySource", "inputUri"]); return i != null && l(e, ["bigqueryUri"], i), e } function cp(t, e) { const o = {}; if (s(e, ["format"]) !== void 0) throw new Error("format parameter is not supported in Gemini API."); if (s(e, ["gcsUri"]) !== void 0) throw new Error("gcsUri parameter is not supported in Gemini API."); if (s(e, ["bigqueryUri"]) !== void 0) throw new Error("bigqueryUri parameter is not supported in Gemini API."); const n = s(e, ["fileName"]); n != null && l(o, ["fileName"], n); const i = s(e, ["inlinedRequests"]); if (i != null) { let r = i; Array.isArray(r) && (r = r.map(a => Fp(t, a))), l(o, ["requests", "requests"], r) } return o } function up(t) { const e = {}, o = s(t, ["format"]); o != null && l(e, ["instancesFormat"], o); const n = s(t, ["gcsUri"]); n != null && l(e, ["gcsSource", "uris"], n); const i = s(t, ["bigqueryUri"]); if (i != null && l(e, ["bigquerySource", "inputUri"], i), s(t, ["fileName"]) !== void 0) throw new Error("fileName parameter is not supported in Vertex AI."); if (s(t, ["inlinedRequests"]) !== void 0) throw new Error("inlinedRequests parameter is not supported in Vertex AI."); return e } function fp(t) { const e = {}; if (s(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const o = s(t, ["data"]); o != null && l(e, ["data"], o); const n = s(t, ["mimeType"]); return n != null && l(e, ["mimeType"], n), e } function pp(t, e) { const o = {}, n = s(e, ["name"]); return n != null && l(o, ["_url", "name"], Si(t, n)), o } function mp(t, e) { const o = {}, n = s(e, ["name"]); return n != null && l(o, ["_url", "name"], Si(t, n)), o } function gp(t) { const e = {}, o = s(t, ["content"]); o != null && l(e, ["content"], o); const n = s(t, ["citationMetadata"]); n != null && l(e, ["citationMetadata"], hp(n)); const i = s(t, ["tokenCount"]); i != null && l(e, ["tokenCount"], i); const r = s(t, ["finishReason"]); r != null && l(e, ["finishReason"], r); const a = s(t, ["urlContextMetadata"]); a != null && l(e, ["urlContextMetadata"], a); const c = s(t, ["avgLogprobs"]); c != null && l(e, ["avgLogprobs"], c); const f = s(t, ["groundingMetadata"]); f != null && l(e, ["groundingMetadata"], f); const u = s(t, ["index"]); u != null && l(e, ["index"], u); const p = s(t, ["logprobsResult"]); p != null && l(e, ["logprobsResult"], p); const v = s(t, ["safetyRatings"]); if (v != null) { let T = v; Array.isArray(T) && (T = T.map(k => k)), l(e, ["safetyRatings"], T) } return e } function hp(t) { const e = {}, o = s(t, ["citationSources"]); if (o != null) { let n = o; Array.isArray(n) && (n = n.map(i => i)), l(e, ["citations"], n) } return e } function Xc(t) { const e = {}, o = s(t, ["parts"]); if (o != null) { let i = o; Array.isArray(i) && (i = i.map(r => Bp(r))), l(e, ["parts"], i) } const n = s(t, ["role"]); return n != null && l(e, ["role"], n), e } function yp(t, e) { const o = {}, n = s(t, ["displayName"]); if (e !== void 0 && n != null && l(e, ["batch", "displayName"], n), s(t, ["dest"]) !== void 0) throw new Error("dest parameter is not supported in Gemini API."); return o } function vp(t, e) { const o = {}, n = s(t, ["displayName"]); e !== void 0 && n != null && l(e, ["displayName"], n); const i = s(t, ["dest"]); return e !== void 0 && i != null && l(e, ["outputConfig"], lp(sp(i))), o } function bc(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["_url", "model"], Ae(t, n)); const i = s(e, ["src"]); i != null && l(o, ["batch", "inputConfig"], cp(t, zc(t, i))); const r = s(e, ["config"]); return r != null && yp(r, o), o } function Tp(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["model"], Ae(t, n)); const i = s(e, ["src"]); i != null && l(o, ["inputConfig"], up(zc(t, i))); const r = s(e, ["config"]); return r != null && vp(r, o), o } function Ep(t, e) { const o = {}, n = s(t, ["displayName"]); return e !== void 0 && n != null && l(e, ["batch", "displayName"], n), o } function bp(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["_url", "model"], Ae(t, n)); const i = s(e, ["src"]); i != null && l(o, ["batch", "inputConfig"], Ap(t, i)); const r = s(e, ["config"]); return r != null && Ep(r, o), o } function Cp(t, e) { const o = {}, n = s(e, ["name"]); return n != null && l(o, ["_url", "name"], Si(t, n)), o } function wp(t, e) { const o = {}, n = s(e, ["name"]); return n != null && l(o, ["_url", "name"], Si(t, n)), o } function Ip(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); o != null && l(e, ["sdkHttpResponse"], o); const n = s(t, ["name"]); n != null && l(e, ["name"], n); const i = s(t, ["done"]); i != null && l(e, ["done"], i); const r = s(t, ["error"]); return r != null && l(e, ["error"], r), e } function Sp(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); o != null && l(e, ["sdkHttpResponse"], o); const n = s(t, ["name"]); n != null && l(e, ["name"], n); const i = s(t, ["done"]); i != null && l(e, ["done"], i); const r = s(t, ["error"]); return r != null && l(e, ["error"], r), e } function Lp(t, e) { const o = {}, n = s(e, ["contents"]); if (n != null) { let r = Pr(t, n); Array.isArray(r) && (r = r.map(a => a)), l(o, ["requests[]", "request", "content"], r) } const i = s(e, ["config"]); return i != null && (l(o, ["_self"], _p(i, o)), xf(o, { "requests[].*": "requests[].request.*" })), o } function _p(t, e) { const o = {}, n = s(t, ["taskType"]); e !== void 0 && n != null && l(e, ["requests[]", "taskType"], n); const i = s(t, ["title"]); e !== void 0 && i != null && l(e, ["requests[]", "title"], i); const r = s(t, ["outputDimensionality"]); if (e !== void 0 && r != null && l(e, ["requests[]", "outputDimensionality"], r), s(t, ["mimeType"]) !== void 0) throw new Error("mimeType parameter is not supported in Gemini API."); if (s(t, ["autoTruncate"]) !== void 0) throw new Error("autoTruncate parameter is not supported in Gemini API."); return o } function Ap(t, e) { const o = {}, n = s(e, ["fileName"]); n != null && l(o, ["file_name"], n); const i = s(e, ["inlinedRequests"]); return i != null && l(o, ["requests"], Lp(t, i)), o } function xp(t) { const e = {}; if (s(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const o = s(t, ["fileUri"]); o != null && l(e, ["fileUri"], o); const n = s(t, ["mimeType"]); return n != null && l(e, ["mimeType"], n), e } function kp(t, e, o) { const n = {}, i = s(e, ["systemInstruction"]); o !== void 0 && i != null && l(o, ["systemInstruction"], Xc(ht(i))); const r = s(e, ["temperature"]); r != null && l(n, ["temperature"], r); const a = s(e, ["topP"]); a != null && l(n, ["topP"], a); const c = s(e, ["topK"]); c != null && l(n, ["topK"], c); const f = s(e, ["candidateCount"]); f != null && l(n, ["candidateCount"], f); const u = s(e, ["maxOutputTokens"]); u != null && l(n, ["maxOutputTokens"], u); const p = s(e, ["stopSequences"]); p != null && l(n, ["stopSequences"], p); const v = s(e, ["responseLogprobs"]); v != null && l(n, ["responseLogprobs"], v); const T = s(e, ["logprobs"]); T != null && l(n, ["logprobs"], T); const k = s(e, ["presencePenalty"]); k != null && l(n, ["presencePenalty"], k); const R = s(e, ["frequencyPenalty"]); R != null && l(n, ["frequencyPenalty"], R); const $ = s(e, ["seed"]); $ != null && l(n, ["seed"], $); const N = s(e, ["responseMimeType"]); N != null && l(n, ["responseMimeType"], N); const P = s(e, ["responseSchema"]); P != null && l(n, ["responseSchema"], Mr(P)); const W = s(e, ["responseJsonSchema"]); if (W != null && l(n, ["responseJsonSchema"], W), s(e, ["routingConfig"]) !== void 0) throw new Error("routingConfig parameter is not supported in Gemini API."); if (s(e, ["modelSelectionConfig"]) !== void 0) throw new Error("modelSelectionConfig parameter is not supported in Gemini API."); const K = s(e, ["safetySettings"]); if (o !== void 0 && K != null) { let $e = K; Array.isArray($e) && ($e = $e.map(Lt => Jp(Lt))), l(o, ["safetySettings"], $e) } const j = s(e, ["tools"]); if (o !== void 0 && j != null) { let $e = Ii(j); Array.isArray($e) && ($e = $e.map(Lt => Wp(wi(Lt)))), l(o, ["tools"], $e) } const le = s(e, ["toolConfig"]); if (o !== void 0 && le != null && l(o, ["toolConfig"], le), s(e, ["labels"]) !== void 0) throw new Error("labels parameter is not supported in Gemini API."); const de = s(e, ["cachedContent"]); o !== void 0 && de != null && l(o, ["cachedContent"], Fn(t, de)); const ue = s(e, ["responseModalities"]); ue != null && l(n, ["responseModalities"], ue); const Fe = s(e, ["mediaResolution"]); Fe != null && l(n, ["mediaResolution"], Fe); const re = s(e, ["speechConfig"]); if (re != null && l(n, ["speechConfig"], Fr(re)), s(e, ["audioTimestamp"]) !== void 0) throw new Error("audioTimestamp parameter is not supported in Gemini API."); const ye = s(e, ["thinkingConfig"]); ye != null && l(n, ["thinkingConfig"], ye); const xe = s(e, ["imageConfig"]); return xe != null && l(n, ["imageConfig"], xe), n } function Rp(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); o != null && l(e, ["sdkHttpResponse"], o); const n = s(t, ["candidates"]); if (n != null) { let f = n; Array.isArray(f) && (f = f.map(u => gp(u))), l(e, ["candidates"], f) } const i = s(t, ["modelVersion"]); i != null && l(e, ["modelVersion"], i); const r = s(t, ["promptFeedback"]); r != null && l(e, ["promptFeedback"], r); const a = s(t, ["responseId"]); a != null && l(e, ["responseId"], a); const c = s(t, ["usageMetadata"]); return c != null && l(e, ["usageMetadata"], c), e } function Dp(t, e) { const o = {}, n = s(e, ["name"]); return n != null && l(o, ["_url", "name"], Si(t, n)), o } function Np(t, e) { const o = {}, n = s(e, ["name"]); return n != null && l(o, ["_url", "name"], Si(t, n)), o } function Pp(t) { const e = {}; if (s(t, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API."); const o = s(t, ["enableWidget"]); return o != null && l(e, ["enableWidget"], o), e } function Mp(t) { const e = {}, o = s(t, ["timeRangeFilter"]); if (o != null && l(e, ["timeRangeFilter"], o), s(t, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API."); return e } function Fp(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["request", "model"], Ae(t, n)); const i = s(e, ["contents"]); if (i != null) { let c = zt(i); Array.isArray(c) && (c = c.map(f => Xc(f))), l(o, ["request", "contents"], c) } const r = s(e, ["metadata"]); r != null && l(o, ["metadata"], r); const a = s(e, ["config"]); return a != null && l(o, ["request", "generationConfig"], kp(t, a, s(o, ["request"], {}))), o } function Up(t) { const e = {}, o = s(t, ["response"]); o != null && l(e, ["response"], Rp(o)); const n = s(t, ["error"]); return n != null && l(e, ["error"], n), e } function $p(t, e) { const o = {}, n = s(t, ["pageSize"]); e !== void 0 && n != null && l(e, ["_query", "pageSize"], n); const i = s(t, ["pageToken"]); if (e !== void 0 && i != null && l(e, ["_query", "pageToken"], i), s(t, ["filter"]) !== void 0) throw new Error("filter parameter is not supported in Gemini API."); return o } function qp(t, e) { const o = {}, n = s(t, ["pageSize"]); e !== void 0 && n != null && l(e, ["_query", "pageSize"], n); const i = s(t, ["pageToken"]); e !== void 0 && i != null && l(e, ["_query", "pageToken"], i); const r = s(t, ["filter"]); return e !== void 0 && r != null && l(e, ["_query", "filter"], r), o } function Vp(t) { const e = {}, o = s(t, ["config"]); return o != null && $p(o, e), e } function Gp(t) { const e = {}, o = s(t, ["config"]); return o != null && qp(o, e), e } function Op(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); o != null && l(e, ["sdkHttpResponse"], o); const n = s(t, ["nextPageToken"]); n != null && l(e, ["nextPageToken"], n); const i = s(t, ["operations"]); if (i != null) { let r = i; Array.isArray(r) && (r = r.map(a => Ds(a))), l(e, ["batchJobs"], r) } return e } function Hp(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); o != null && l(e, ["sdkHttpResponse"], o); const n = s(t, ["nextPageToken"]); n != null && l(e, ["nextPageToken"], n); const i = s(t, ["batchPredictionJobs"]); if (i != null) { let r = i; Array.isArray(r) && (r = r.map(a => Ar(a))), l(e, ["batchJobs"], r) } return e } function Bp(t) { const e = {}, o = s(t, ["videoMetadata"]); o != null && l(e, ["videoMetadata"], o); const n = s(t, ["thought"]); n != null && l(e, ["thought"], n); const i = s(t, ["inlineData"]); i != null && l(e, ["inlineData"], fp(i)); const r = s(t, ["fileData"]); r != null && l(e, ["fileData"], xp(r)); const a = s(t, ["thoughtSignature"]); a != null && l(e, ["thoughtSignature"], a); const c = s(t, ["functionCall"]); c != null && l(e, ["functionCall"], c); const f = s(t, ["codeExecutionResult"]); f != null && l(e, ["codeExecutionResult"], f); const u = s(t, ["executableCode"]); u != null && l(e, ["executableCode"], u); const p = s(t, ["functionResponse"]); p != null && l(e, ["functionResponse"], p); const v = s(t, ["text"]); return v != null && l(e, ["text"], v), e } function Jp(t) { const e = {}; if (s(t, ["method"]) !== void 0) throw new Error("method parameter is not supported in Gemini API."); const o = s(t, ["category"]); o != null && l(e, ["category"], o); const n = s(t, ["threshold"]); return n != null && l(e, ["threshold"], n), e } function Wp(t) { const e = {}, o = s(t, ["functionDeclarations"]); if (o != null) { let u = o; Array.isArray(u) && (u = u.map(p => p)), l(e, ["functionDeclarations"], u) } if (s(t, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API."); const n = s(t, ["googleSearch"]); n != null && l(e, ["googleSearch"], Mp(n)); const i = s(t, ["googleSearchRetrieval"]); if (i != null && l(e, ["googleSearchRetrieval"], i), s(t, ["enterpriseWebSearch"]) !== void 0) throw new Error("enterpriseWebSearch parameter is not supported in Gemini API."); const r = s(t, ["googleMaps"]); r != null && l(e, ["googleMaps"], Pp(r)); const a = s(t, ["urlContext"]); a != null && l(e, ["urlContext"], a); const c = s(t, ["computerUse"]); c != null && l(e, ["computerUse"], c); const f = s(t, ["codeExecution"]); return f != null && l(e, ["codeExecution"], f), e }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */var Io; (function (t) { t.PAGED_ITEM_BATCH_JOBS = "batchJobs", t.PAGED_ITEM_MODELS = "models", t.PAGED_ITEM_TUNING_JOBS = "tuningJobs", t.PAGED_ITEM_FILES = "files", t.PAGED_ITEM_CACHED_CONTENTS = "cachedContents" })(Io || (Io = {})); class Zi { constructor(e, o, n, i) { this.pageInternal = [], this.paramsInternal = {}, this.requestInternal = o, this.init(e, n, i) } init(e, o, n) { var i, r; this.nameInternal = e, this.pageInternal = o[this.nameInternal] || [], this.sdkHttpResponseInternal = o == null ? void 0 : o.sdkHttpResponse, this.idxInternal = 0; let a = { config: {} }; !n || Object.keys(n).length === 0 ? a = { config: {} } : typeof n == "object" ? a = Object.assign({}, n) : a = n, a.config && (a.config.pageToken = o.nextPageToken), this.paramsInternal = a, this.pageInternalSize = (r = (i = a.config) === null || i === void 0 ? void 0 : i.pageSize) !== null && r !== void 0 ? r : this.pageInternal.length } initNextPage(e) { this.init(this.nameInternal, e, this.paramsInternal) } get page() { return this.pageInternal } get name() { return this.nameInternal } get pageSize() { return this.pageInternalSize } get sdkHttpResponse() { return this.sdkHttpResponseInternal } get params() { return this.paramsInternal } get pageLength() { return this.pageInternal.length } getItem(e) { return this.pageInternal[e] } [Symbol.asyncIterator]() { return { next: async () => { if (this.idxInternal >= this.pageLength) if (this.hasNextPage()) await this.nextPage(); else return { value: void 0, done: !0 }; const e = this.getItem(this.idxInternal); return this.idxInternal += 1, { value: e, done: !1 } }, return: async () => ({ value: void 0, done: !0 }) } } async nextPage() { if (!this.hasNextPage()) throw new Error("No more pages to fetch."); const e = await this.requestInternal(this.params); return this.initNextPage(e), this.page } hasNextPage() { var e; return ((e = this.params.config) === null || e === void 0 ? void 0 : e.pageToken) !== void 0 } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class zp extends So { constructor(e) { super(), this.apiClient = e, this.create = async o => (this.apiClient.isVertexAI() && (o.config = this.formatDestination(o.src, o.config)), this.createInternal(o)), this.createEmbeddings = async o => { if (console.warn("batches.createEmbeddings() is experimental and may change without notice."), this.apiClient.isVertexAI()) throw new Error("Vertex AI does not support batches.createEmbeddings."); return this.createEmbeddingsInternal(o) }, this.list = async (o = {}) => new Zi(Io.PAGED_ITEM_BATCH_JOBS, n => this.listInternal(n), await this.listInternal(o), o) } createInlinedGenerateContentRequest(e) { const o = bc(this.apiClient, e), n = o._url, i = ie("{model}:batchGenerateContent", n), c = o.batch.inputConfig.requests, f = c.requests, u = []; for (const p of f) { const v = Object.assign({}, p); if (v.systemInstruction) { const T = v.systemInstruction; delete v.systemInstruction; const k = v.request; k.systemInstruction = T, v.request = k } u.push(v) } return c.requests = u, delete o.config, delete o._url, delete o._query, { path: i, body: o } } getGcsUri(e) { if (typeof e == "string") return e.startsWith("gs://") ? e : void 0; if (!Array.isArray(e) && e.gcsUri && e.gcsUri.length > 0) return e.gcsUri[0] } getBigqueryUri(e) { if (typeof e == "string") return e.startsWith("bq://") ? e : void 0; if (!Array.isArray(e)) return e.bigqueryUri } formatDestination(e, o) { const n = o ? Object.assign({}, o) : {}, i = Date.now().toString(); if (n.displayName || (n.displayName = `genaiBatchJob_${i}`), n.dest === void 0) { const r = this.getGcsUri(e), a = this.getBigqueryUri(e); if (r) r.endsWith(".jsonl") ? n.dest = `${r.slice(0, -6)}/dest` : n.dest = `${r}_dest_${i}`; else if (a) n.dest = `${a}_dest_${i}`; else throw new Error("Unsupported source for Vertex AI: No GCS or BigQuery URI found.") } return n } async createInternal(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = Tp(this.apiClient, e); return c = ie("batchPredictionJobs", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(p => p.json()), a.then(p => Ar(p)) } else { const u = bc(this.apiClient, e); return c = ie("{model}:batchGenerateContent", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }).then(p => p.json()), a.then(p => Ds(p)) } } async createEmbeddingsInternal(e) { var o, n; let i, r = "", a = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const c = bp(this.apiClient, e); return r = ie("{model}:asyncBatchEmbedContent", c._url), a = c._query, delete c._url, delete c._query, i = this.apiClient.request({ path: r, queryParams: a, body: JSON.stringify(c), httpMethod: "POST", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(f => f.json()), i.then(f => Ds(f)) } } async get(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = Np(this.apiClient, e); return c = ie("batchPredictionJobs/{name}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(p => p.json()), a.then(p => Ar(p)) } else { const u = Dp(this.apiClient, e); return c = ie("batches/{name}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }).then(p => p.json()), a.then(p => Ds(p)) } } async cancel(e) { var o, n, i, r; let a = "", c = {}; if (this.apiClient.isVertexAI()) { const f = mp(this.apiClient, e); a = ie("batchPredictionJobs/{name}:cancel", f._url), c = f._query, delete f._url, delete f._query, await this.apiClient.request({ path: a, queryParams: c, body: JSON.stringify(f), httpMethod: "POST", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }) } else { const f = pp(this.apiClient, e); a = ie("batches/{name}:cancel", f._url), c = f._query, delete f._url, delete f._query, await this.apiClient.request({ path: a, queryParams: c, body: JSON.stringify(f), httpMethod: "POST", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }) } } async listInternal(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = Gp(e); return c = ie("batchPredictionJobs", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => { const v = Hp(p), T = new yc; return Object.assign(T, v), T }) } else { const u = Vp(e); return c = ie("batches", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => { const v = Op(p), T = new yc; return Object.assign(T, v), T }) } } async delete(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = wp(this.apiClient, e); return c = ie("batchPredictionJobs/{name}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "DELETE", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => Sp(p)) } else { const u = Cp(this.apiClient, e); return c = ie("batches/{name}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "DELETE", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => Ip(p)) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Yp(t) { const e = {}; if (s(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const o = s(t, ["data"]); o != null && l(e, ["data"], o); const n = s(t, ["mimeType"]); return n != null && l(e, ["mimeType"], n), e } function Cc(t) { const e = {}, o = s(t, ["parts"]); if (o != null) { let i = o; Array.isArray(i) && (i = i.map(r => gm(r))), l(e, ["parts"], i) } const n = s(t, ["role"]); return n != null && l(e, ["role"], n), e } function Kp(t, e) { const o = {}, n = s(t, ["ttl"]); e !== void 0 && n != null && l(e, ["ttl"], n); const i = s(t, ["expireTime"]); e !== void 0 && i != null && l(e, ["expireTime"], i); const r = s(t, ["displayName"]); e !== void 0 && r != null && l(e, ["displayName"], r); const a = s(t, ["contents"]); if (e !== void 0 && a != null) { let p = zt(a); Array.isArray(p) && (p = p.map(v => Cc(v))), l(e, ["contents"], p) } const c = s(t, ["systemInstruction"]); e !== void 0 && c != null && l(e, ["systemInstruction"], Cc(ht(c))); const f = s(t, ["tools"]); if (e !== void 0 && f != null) { let p = f; Array.isArray(p) && (p = p.map(v => hm(v))), l(e, ["tools"], p) } const u = s(t, ["toolConfig"]); if (e !== void 0 && u != null && l(e, ["toolConfig"], u), s(t, ["kmsKeyName"]) !== void 0) throw new Error("kmsKeyName parameter is not supported in Gemini API."); return o } function Xp(t, e) { const o = {}, n = s(t, ["ttl"]); e !== void 0 && n != null && l(e, ["ttl"], n); const i = s(t, ["expireTime"]); e !== void 0 && i != null && l(e, ["expireTime"], i); const r = s(t, ["displayName"]); e !== void 0 && r != null && l(e, ["displayName"], r); const a = s(t, ["contents"]); if (e !== void 0 && a != null) { let v = zt(a); Array.isArray(v) && (v = v.map(T => T)), l(e, ["contents"], v) } const c = s(t, ["systemInstruction"]); e !== void 0 && c != null && l(e, ["systemInstruction"], ht(c)); const f = s(t, ["tools"]); if (e !== void 0 && f != null) { let v = f; Array.isArray(v) && (v = v.map(T => ym(T))), l(e, ["tools"], v) } const u = s(t, ["toolConfig"]); e !== void 0 && u != null && l(e, ["toolConfig"], u); const p = s(t, ["kmsKeyName"]); return e !== void 0 && p != null && l(e, ["encryption_spec", "kmsKeyName"], p), o } function Zp(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["model"], $c(t, n)); const i = s(e, ["config"]); return i != null && Kp(i, o), o } function Qp(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["model"], $c(t, n)); const i = s(e, ["config"]); return i != null && Xp(i, o), o } function jp(t, e) { const o = {}, n = s(e, ["name"]); return n != null && l(o, ["_url", "name"], Fn(t, n)), o } function em(t, e) { const o = {}, n = s(e, ["name"]); return n != null && l(o, ["_url", "name"], Fn(t, n)), o } function tm(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); return o != null && l(e, ["sdkHttpResponse"], o), e } function nm(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); return o != null && l(e, ["sdkHttpResponse"], o), e } function om(t) { const e = {}; if (s(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const o = s(t, ["fileUri"]); o != null && l(e, ["fileUri"], o); const n = s(t, ["mimeType"]); return n != null && l(e, ["mimeType"], n), e } function im(t) { const e = {}; if (s(t, ["behavior"]) !== void 0) throw new Error("behavior parameter is not supported in Vertex AI."); const o = s(t, ["description"]); o != null && l(e, ["description"], o); const n = s(t, ["name"]); n != null && l(e, ["name"], n); const i = s(t, ["parameters"]); i != null && l(e, ["parameters"], i); const r = s(t, ["parametersJsonSchema"]); r != null && l(e, ["parametersJsonSchema"], r); const a = s(t, ["response"]); a != null && l(e, ["response"], a); const c = s(t, ["responseJsonSchema"]); return c != null && l(e, ["responseJsonSchema"], c), e } function sm(t, e) { const o = {}, n = s(e, ["name"]); return n != null && l(o, ["_url", "name"], Fn(t, n)), o } function am(t, e) { const o = {}, n = s(e, ["name"]); return n != null && l(o, ["_url", "name"], Fn(t, n)), o } function rm(t) { const e = {}; if (s(t, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API."); const o = s(t, ["enableWidget"]); return o != null && l(e, ["enableWidget"], o), e } function lm(t) { const e = {}, o = s(t, ["timeRangeFilter"]); if (o != null && l(e, ["timeRangeFilter"], o), s(t, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API."); return e } function dm(t, e) { const o = {}, n = s(t, ["pageSize"]); e !== void 0 && n != null && l(e, ["_query", "pageSize"], n); const i = s(t, ["pageToken"]); return e !== void 0 && i != null && l(e, ["_query", "pageToken"], i), o } function cm(t, e) { const o = {}, n = s(t, ["pageSize"]); e !== void 0 && n != null && l(e, ["_query", "pageSize"], n); const i = s(t, ["pageToken"]); return e !== void 0 && i != null && l(e, ["_query", "pageToken"], i), o } function um(t) { const e = {}, o = s(t, ["config"]); return o != null && dm(o, e), e } function fm(t) { const e = {}, o = s(t, ["config"]); return o != null && cm(o, e), e } function pm(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); o != null && l(e, ["sdkHttpResponse"], o); const n = s(t, ["nextPageToken"]); n != null && l(e, ["nextPageToken"], n); const i = s(t, ["cachedContents"]); if (i != null) { let r = i; Array.isArray(r) && (r = r.map(a => a)), l(e, ["cachedContents"], r) } return e } function mm(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); o != null && l(e, ["sdkHttpResponse"], o); const n = s(t, ["nextPageToken"]); n != null && l(e, ["nextPageToken"], n); const i = s(t, ["cachedContents"]); if (i != null) { let r = i; Array.isArray(r) && (r = r.map(a => a)), l(e, ["cachedContents"], r) } return e } function gm(t) { const e = {}, o = s(t, ["videoMetadata"]); o != null && l(e, ["videoMetadata"], o); const n = s(t, ["thought"]); n != null && l(e, ["thought"], n); const i = s(t, ["inlineData"]); i != null && l(e, ["inlineData"], Yp(i)); const r = s(t, ["fileData"]); r != null && l(e, ["fileData"], om(r)); const a = s(t, ["thoughtSignature"]); a != null && l(e, ["thoughtSignature"], a); const c = s(t, ["functionCall"]); c != null && l(e, ["functionCall"], c); const f = s(t, ["codeExecutionResult"]); f != null && l(e, ["codeExecutionResult"], f); const u = s(t, ["executableCode"]); u != null && l(e, ["executableCode"], u); const p = s(t, ["functionResponse"]); p != null && l(e, ["functionResponse"], p); const v = s(t, ["text"]); return v != null && l(e, ["text"], v), e } function hm(t) { const e = {}, o = s(t, ["functionDeclarations"]); if (o != null) { let u = o; Array.isArray(u) && (u = u.map(p => p)), l(e, ["functionDeclarations"], u) } if (s(t, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API."); const n = s(t, ["googleSearch"]); n != null && l(e, ["googleSearch"], lm(n)); const i = s(t, ["googleSearchRetrieval"]); if (i != null && l(e, ["googleSearchRetrieval"], i), s(t, ["enterpriseWebSearch"]) !== void 0) throw new Error("enterpriseWebSearch parameter is not supported in Gemini API."); const r = s(t, ["googleMaps"]); r != null && l(e, ["googleMaps"], rm(r)); const a = s(t, ["urlContext"]); a != null && l(e, ["urlContext"], a); const c = s(t, ["computerUse"]); c != null && l(e, ["computerUse"], c); const f = s(t, ["codeExecution"]); return f != null && l(e, ["codeExecution"], f), e } function ym(t) { const e = {}, o = s(t, ["functionDeclarations"]); if (o != null) { let v = o; Array.isArray(v) && (v = v.map(T => im(T))), l(e, ["functionDeclarations"], v) } const n = s(t, ["retrieval"]); n != null && l(e, ["retrieval"], n); const i = s(t, ["googleSearch"]); i != null && l(e, ["googleSearch"], i); const r = s(t, ["googleSearchRetrieval"]); r != null && l(e, ["googleSearchRetrieval"], r); const a = s(t, ["enterpriseWebSearch"]); a != null && l(e, ["enterpriseWebSearch"], a); const c = s(t, ["googleMaps"]); c != null && l(e, ["googleMaps"], c); const f = s(t, ["urlContext"]); f != null && l(e, ["urlContext"], f); const u = s(t, ["computerUse"]); u != null && l(e, ["computerUse"], u); const p = s(t, ["codeExecution"]); return p != null && l(e, ["codeExecution"], p), e } function vm(t, e) { const o = {}, n = s(t, ["ttl"]); e !== void 0 && n != null && l(e, ["ttl"], n); const i = s(t, ["expireTime"]); return e !== void 0 && i != null && l(e, ["expireTime"], i), o } function Tm(t, e) { const o = {}, n = s(t, ["ttl"]); e !== void 0 && n != null && l(e, ["ttl"], n); const i = s(t, ["expireTime"]); return e !== void 0 && i != null && l(e, ["expireTime"], i), o } function Em(t, e) { const o = {}, n = s(e, ["name"]); n != null && l(o, ["_url", "name"], Fn(t, n)); const i = s(e, ["config"]); return i != null && vm(i, o), o } function bm(t, e) { const o = {}, n = s(e, ["name"]); n != null && l(o, ["_url", "name"], Fn(t, n)); const i = s(e, ["config"]); return i != null && Tm(i, o), o }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Cm extends So { constructor(e) { super(), this.apiClient = e, this.list = async (o = {}) => new Zi(Io.PAGED_ITEM_CACHED_CONTENTS, n => this.listInternal(n), await this.listInternal(o), o) } async create(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = Qp(this.apiClient, e); return c = ie("cachedContents", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(p => p.json()), a.then(p => p) } else { const u = Zp(this.apiClient, e); return c = ie("cachedContents", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }).then(p => p.json()), a.then(p => p) } } async get(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = am(this.apiClient, e); return c = ie("{name}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(p => p.json()), a.then(p => p) } else { const u = sm(this.apiClient, e); return c = ie("{name}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }).then(p => p.json()), a.then(p => p) } } async delete(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = em(this.apiClient, e); return c = ie("{name}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "DELETE", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => { const v = nm(p), T = new gc; return Object.assign(T, v), T }) } else { const u = jp(this.apiClient, e); return c = ie("{name}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "DELETE", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => { const v = tm(p), T = new gc; return Object.assign(T, v), T }) } } async update(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = bm(this.apiClient, e); return c = ie("{name}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "PATCH", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(p => p.json()), a.then(p => p) } else { const u = Em(this.apiClient, e); return c = ie("{name}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "PATCH", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }).then(p => p.json()), a.then(p => p) } } async listInternal(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = fm(e); return c = ie("cachedContents", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => { const v = mm(p), T = new hc; return Object.assign(T, v), T }) } else { const u = um(e); return c = ie("cachedContents", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => { const v = pm(p), T = new hc; return Object.assign(T, v), T }) } } } function wc(t) { var e = typeof Symbol == "function" && Symbol.iterator, o = e && t[e], n = 0; if (o) return o.call(t); if (t && typeof t.length == "number") return { next: function () { return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t } } }; throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.") } function Ke(t) { return this instanceof Ke ? (this.v = t, this) : new Ke(t) } function bi(t, e, o) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var n = o.apply(t, e || []), i, r = []; return i = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), c("next"), c("throw"), c("return", a), i[Symbol.asyncIterator] = function () { return this }, i; function a(k) { return function (R) { return Promise.resolve(R).then(k, v) } } function c(k, R) { n[k] && (i[k] = function ($) { return new Promise(function (N, P) { r.push([k, $, N, P]) > 1 || f(k, $) }) }, R && (i[k] = R(i[k]))) } function f(k, R) { try { u(n[k](R)) } catch ($) { T(r[0][3], $) } } function u(k) { k.value instanceof Ke ? Promise.resolve(k.value.v).then(p, v) : T(r[0][2], k) } function p(k) { f("next", k) } function v(k) { f("throw", k) } function T(k, R) { k(R), r.shift(), r.length && f(r[0][0], r[0][1]) } } function Xi(t) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var e = t[Symbol.asyncIterator], o; return e ? e.call(t) : (t = typeof wc == "function" ? wc(t) : t[Symbol.iterator](), o = {}, n("next"), n("throw"), n("return"), o[Symbol.asyncIterator] = function () { return this }, o); function n(r) { o[r] = t[r] && function (a) { return new Promise(function (c, f) { a = t[r](a), i(c, f, a.done, a.value) }) } } function i(r, a, c, f) { Promise.resolve(f).then(function (u) { r({ value: u, done: c }) }, a) } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function wm(t) { var e; if (t.candidates == null || t.candidates.length === 0) return !1; const o = (e = t.candidates[0]) === null || e === void 0 ? void 0 : e.content; return o === void 0 ? !1 : Zc(o) } function Zc(t) { if (t.parts === void 0 || t.parts.length === 0) return !1; for (const e of t.parts) if (e === void 0 || Object.keys(e).length === 0) return !1; return !0 } function Im(t) { if (t.length !== 0) { for (const e of t) if (e.role !== "user" && e.role !== "model") throw new Error(`Role must be user or model, but got ${e.role}.`) } } function Ic(t) { if (t === void 0 || t.length === 0) return []; const e = [], o = t.length; let n = 0; for (; n < o;)if (t[n].role === "user") e.push(t[n]), n++; else { const i = []; let r = !0; for (; n < o && t[n].role === "model";)i.push(t[n]), r && !Zc(t[n]) && (r = !1), n++; r ? e.push(...i) : e.pop() } return e } class Sm { constructor(e, o) { this.modelsModule = e, this.apiClient = o } create(e) { return new Lm(this.apiClient, this.modelsModule, e.model, e.config, structuredClone(e.history)) } } class Lm { constructor(e, o, n, i = {}, r = []) { this.apiClient = e, this.modelsModule = o, this.model = n, this.config = i, this.history = r, this.sendPromise = Promise.resolve(), Im(r) } async sendMessage(e) { var o; await this.sendPromise; const n = ht(e.message), i = this.modelsModule.generateContent({ model: this.model, contents: this.getHistory(!0).concat(n), config: (o = e.config) !== null && o !== void 0 ? o : this.config }); return this.sendPromise = (async () => { var r, a, c; const f = await i, u = (a = (r = f.candidates) === null || r === void 0 ? void 0 : r[0]) === null || a === void 0 ? void 0 : a.content, p = f.automaticFunctionCallingHistory, v = this.getHistory(!0).length; let T = []; p != null && (T = (c = p.slice(v)) !== null && c !== void 0 ? c : []); const k = u ? [u] : []; this.recordHistory(n, k, T) })(), await this.sendPromise.catch(() => { this.sendPromise = Promise.resolve() }), i } async sendMessageStream(e) { var o; await this.sendPromise; const n = ht(e.message), i = this.modelsModule.generateContentStream({ model: this.model, contents: this.getHistory(!0).concat(n), config: (o = e.config) !== null && o !== void 0 ? o : this.config }); this.sendPromise = i.then(() => { }).catch(() => { }); const r = await i; return this.processStreamResponse(r, n) } getHistory(e = !1) { const o = e ? Ic(this.history) : this.history; return structuredClone(o) } processStreamResponse(e, o) { var n, i; return bi(this, arguments, function* () { var a, c, f, u; const p = []; try { for (var v = !0, T = Xi(e), k; k = yield Ke(T.next()), a = k.done, !a; v = !0) { u = k.value, v = !1; const R = u; if (wm(R)) { const $ = (i = (n = R.candidates) === null || n === void 0 ? void 0 : n[0]) === null || i === void 0 ? void 0 : i.content; $ !== void 0 && p.push($) } yield yield Ke(R) } } catch (R) { c = { error: R } } finally { try { !v && !a && (f = T.return) && (yield Ke(f.call(T))) } finally { if (c) throw c.error } } this.recordHistory(o, p) }) } recordHistory(e, o, n) { let i = []; o.length > 0 && o.every(r => r.role !== void 0) ? i = o : i.push({ role: "model", parts: [] }), n && n.length > 0 ? this.history.push(...Ic(n)) : this.history.push(e), this.history.push(...i) } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Us extends Error { constructor(e) { super(e.message), this.name = "ApiError", this.status = e.status, Object.setPrototypeOf(this, Us.prototype) } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function _m(t) { const e = {}, o = s(t, ["file"]); return o != null && l(e, ["file"], o), e } function Am(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); return o != null && l(e, ["sdkHttpResponse"], o), e } function xm(t) { const e = {}, o = s(t, ["name"]); return o != null && l(e, ["_url", "file"], Bc(o)), e } function km(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); return o != null && l(e, ["sdkHttpResponse"], o), e } function Rm(t) { const e = {}, o = s(t, ["name"]); return o != null && l(e, ["_url", "file"], Bc(o)), e } function Dm(t, e) { const o = {}, n = s(t, ["pageSize"]); e !== void 0 && n != null && l(e, ["_query", "pageSize"], n); const i = s(t, ["pageToken"]); return e !== void 0 && i != null && l(e, ["_query", "pageToken"], i), o } function Nm(t) { const e = {}, o = s(t, ["config"]); return o != null && Dm(o, e), e } function Pm(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); o != null && l(e, ["sdkHttpResponse"], o); const n = s(t, ["nextPageToken"]); n != null && l(e, ["nextPageToken"], n); const i = s(t, ["files"]); if (i != null) { let r = i; Array.isArray(r) && (r = r.map(a => a)), l(e, ["files"], r) } return e }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Mm extends So { constructor(e) { super(), this.apiClient = e, this.list = async (o = {}) => new Zi(Io.PAGED_ITEM_FILES, n => this.listInternal(n), await this.listInternal(o), o) } async upload(e) { if (this.apiClient.isVertexAI()) throw new Error("Vertex AI does not support uploading files. You can share files through a GCS bucket."); return this.apiClient.uploadFile(e.file, e.config).then(o => o) } async download(e) { await this.apiClient.downloadFile(e) } async listInternal(e) { var o, n; let i, r = "", a = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const c = Nm(e); return r = ie("files", c._url), a = c._query, delete c._url, delete c._query, i = this.apiClient.request({ path: r, queryParams: a, body: JSON.stringify(c), httpMethod: "GET", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(f => f.json().then(u => { const p = u; return p.sdkHttpResponse = { headers: f.headers }, p })), i.then(f => { const u = Pm(f), p = new Wf; return Object.assign(p, u), p }) } } async createInternal(e) { var o, n; let i, r = "", a = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const c = _m(e); return r = ie("upload/v1beta/files", c._url), a = c._query, delete c._url, delete c._query, i = this.apiClient.request({ path: r, queryParams: a, body: JSON.stringify(c), httpMethod: "POST", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(f => f.json()), i.then(f => { const u = Am(f), p = new zf; return Object.assign(p, u), p }) } } async get(e) { var o, n; let i, r = "", a = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const c = Rm(e); return r = ie("files/{file}", c._url), a = c._query, delete c._url, delete c._query, i = this.apiClient.request({ path: r, queryParams: a, body: JSON.stringify(c), httpMethod: "GET", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(f => f.json()), i.then(f => f) } } async delete(e) { var o, n; let i, r = "", a = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const c = xm(e); return r = ie("files/{file}", c._url), a = c._query, delete c._url, delete c._query, i = this.apiClient.request({ path: r, queryParams: a, body: JSON.stringify(c), httpMethod: "DELETE", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(f => f.json().then(u => { const p = u; return p.sdkHttpResponse = { headers: f.headers }, p })), i.then(f => { const u = km(f), p = new Yf; return Object.assign(p, u), p }) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Ns(t) { const e = {}; if (s(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const o = s(t, ["data"]); o != null && l(e, ["data"], o); const n = s(t, ["mimeType"]); return n != null && l(e, ["mimeType"], n), e } function Fm(t) { const e = {}, o = s(t, ["parts"]); if (o != null) { let i = o; Array.isArray(i) && (i = i.map(r => Zm(r))), l(e, ["parts"], i) } const n = s(t, ["role"]); return n != null && l(e, ["role"], n), e } function Um(t) { const e = {}; if (s(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const o = s(t, ["fileUri"]); o != null && l(e, ["fileUri"], o); const n = s(t, ["mimeType"]); return n != null && l(e, ["mimeType"], n), e } function $m(t) { const e = {}; if (s(t, ["behavior"]) !== void 0) throw new Error("behavior parameter is not supported in Vertex AI."); const o = s(t, ["description"]); o != null && l(e, ["description"], o); const n = s(t, ["name"]); n != null && l(e, ["name"], n); const i = s(t, ["parameters"]); i != null && l(e, ["parameters"], i); const r = s(t, ["parametersJsonSchema"]); r != null && l(e, ["parametersJsonSchema"], r); const a = s(t, ["response"]); a != null && l(e, ["response"], a); const c = s(t, ["responseJsonSchema"]); return c != null && l(e, ["responseJsonSchema"], c), e } function qm(t) { const e = {}, o = s(t, ["modelSelectionConfig"]); o != null && l(e, ["modelConfig"], o); const n = s(t, ["audioTimestamp"]); n != null && l(e, ["audioTimestamp"], n); const i = s(t, ["candidateCount"]); i != null && l(e, ["candidateCount"], i); const r = s(t, ["enableAffectiveDialog"]); r != null && l(e, ["enableAffectiveDialog"], r); const a = s(t, ["frequencyPenalty"]); a != null && l(e, ["frequencyPenalty"], a); const c = s(t, ["logprobs"]); c != null && l(e, ["logprobs"], c); const f = s(t, ["maxOutputTokens"]); f != null && l(e, ["maxOutputTokens"], f); const u = s(t, ["mediaResolution"]); u != null && l(e, ["mediaResolution"], u); const p = s(t, ["presencePenalty"]); p != null && l(e, ["presencePenalty"], p); const v = s(t, ["responseJsonSchema"]); v != null && l(e, ["responseJsonSchema"], v); const T = s(t, ["responseLogprobs"]); T != null && l(e, ["responseLogprobs"], T); const k = s(t, ["responseMimeType"]); k != null && l(e, ["responseMimeType"], k); const R = s(t, ["responseModalities"]); R != null && l(e, ["responseModalities"], R); const $ = s(t, ["responseSchema"]); $ != null && l(e, ["responseSchema"], $); const N = s(t, ["routingConfig"]); N != null && l(e, ["routingConfig"], N); const P = s(t, ["seed"]); P != null && l(e, ["seed"], P); const W = s(t, ["speechConfig"]); W != null && l(e, ["speechConfig"], Qc(W)); const K = s(t, ["stopSequences"]); K != null && l(e, ["stopSequences"], K); const j = s(t, ["temperature"]); j != null && l(e, ["temperature"], j); const le = s(t, ["thinkingConfig"]); le != null && l(e, ["thinkingConfig"], le); const de = s(t, ["topK"]); de != null && l(e, ["topK"], de); const ue = s(t, ["topP"]); if (ue != null && l(e, ["topP"], ue), s(t, ["enableEnhancedCivicAnswers"]) !== void 0) throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI."); return e } function Vm(t) { const e = {}; if (s(t, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API."); const o = s(t, ["enableWidget"]); return o != null && l(e, ["enableWidget"], o), e } function Gm(t) { const e = {}, o = s(t, ["timeRangeFilter"]); if (o != null && l(e, ["timeRangeFilter"], o), s(t, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API."); return e } function Om(t, e) { const o = {}, n = s(t, ["generationConfig"]); e !== void 0 && n != null && l(e, ["setup", "generationConfig"], n); const i = s(t, ["responseModalities"]); e !== void 0 && i != null && l(e, ["setup", "generationConfig", "responseModalities"], i); const r = s(t, ["temperature"]); e !== void 0 && r != null && l(e, ["setup", "generationConfig", "temperature"], r); const a = s(t, ["topP"]); e !== void 0 && a != null && l(e, ["setup", "generationConfig", "topP"], a); const c = s(t, ["topK"]); e !== void 0 && c != null && l(e, ["setup", "generationConfig", "topK"], c); const f = s(t, ["maxOutputTokens"]); e !== void 0 && f != null && l(e, ["setup", "generationConfig", "maxOutputTokens"], f); const u = s(t, ["mediaResolution"]); e !== void 0 && u != null && l(e, ["setup", "generationConfig", "mediaResolution"], u); const p = s(t, ["seed"]); e !== void 0 && p != null && l(e, ["setup", "generationConfig", "seed"], p); const v = s(t, ["speechConfig"]); e !== void 0 && v != null && l(e, ["setup", "generationConfig", "speechConfig"], Ur(v)); const T = s(t, ["thinkingConfig"]); e !== void 0 && T != null && l(e, ["setup", "generationConfig", "thinkingConfig"], T); const k = s(t, ["enableAffectiveDialog"]); e !== void 0 && k != null && l(e, ["setup", "generationConfig", "enableAffectiveDialog"], k); const R = s(t, ["systemInstruction"]); e !== void 0 && R != null && l(e, ["setup", "systemInstruction"], Fm(ht(R))); const $ = s(t, ["tools"]); if (e !== void 0 && $ != null) { let de = Ii($); Array.isArray(de) && (de = de.map(ue => jm(wi(ue)))), l(e, ["setup", "tools"], de) } const N = s(t, ["sessionResumption"]); e !== void 0 && N != null && l(e, ["setup", "sessionResumption"], Qm(N)); const P = s(t, ["inputAudioTranscription"]); e !== void 0 && P != null && l(e, ["setup", "inputAudioTranscription"], P); const W = s(t, ["outputAudioTranscription"]); e !== void 0 && W != null && l(e, ["setup", "outputAudioTranscription"], W); const K = s(t, ["realtimeInputConfig"]); e !== void 0 && K != null && l(e, ["setup", "realtimeInputConfig"], K); const j = s(t, ["contextWindowCompression"]); e !== void 0 && j != null && l(e, ["setup", "contextWindowCompression"], j); const le = s(t, ["proactivity"]); return e !== void 0 && le != null && l(e, ["setup", "proactivity"], le), o } function Hm(t, e) { const o = {}, n = s(t, ["generationConfig"]); e !== void 0 && n != null && l(e, ["setup", "generationConfig"], qm(n)); const i = s(t, ["responseModalities"]); e !== void 0 && i != null && l(e, ["setup", "generationConfig", "responseModalities"], i); const r = s(t, ["temperature"]); e !== void 0 && r != null && l(e, ["setup", "generationConfig", "temperature"], r); const a = s(t, ["topP"]); e !== void 0 && a != null && l(e, ["setup", "generationConfig", "topP"], a); const c = s(t, ["topK"]); e !== void 0 && c != null && l(e, ["setup", "generationConfig", "topK"], c); const f = s(t, ["maxOutputTokens"]); e !== void 0 && f != null && l(e, ["setup", "generationConfig", "maxOutputTokens"], f); const u = s(t, ["mediaResolution"]); e !== void 0 && u != null && l(e, ["setup", "generationConfig", "mediaResolution"], u); const p = s(t, ["seed"]); e !== void 0 && p != null && l(e, ["setup", "generationConfig", "seed"], p); const v = s(t, ["speechConfig"]); e !== void 0 && v != null && l(e, ["setup", "generationConfig", "speechConfig"], Qc(Ur(v))); const T = s(t, ["thinkingConfig"]); e !== void 0 && T != null && l(e, ["setup", "generationConfig", "thinkingConfig"], T); const k = s(t, ["enableAffectiveDialog"]); e !== void 0 && k != null && l(e, ["setup", "generationConfig", "enableAffectiveDialog"], k); const R = s(t, ["systemInstruction"]); e !== void 0 && R != null && l(e, ["setup", "systemInstruction"], ht(R)); const $ = s(t, ["tools"]); if (e !== void 0 && $ != null) { let de = Ii($); Array.isArray(de) && (de = de.map(ue => eg(wi(ue)))), l(e, ["setup", "tools"], de) } const N = s(t, ["sessionResumption"]); e !== void 0 && N != null && l(e, ["setup", "sessionResumption"], N); const P = s(t, ["inputAudioTranscription"]); e !== void 0 && P != null && l(e, ["setup", "inputAudioTranscription"], P); const W = s(t, ["outputAudioTranscription"]); e !== void 0 && W != null && l(e, ["setup", "outputAudioTranscription"], W); const K = s(t, ["realtimeInputConfig"]); e !== void 0 && K != null && l(e, ["setup", "realtimeInputConfig"], K); const j = s(t, ["contextWindowCompression"]); e !== void 0 && j != null && l(e, ["setup", "contextWindowCompression"], j); const le = s(t, ["proactivity"]); return e !== void 0 && le != null && l(e, ["setup", "proactivity"], le), o } function Bm(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["setup", "model"], Ae(t, n)); const i = s(e, ["config"]); return i != null && l(o, ["config"], Om(i, o)), o } function Jm(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["setup", "model"], Ae(t, n)); const i = s(e, ["config"]); return i != null && l(o, ["config"], Hm(i, o)), o } function Wm(t) { const e = {}, o = s(t, ["musicGenerationConfig"]); return o != null && l(e, ["musicGenerationConfig"], o), e } function zm(t) { const e = {}, o = s(t, ["weightedPrompts"]); if (o != null) { let n = o; Array.isArray(n) && (n = n.map(i => i)), l(e, ["weightedPrompts"], n) } return e } function Ym(t) { const e = {}, o = s(t, ["media"]); if (o != null) { let u = qc(o); Array.isArray(u) && (u = u.map(p => Ns(p))), l(e, ["mediaChunks"], u) } const n = s(t, ["audio"]); n != null && l(e, ["audio"], Ns(Gc(n))); const i = s(t, ["audioStreamEnd"]); i != null && l(e, ["audioStreamEnd"], i); const r = s(t, ["video"]); r != null && l(e, ["video"], Ns(Vc(r))); const a = s(t, ["text"]); a != null && l(e, ["text"], a); const c = s(t, ["activityStart"]); c != null && l(e, ["activityStart"], c); const f = s(t, ["activityEnd"]); return f != null && l(e, ["activityEnd"], f), e } function Km(t) { const e = {}, o = s(t, ["media"]); if (o != null) { let u = qc(o); Array.isArray(u) && (u = u.map(p => p)), l(e, ["mediaChunks"], u) } const n = s(t, ["audio"]); n != null && l(e, ["audio"], Gc(n)); const i = s(t, ["audioStreamEnd"]); i != null && l(e, ["audioStreamEnd"], i); const r = s(t, ["video"]); r != null && l(e, ["video"], Vc(r)); const a = s(t, ["text"]); a != null && l(e, ["text"], a); const c = s(t, ["activityStart"]); c != null && l(e, ["activityStart"], c); const f = s(t, ["activityEnd"]); return f != null && l(e, ["activityEnd"], f), e } function Xm(t) { const e = {}, o = s(t, ["setupComplete"]); o != null && l(e, ["setupComplete"], o); const n = s(t, ["serverContent"]); n != null && l(e, ["serverContent"], n); const i = s(t, ["toolCall"]); i != null && l(e, ["toolCall"], i); const r = s(t, ["toolCallCancellation"]); r != null && l(e, ["toolCallCancellation"], r); const a = s(t, ["usageMetadata"]); a != null && l(e, ["usageMetadata"], tg(a)); const c = s(t, ["goAway"]); c != null && l(e, ["goAway"], c); const f = s(t, ["sessionResumptionUpdate"]); return f != null && l(e, ["sessionResumptionUpdate"], f), e } function Zm(t) { const e = {}, o = s(t, ["videoMetadata"]); o != null && l(e, ["videoMetadata"], o); const n = s(t, ["thought"]); n != null && l(e, ["thought"], n); const i = s(t, ["inlineData"]); i != null && l(e, ["inlineData"], Ns(i)); const r = s(t, ["fileData"]); r != null && l(e, ["fileData"], Um(r)); const a = s(t, ["thoughtSignature"]); a != null && l(e, ["thoughtSignature"], a); const c = s(t, ["functionCall"]); c != null && l(e, ["functionCall"], c); const f = s(t, ["codeExecutionResult"]); f != null && l(e, ["codeExecutionResult"], f); const u = s(t, ["executableCode"]); u != null && l(e, ["executableCode"], u); const p = s(t, ["functionResponse"]); p != null && l(e, ["functionResponse"], p); const v = s(t, ["text"]); return v != null && l(e, ["text"], v), e } function Qm(t) { const e = {}, o = s(t, ["handle"]); if (o != null && l(e, ["handle"], o), s(t, ["transparent"]) !== void 0) throw new Error("transparent parameter is not supported in Gemini API."); return e } function Qc(t) { const e = {}, o = s(t, ["voiceConfig"]); if (o != null && l(e, ["voiceConfig"], o), s(t, ["multiSpeakerVoiceConfig"]) !== void 0) throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI."); const n = s(t, ["languageCode"]); return n != null && l(e, ["languageCode"], n), e } function jm(t) { const e = {}, o = s(t, ["functionDeclarations"]); if (o != null) { let u = o; Array.isArray(u) && (u = u.map(p => p)), l(e, ["functionDeclarations"], u) } if (s(t, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API."); const n = s(t, ["googleSearch"]); n != null && l(e, ["googleSearch"], Gm(n)); const i = s(t, ["googleSearchRetrieval"]); if (i != null && l(e, ["googleSearchRetrieval"], i), s(t, ["enterpriseWebSearch"]) !== void 0) throw new Error("enterpriseWebSearch parameter is not supported in Gemini API."); const r = s(t, ["googleMaps"]); r != null && l(e, ["googleMaps"], Vm(r)); const a = s(t, ["urlContext"]); a != null && l(e, ["urlContext"], a); const c = s(t, ["computerUse"]); c != null && l(e, ["computerUse"], c); const f = s(t, ["codeExecution"]); return f != null && l(e, ["codeExecution"], f), e } function eg(t) { const e = {}, o = s(t, ["functionDeclarations"]); if (o != null) { let v = o; Array.isArray(v) && (v = v.map(T => $m(T))), l(e, ["functionDeclarations"], v) } const n = s(t, ["retrieval"]); n != null && l(e, ["retrieval"], n); const i = s(t, ["googleSearch"]); i != null && l(e, ["googleSearch"], i); const r = s(t, ["googleSearchRetrieval"]); r != null && l(e, ["googleSearchRetrieval"], r); const a = s(t, ["enterpriseWebSearch"]); a != null && l(e, ["enterpriseWebSearch"], a); const c = s(t, ["googleMaps"]); c != null && l(e, ["googleMaps"], c); const f = s(t, ["urlContext"]); f != null && l(e, ["urlContext"], f); const u = s(t, ["computerUse"]); u != null && l(e, ["computerUse"], u); const p = s(t, ["codeExecution"]); return p != null && l(e, ["codeExecution"], p), e } function tg(t) { const e = {}, o = s(t, ["promptTokenCount"]); o != null && l(e, ["promptTokenCount"], o); const n = s(t, ["cachedContentTokenCount"]); n != null && l(e, ["cachedContentTokenCount"], n); const i = s(t, ["candidatesTokenCount"]); i != null && l(e, ["responseTokenCount"], i); const r = s(t, ["toolUsePromptTokenCount"]); r != null && l(e, ["toolUsePromptTokenCount"], r); const a = s(t, ["thoughtsTokenCount"]); a != null && l(e, ["thoughtsTokenCount"], a); const c = s(t, ["totalTokenCount"]); c != null && l(e, ["totalTokenCount"], c); const f = s(t, ["promptTokensDetails"]); if (f != null) { let k = f; Array.isArray(k) && (k = k.map(R => R)), l(e, ["promptTokensDetails"], k) } const u = s(t, ["cacheTokensDetails"]); if (u != null) { let k = u; Array.isArray(k) && (k = k.map(R => R)), l(e, ["cacheTokensDetails"], k) } const p = s(t, ["candidatesTokensDetails"]); if (p != null) { let k = p; Array.isArray(k) && (k = k.map(R => R)), l(e, ["responseTokensDetails"], k) } const v = s(t, ["toolUsePromptTokensDetails"]); if (v != null) { let k = v; Array.isArray(k) && (k = k.map(R => R)), l(e, ["toolUsePromptTokensDetails"], k) } const T = s(t, ["trafficType"]); return T != null && l(e, ["trafficType"], T), e }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function ng(t) { const e = {}; if (s(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const o = s(t, ["data"]); o != null && l(e, ["data"], o); const n = s(t, ["mimeType"]); return n != null && l(e, ["mimeType"], n), e } function og(t) { const e = {}, o = s(t, ["content"]); o != null && l(e, ["content"], o); const n = s(t, ["citationMetadata"]); n != null && l(e, ["citationMetadata"], ig(n)); const i = s(t, ["tokenCount"]); i != null && l(e, ["tokenCount"], i); const r = s(t, ["finishReason"]); r != null && l(e, ["finishReason"], r); const a = s(t, ["urlContextMetadata"]); a != null && l(e, ["urlContextMetadata"], a); const c = s(t, ["avgLogprobs"]); c != null && l(e, ["avgLogprobs"], c); const f = s(t, ["groundingMetadata"]); f != null && l(e, ["groundingMetadata"], f); const u = s(t, ["index"]); u != null && l(e, ["index"], u); const p = s(t, ["logprobsResult"]); p != null && l(e, ["logprobsResult"], p); const v = s(t, ["safetyRatings"]); if (v != null) { let T = v; Array.isArray(T) && (T = T.map(k => k)), l(e, ["safetyRatings"], T) } return e } function ig(t) { const e = {}, o = s(t, ["citationSources"]); if (o != null) { let n = o; Array.isArray(n) && (n = n.map(i => i)), l(e, ["citations"], n) } return e } function sg(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["_url", "model"], Ae(t, n)); const i = s(e, ["contents"]); if (i != null) { let r = zt(i); Array.isArray(r) && (r = r.map(a => a)), l(o, ["contents"], r) } return o } function ag(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); o != null && l(e, ["sdkHttpResponse"], o); const n = s(t, ["tokensInfo"]); if (n != null) { let i = n; Array.isArray(i) && (i = i.map(r => r)), l(e, ["tokensInfo"], i) } return e } function rg(t) { const e = {}, o = s(t, ["values"]); o != null && l(e, ["values"], o); const n = s(t, ["statistics"]); return n != null && l(e, ["statistics"], lg(n)), e } function lg(t) { const e = {}, o = s(t, ["truncated"]); o != null && l(e, ["truncated"], o); const n = s(t, ["token_count"]); return n != null && l(e, ["tokenCount"], n), e } function $s(t) { const e = {}, o = s(t, ["parts"]); if (o != null) { let i = o; Array.isArray(i) && (i = i.map(r => ph(r))), l(e, ["parts"], i) } const n = s(t, ["role"]); return n != null && l(e, ["role"], n), e } function dg(t) { const e = {}, o = s(t, ["controlType"]); o != null && l(e, ["controlType"], o); const n = s(t, ["enableControlImageComputation"]); return n != null && l(e, ["computeControl"], n), e } function cg(t) { const e = {}; if (s(t, ["systemInstruction"]) !== void 0) throw new Error("systemInstruction parameter is not supported in Gemini API."); if (s(t, ["tools"]) !== void 0) throw new Error("tools parameter is not supported in Gemini API."); if (s(t, ["generationConfig"]) !== void 0) throw new Error("generationConfig parameter is not supported in Gemini API."); return e } function ug(t, e) { const o = {}, n = s(t, ["systemInstruction"]); e !== void 0 && n != null && l(e, ["systemInstruction"], ht(n)); const i = s(t, ["tools"]); if (e !== void 0 && i != null) { let a = i; Array.isArray(a) && (a = a.map(c => ou(c))), l(e, ["tools"], a) } const r = s(t, ["generationConfig"]); return e !== void 0 && r != null && l(e, ["generationConfig"], eh(r)), o } function fg(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["_url", "model"], Ae(t, n)); const i = s(e, ["contents"]); if (i != null) { let a = zt(i); Array.isArray(a) && (a = a.map(c => $s(c))), l(o, ["contents"], a) } const r = s(e, ["config"]); return r != null && cg(r), o } function pg(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["_url", "model"], Ae(t, n)); const i = s(e, ["contents"]); if (i != null) { let a = zt(i); Array.isArray(a) && (a = a.map(c => c)), l(o, ["contents"], a) } const r = s(e, ["config"]); return r != null && ug(r, o), o } function mg(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); o != null && l(e, ["sdkHttpResponse"], o); const n = s(t, ["totalTokens"]); n != null && l(e, ["totalTokens"], n); const i = s(t, ["cachedContentTokenCount"]); return i != null && l(e, ["cachedContentTokenCount"], i), e } function gg(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); o != null && l(e, ["sdkHttpResponse"], o); const n = s(t, ["totalTokens"]); return n != null && l(e, ["totalTokens"], n), e } function hg(t, e) { const o = {}, n = s(e, ["model"]); return n != null && l(o, ["_url", "name"], Ae(t, n)), o } function yg(t, e) { const o = {}, n = s(e, ["model"]); return n != null && l(o, ["_url", "name"], Ae(t, n)), o } function vg(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); return o != null && l(e, ["sdkHttpResponse"], o), e } function Tg(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); return o != null && l(e, ["sdkHttpResponse"], o), e } function Eg(t, e) { const o = {}, n = s(t, ["outputGcsUri"]); e !== void 0 && n != null && l(e, ["parameters", "storageUri"], n); const i = s(t, ["negativePrompt"]); e !== void 0 && i != null && l(e, ["parameters", "negativePrompt"], i); const r = s(t, ["numberOfImages"]); e !== void 0 && r != null && l(e, ["parameters", "sampleCount"], r); const a = s(t, ["aspectRatio"]); e !== void 0 && a != null && l(e, ["parameters", "aspectRatio"], a); const c = s(t, ["guidanceScale"]); e !== void 0 && c != null && l(e, ["parameters", "guidanceScale"], c); const f = s(t, ["seed"]); e !== void 0 && f != null && l(e, ["parameters", "seed"], f); const u = s(t, ["safetyFilterLevel"]); e !== void 0 && u != null && l(e, ["parameters", "safetySetting"], u); const p = s(t, ["personGeneration"]); e !== void 0 && p != null && l(e, ["parameters", "personGeneration"], p); const v = s(t, ["includeSafetyAttributes"]); e !== void 0 && v != null && l(e, ["parameters", "includeSafetyAttributes"], v); const T = s(t, ["includeRaiReason"]); e !== void 0 && T != null && l(e, ["parameters", "includeRaiReason"], T); const k = s(t, ["language"]); e !== void 0 && k != null && l(e, ["parameters", "language"], k); const R = s(t, ["outputMimeType"]); e !== void 0 && R != null && l(e, ["parameters", "outputOptions", "mimeType"], R); const $ = s(t, ["outputCompressionQuality"]); e !== void 0 && $ != null && l(e, ["parameters", "outputOptions", "compressionQuality"], $); const N = s(t, ["addWatermark"]); e !== void 0 && N != null && l(e, ["parameters", "addWatermark"], N); const P = s(t, ["labels"]); e !== void 0 && P != null && l(e, ["labels"], P); const W = s(t, ["editMode"]); e !== void 0 && W != null && l(e, ["parameters", "editMode"], W); const K = s(t, ["baseSteps"]); return e !== void 0 && K != null && l(e, ["parameters", "editConfig", "baseSteps"], K), o } function bg(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["_url", "model"], Ae(t, n)); const i = s(e, ["prompt"]); i != null && l(o, ["instances[0]", "prompt"], i); const r = s(e, ["referenceImages"]); if (r != null) { let c = r; Array.isArray(c) && (c = c.map(f => Th(f))), l(o, ["instances[0]", "referenceImages"], c) } const a = s(e, ["config"]); return a != null && Eg(a, o), o } function Cg(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); o != null && l(e, ["sdkHttpResponse"], o); const n = s(t, ["predictions"]); if (n != null) { let i = n; Array.isArray(i) && (i = i.map(r => qs(r))), l(e, ["generatedImages"], i) } return e } function wg(t, e) { const o = {}, n = s(t, ["taskType"]); e !== void 0 && n != null && l(e, ["requests[]", "taskType"], n); const i = s(t, ["title"]); e !== void 0 && i != null && l(e, ["requests[]", "title"], i); const r = s(t, ["outputDimensionality"]); if (e !== void 0 && r != null && l(e, ["requests[]", "outputDimensionality"], r), s(t, ["mimeType"]) !== void 0) throw new Error("mimeType parameter is not supported in Gemini API."); if (s(t, ["autoTruncate"]) !== void 0) throw new Error("autoTruncate parameter is not supported in Gemini API."); return o } function Ig(t, e) { const o = {}, n = s(t, ["taskType"]); e !== void 0 && n != null && l(e, ["instances[]", "task_type"], n); const i = s(t, ["title"]); e !== void 0 && i != null && l(e, ["instances[]", "title"], i); const r = s(t, ["outputDimensionality"]); e !== void 0 && r != null && l(e, ["parameters", "outputDimensionality"], r); const a = s(t, ["mimeType"]); e !== void 0 && a != null && l(e, ["instances[]", "mimeType"], a); const c = s(t, ["autoTruncate"]); return e !== void 0 && c != null && l(e, ["parameters", "autoTruncate"], c), o } function Sg(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["_url", "model"], Ae(t, n)); const i = s(e, ["contents"]); if (i != null) { let c = Pr(t, i); Array.isArray(c) && (c = c.map(f => f)), l(o, ["requests[]", "content"], c) } const r = s(e, ["config"]); r != null && wg(r, o); const a = s(e, ["model"]); return a !== void 0 && l(o, ["requests[]", "model"], Ae(t, a)), o } function Lg(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["_url", "model"], Ae(t, n)); const i = s(e, ["contents"]); if (i != null) { let a = Pr(t, i); Array.isArray(a) && (a = a.map(c => c)), l(o, ["instances[]", "content"], a) } const r = s(e, ["config"]); return r != null && Ig(r, o), o } function _g(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); o != null && l(e, ["sdkHttpResponse"], o); const n = s(t, ["embeddings"]); if (n != null) { let r = n; Array.isArray(r) && (r = r.map(a => a)), l(e, ["embeddings"], r) } const i = s(t, ["metadata"]); return i != null && l(e, ["metadata"], i), e } function Ag(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); o != null && l(e, ["sdkHttpResponse"], o); const n = s(t, ["predictions[]", "embeddings"]); if (n != null) { let r = n; Array.isArray(r) && (r = r.map(a => rg(a))), l(e, ["embeddings"], r) } const i = s(t, ["metadata"]); return i != null && l(e, ["metadata"], i), e } function xg(t) { const e = {}, o = s(t, ["endpoint"]); o != null && l(e, ["name"], o); const n = s(t, ["deployedModelId"]); return n != null && l(e, ["deployedModelId"], n), e } function kg(t) { const e = {}; if (s(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const o = s(t, ["fileUri"]); o != null && l(e, ["fileUri"], o); const n = s(t, ["mimeType"]); return n != null && l(e, ["mimeType"], n), e } function Rg(t) { const e = {}; if (s(t, ["behavior"]) !== void 0) throw new Error("behavior parameter is not supported in Vertex AI."); const o = s(t, ["description"]); o != null && l(e, ["description"], o); const n = s(t, ["name"]); n != null && l(e, ["name"], n); const i = s(t, ["parameters"]); i != null && l(e, ["parameters"], i); const r = s(t, ["parametersJsonSchema"]); r != null && l(e, ["parametersJsonSchema"], r); const a = s(t, ["response"]); a != null && l(e, ["response"], a); const c = s(t, ["responseJsonSchema"]); return c != null && l(e, ["responseJsonSchema"], c), e } function Dg(t, e, o) { const n = {}, i = s(e, ["systemInstruction"]); o !== void 0 && i != null && l(o, ["systemInstruction"], $s(ht(i))); const r = s(e, ["temperature"]); r != null && l(n, ["temperature"], r); const a = s(e, ["topP"]); a != null && l(n, ["topP"], a); const c = s(e, ["topK"]); c != null && l(n, ["topK"], c); const f = s(e, ["candidateCount"]); f != null && l(n, ["candidateCount"], f); const u = s(e, ["maxOutputTokens"]); u != null && l(n, ["maxOutputTokens"], u); const p = s(e, ["stopSequences"]); p != null && l(n, ["stopSequences"], p); const v = s(e, ["responseLogprobs"]); v != null && l(n, ["responseLogprobs"], v); const T = s(e, ["logprobs"]); T != null && l(n, ["logprobs"], T); const k = s(e, ["presencePenalty"]); k != null && l(n, ["presencePenalty"], k); const R = s(e, ["frequencyPenalty"]); R != null && l(n, ["frequencyPenalty"], R); const $ = s(e, ["seed"]); $ != null && l(n, ["seed"], $); const N = s(e, ["responseMimeType"]); N != null && l(n, ["responseMimeType"], N); const P = s(e, ["responseSchema"]); P != null && l(n, ["responseSchema"], Mr(P)); const W = s(e, ["responseJsonSchema"]); if (W != null && l(n, ["responseJsonSchema"], W), s(e, ["routingConfig"]) !== void 0) throw new Error("routingConfig parameter is not supported in Gemini API."); if (s(e, ["modelSelectionConfig"]) !== void 0) throw new Error("modelSelectionConfig parameter is not supported in Gemini API."); const K = s(e, ["safetySettings"]); if (o !== void 0 && K != null) { let $e = K; Array.isArray($e) && ($e = $e.map(Lt => Eh(Lt))), l(o, ["safetySettings"], $e) } const j = s(e, ["tools"]); if (o !== void 0 && j != null) { let $e = Ii(j); Array.isArray($e) && ($e = $e.map(Lt => Lh(wi(Lt)))), l(o, ["tools"], $e) } const le = s(e, ["toolConfig"]); if (o !== void 0 && le != null && l(o, ["toolConfig"], le), s(e, ["labels"]) !== void 0) throw new Error("labels parameter is not supported in Gemini API."); const de = s(e, ["cachedContent"]); o !== void 0 && de != null && l(o, ["cachedContent"], Fn(t, de)); const ue = s(e, ["responseModalities"]); ue != null && l(n, ["responseModalities"], ue); const Fe = s(e, ["mediaResolution"]); Fe != null && l(n, ["mediaResolution"], Fe); const re = s(e, ["speechConfig"]); if (re != null && l(n, ["speechConfig"], Fr(re)), s(e, ["audioTimestamp"]) !== void 0) throw new Error("audioTimestamp parameter is not supported in Gemini API."); const ye = s(e, ["thinkingConfig"]); ye != null && l(n, ["thinkingConfig"], ye); const xe = s(e, ["imageConfig"]); return xe != null && l(n, ["imageConfig"], xe), n } function Ng(t, e, o) { const n = {}, i = s(e, ["systemInstruction"]); o !== void 0 && i != null && l(o, ["systemInstruction"], ht(i)); const r = s(e, ["temperature"]); r != null && l(n, ["temperature"], r); const a = s(e, ["topP"]); a != null && l(n, ["topP"], a); const c = s(e, ["topK"]); c != null && l(n, ["topK"], c); const f = s(e, ["candidateCount"]); f != null && l(n, ["candidateCount"], f); const u = s(e, ["maxOutputTokens"]); u != null && l(n, ["maxOutputTokens"], u); const p = s(e, ["stopSequences"]); p != null && l(n, ["stopSequences"], p); const v = s(e, ["responseLogprobs"]); v != null && l(n, ["responseLogprobs"], v); const T = s(e, ["logprobs"]); T != null && l(n, ["logprobs"], T); const k = s(e, ["presencePenalty"]); k != null && l(n, ["presencePenalty"], k); const R = s(e, ["frequencyPenalty"]); R != null && l(n, ["frequencyPenalty"], R); const $ = s(e, ["seed"]); $ != null && l(n, ["seed"], $); const N = s(e, ["responseMimeType"]); N != null && l(n, ["responseMimeType"], N); const P = s(e, ["responseSchema"]); P != null && l(n, ["responseSchema"], Mr(P)); const W = s(e, ["responseJsonSchema"]); W != null && l(n, ["responseJsonSchema"], W); const K = s(e, ["routingConfig"]); K != null && l(n, ["routingConfig"], K); const j = s(e, ["modelSelectionConfig"]); j != null && l(n, ["modelConfig"], j); const le = s(e, ["safetySettings"]); if (o !== void 0 && le != null) { let Pt = le; Array.isArray(Pt) && (Pt = Pt.map(Un => Un)), l(o, ["safetySettings"], Pt) } const de = s(e, ["tools"]); if (o !== void 0 && de != null) { let Pt = Ii(de); Array.isArray(Pt) && (Pt = Pt.map(Un => ou(wi(Un)))), l(o, ["tools"], Pt) } const ue = s(e, ["toolConfig"]); o !== void 0 && ue != null && l(o, ["toolConfig"], ue); const Fe = s(e, ["labels"]); o !== void 0 && Fe != null && l(o, ["labels"], Fe); const re = s(e, ["cachedContent"]); o !== void 0 && re != null && l(o, ["cachedContent"], Fn(t, re)); const ye = s(e, ["responseModalities"]); ye != null && l(n, ["responseModalities"], ye); const xe = s(e, ["mediaResolution"]); xe != null && l(n, ["mediaResolution"], xe); const $e = s(e, ["speechConfig"]); $e != null && l(n, ["speechConfig"], nu(Fr($e))); const Lt = s(e, ["audioTimestamp"]); Lt != null && l(n, ["audioTimestamp"], Lt); const Rt = s(e, ["thinkingConfig"]); Rt != null && l(n, ["thinkingConfig"], Rt); const Qi = s(e, ["imageConfig"]); return Qi != null && l(n, ["imageConfig"], Qi), n } function Sc(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["_url", "model"], Ae(t, n)); const i = s(e, ["contents"]); if (i != null) { let a = zt(i); Array.isArray(a) && (a = a.map(c => $s(c))), l(o, ["contents"], a) } const r = s(e, ["config"]); return r != null && l(o, ["generationConfig"], Dg(t, r, o)), o } function Lc(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["_url", "model"], Ae(t, n)); const i = s(e, ["contents"]); if (i != null) { let a = zt(i); Array.isArray(a) && (a = a.map(c => c)), l(o, ["contents"], a) } const r = s(e, ["config"]); return r != null && l(o, ["generationConfig"], Ng(t, r, o)), o } function _c(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); o != null && l(e, ["sdkHttpResponse"], o); const n = s(t, ["candidates"]); if (n != null) { let f = n; Array.isArray(f) && (f = f.map(u => og(u))), l(e, ["candidates"], f) } const i = s(t, ["modelVersion"]); i != null && l(e, ["modelVersion"], i); const r = s(t, ["promptFeedback"]); r != null && l(e, ["promptFeedback"], r); const a = s(t, ["responseId"]); a != null && l(e, ["responseId"], a); const c = s(t, ["usageMetadata"]); return c != null && l(e, ["usageMetadata"], c), e } function Ac(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); o != null && l(e, ["sdkHttpResponse"], o); const n = s(t, ["candidates"]); if (n != null) { let u = n; Array.isArray(u) && (u = u.map(p => p)), l(e, ["candidates"], u) } const i = s(t, ["createTime"]); i != null && l(e, ["createTime"], i); const r = s(t, ["modelVersion"]); r != null && l(e, ["modelVersion"], r); const a = s(t, ["promptFeedback"]); a != null && l(e, ["promptFeedback"], a); const c = s(t, ["responseId"]); c != null && l(e, ["responseId"], c); const f = s(t, ["usageMetadata"]); return f != null && l(e, ["usageMetadata"], f), e } function Pg(t, e) { const o = {}; if (s(t, ["outputGcsUri"]) !== void 0) throw new Error("outputGcsUri parameter is not supported in Gemini API."); if (s(t, ["negativePrompt"]) !== void 0) throw new Error("negativePrompt parameter is not supported in Gemini API."); const n = s(t, ["numberOfImages"]); e !== void 0 && n != null && l(e, ["parameters", "sampleCount"], n); const i = s(t, ["aspectRatio"]); e !== void 0 && i != null && l(e, ["parameters", "aspectRatio"], i); const r = s(t, ["guidanceScale"]); if (e !== void 0 && r != null && l(e, ["parameters", "guidanceScale"], r), s(t, ["seed"]) !== void 0) throw new Error("seed parameter is not supported in Gemini API."); const a = s(t, ["safetyFilterLevel"]); e !== void 0 && a != null && l(e, ["parameters", "safetySetting"], a); const c = s(t, ["personGeneration"]); e !== void 0 && c != null && l(e, ["parameters", "personGeneration"], c); const f = s(t, ["includeSafetyAttributes"]); e !== void 0 && f != null && l(e, ["parameters", "includeSafetyAttributes"], f); const u = s(t, ["includeRaiReason"]); e !== void 0 && u != null && l(e, ["parameters", "includeRaiReason"], u); const p = s(t, ["language"]); e !== void 0 && p != null && l(e, ["parameters", "language"], p); const v = s(t, ["outputMimeType"]); e !== void 0 && v != null && l(e, ["parameters", "outputOptions", "mimeType"], v); const T = s(t, ["outputCompressionQuality"]); if (e !== void 0 && T != null && l(e, ["parameters", "outputOptions", "compressionQuality"], T), s(t, ["addWatermark"]) !== void 0) throw new Error("addWatermark parameter is not supported in Gemini API."); if (s(t, ["labels"]) !== void 0) throw new Error("labels parameter is not supported in Gemini API."); const k = s(t, ["imageSize"]); if (e !== void 0 && k != null && l(e, ["parameters", "sampleImageSize"], k), s(t, ["enhancePrompt"]) !== void 0) throw new Error("enhancePrompt parameter is not supported in Gemini API."); return o } function Mg(t, e) { const o = {}, n = s(t, ["outputGcsUri"]); e !== void 0 && n != null && l(e, ["parameters", "storageUri"], n); const i = s(t, ["negativePrompt"]); e !== void 0 && i != null && l(e, ["parameters", "negativePrompt"], i); const r = s(t, ["numberOfImages"]); e !== void 0 && r != null && l(e, ["parameters", "sampleCount"], r); const a = s(t, ["aspectRatio"]); e !== void 0 && a != null && l(e, ["parameters", "aspectRatio"], a); const c = s(t, ["guidanceScale"]); e !== void 0 && c != null && l(e, ["parameters", "guidanceScale"], c); const f = s(t, ["seed"]); e !== void 0 && f != null && l(e, ["parameters", "seed"], f); const u = s(t, ["safetyFilterLevel"]); e !== void 0 && u != null && l(e, ["parameters", "safetySetting"], u); const p = s(t, ["personGeneration"]); e !== void 0 && p != null && l(e, ["parameters", "personGeneration"], p); const v = s(t, ["includeSafetyAttributes"]); e !== void 0 && v != null && l(e, ["parameters", "includeSafetyAttributes"], v); const T = s(t, ["includeRaiReason"]); e !== void 0 && T != null && l(e, ["parameters", "includeRaiReason"], T); const k = s(t, ["language"]); e !== void 0 && k != null && l(e, ["parameters", "language"], k); const R = s(t, ["outputMimeType"]); e !== void 0 && R != null && l(e, ["parameters", "outputOptions", "mimeType"], R); const $ = s(t, ["outputCompressionQuality"]); e !== void 0 && $ != null && l(e, ["parameters", "outputOptions", "compressionQuality"], $); const N = s(t, ["addWatermark"]); e !== void 0 && N != null && l(e, ["parameters", "addWatermark"], N); const P = s(t, ["labels"]); e !== void 0 && P != null && l(e, ["labels"], P); const W = s(t, ["imageSize"]); e !== void 0 && W != null && l(e, ["parameters", "sampleImageSize"], W); const K = s(t, ["enhancePrompt"]); return e !== void 0 && K != null && l(e, ["parameters", "enhancePrompt"], K), o } function Fg(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["_url", "model"], Ae(t, n)); const i = s(e, ["prompt"]); i != null && l(o, ["instances[0]", "prompt"], i); const r = s(e, ["config"]); return r != null && Pg(r, o), o } function Ug(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["_url", "model"], Ae(t, n)); const i = s(e, ["prompt"]); i != null && l(o, ["instances[0]", "prompt"], i); const r = s(e, ["config"]); return r != null && Mg(r, o), o } function $g(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); o != null && l(e, ["sdkHttpResponse"], o); const n = s(t, ["predictions"]); if (n != null) { let r = n; Array.isArray(r) && (r = r.map(a => Xg(a))), l(e, ["generatedImages"], r) } const i = s(t, ["positivePromptSafetyAttributes"]); return i != null && l(e, ["positivePromptSafetyAttributes"], eu(i)), e } function qg(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); o != null && l(e, ["sdkHttpResponse"], o); const n = s(t, ["predictions"]); if (n != null) { let r = n; Array.isArray(r) && (r = r.map(a => qs(a))), l(e, ["generatedImages"], r) } const i = s(t, ["positivePromptSafetyAttributes"]); return i != null && l(e, ["positivePromptSafetyAttributes"], tu(i)), e } function Vg(t, e) { const o = {}, n = s(t, ["numberOfVideos"]); if (e !== void 0 && n != null && l(e, ["parameters", "sampleCount"], n), s(t, ["outputGcsUri"]) !== void 0) throw new Error("outputGcsUri parameter is not supported in Gemini API."); if (s(t, ["fps"]) !== void 0) throw new Error("fps parameter is not supported in Gemini API."); const i = s(t, ["durationSeconds"]); if (e !== void 0 && i != null && l(e, ["parameters", "durationSeconds"], i), s(t, ["seed"]) !== void 0) throw new Error("seed parameter is not supported in Gemini API."); const r = s(t, ["aspectRatio"]); e !== void 0 && r != null && l(e, ["parameters", "aspectRatio"], r); const a = s(t, ["resolution"]); e !== void 0 && a != null && l(e, ["parameters", "resolution"], a); const c = s(t, ["personGeneration"]); if (e !== void 0 && c != null && l(e, ["parameters", "personGeneration"], c), s(t, ["pubsubTopic"]) !== void 0) throw new Error("pubsubTopic parameter is not supported in Gemini API."); const f = s(t, ["negativePrompt"]); e !== void 0 && f != null && l(e, ["parameters", "negativePrompt"], f); const u = s(t, ["enhancePrompt"]); if (e !== void 0 && u != null && l(e, ["parameters", "enhancePrompt"], u), s(t, ["generateAudio"]) !== void 0) throw new Error("generateAudio parameter is not supported in Gemini API."); const p = s(t, ["lastFrame"]); e !== void 0 && p != null && l(e, ["instances[0]", "lastFrame"], Vs(p)); const v = s(t, ["referenceImages"]); if (e !== void 0 && v != null) { let T = v; Array.isArray(T) && (T = T.map(k => qh(k))), l(e, ["instances[0]", "referenceImages"], T) } if (s(t, ["mask"]) !== void 0) throw new Error("mask parameter is not supported in Gemini API."); if (s(t, ["compressionQuality"]) !== void 0) throw new Error("compressionQuality parameter is not supported in Gemini API."); return o } function Gg(t, e) { const o = {}, n = s(t, ["numberOfVideos"]); e !== void 0 && n != null && l(e, ["parameters", "sampleCount"], n); const i = s(t, ["outputGcsUri"]); e !== void 0 && i != null && l(e, ["parameters", "storageUri"], i); const r = s(t, ["fps"]); e !== void 0 && r != null && l(e, ["parameters", "fps"], r); const a = s(t, ["durationSeconds"]); e !== void 0 && a != null && l(e, ["parameters", "durationSeconds"], a); const c = s(t, ["seed"]); e !== void 0 && c != null && l(e, ["parameters", "seed"], c); const f = s(t, ["aspectRatio"]); e !== void 0 && f != null && l(e, ["parameters", "aspectRatio"], f); const u = s(t, ["resolution"]); e !== void 0 && u != null && l(e, ["parameters", "resolution"], u); const p = s(t, ["personGeneration"]); e !== void 0 && p != null && l(e, ["parameters", "personGeneration"], p); const v = s(t, ["pubsubTopic"]); e !== void 0 && v != null && l(e, ["parameters", "pubsubTopic"], v); const T = s(t, ["negativePrompt"]); e !== void 0 && T != null && l(e, ["parameters", "negativePrompt"], T); const k = s(t, ["enhancePrompt"]); e !== void 0 && k != null && l(e, ["parameters", "enhancePrompt"], k); const R = s(t, ["generateAudio"]); e !== void 0 && R != null && l(e, ["parameters", "generateAudio"], R); const $ = s(t, ["lastFrame"]); e !== void 0 && $ != null && l(e, ["instances[0]", "lastFrame"], nn($)); const N = s(t, ["referenceImages"]); if (e !== void 0 && N != null) { let K = N; Array.isArray(K) && (K = K.map(j => Vh(j))), l(e, ["instances[0]", "referenceImages"], K) } const P = s(t, ["mask"]); e !== void 0 && P != null && l(e, ["instances[0]", "mask"], $h(P)); const W = s(t, ["compressionQuality"]); return e !== void 0 && W != null && l(e, ["parameters", "compressionQuality"], W), o } function Og(t) { const e = {}, o = s(t, ["name"]); o != null && l(e, ["name"], o); const n = s(t, ["metadata"]); n != null && l(e, ["metadata"], n); const i = s(t, ["done"]); i != null && l(e, ["done"], i); const r = s(t, ["error"]); r != null && l(e, ["error"], r); const a = s(t, ["response", "generateVideoResponse"]); return a != null && l(e, ["response"], Wg(a)), e } function Hg(t) { const e = {}, o = s(t, ["name"]); o != null && l(e, ["name"], o); const n = s(t, ["metadata"]); n != null && l(e, ["metadata"], n); const i = s(t, ["done"]); i != null && l(e, ["done"], i); const r = s(t, ["error"]); r != null && l(e, ["error"], r); const a = s(t, ["response"]); return a != null && l(e, ["response"], zg(a)), e } function Bg(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["_url", "model"], Ae(t, n)); const i = s(e, ["prompt"]); i != null && l(o, ["instances[0]", "prompt"], i); const r = s(e, ["image"]); r != null && l(o, ["instances[0]", "image"], Vs(r)); const a = s(e, ["video"]); a != null && l(o, ["instances[0]", "video"], iu(a)); const c = s(e, ["source"]); c != null && Yg(c, o); const f = s(e, ["config"]); return f != null && Vg(f, o), o } function Jg(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["_url", "model"], Ae(t, n)); const i = s(e, ["prompt"]); i != null && l(o, ["instances[0]", "prompt"], i); const r = s(e, ["image"]); r != null && l(o, ["instances[0]", "image"], nn(r)); const a = s(e, ["video"]); a != null && l(o, ["instances[0]", "video"], su(a)); const c = s(e, ["source"]); c != null && Kg(c, o); const f = s(e, ["config"]); return f != null && Gg(f, o), o } function Wg(t) { const e = {}, o = s(t, ["generatedSamples"]); if (o != null) { let r = o; Array.isArray(r) && (r = r.map(a => Qg(a))), l(e, ["generatedVideos"], r) } const n = s(t, ["raiMediaFilteredCount"]); n != null && l(e, ["raiMediaFilteredCount"], n); const i = s(t, ["raiMediaFilteredReasons"]); return i != null && l(e, ["raiMediaFilteredReasons"], i), e } function zg(t) { const e = {}, o = s(t, ["videos"]); if (o != null) { let r = o; Array.isArray(r) && (r = r.map(a => jg(a))), l(e, ["generatedVideos"], r) } const n = s(t, ["raiMediaFilteredCount"]); n != null && l(e, ["raiMediaFilteredCount"], n); const i = s(t, ["raiMediaFilteredReasons"]); return i != null && l(e, ["raiMediaFilteredReasons"], i), e } function Yg(t, e) { const o = {}, n = s(t, ["prompt"]); e !== void 0 && n != null && l(e, ["instances[0]", "prompt"], n); const i = s(t, ["image"]); e !== void 0 && i != null && l(e, ["instances[0]", "image"], Vs(i)); const r = s(t, ["video"]); return e !== void 0 && r != null && l(e, ["instances[0]", "video"], iu(r)), o } function Kg(t, e) { const o = {}, n = s(t, ["prompt"]); e !== void 0 && n != null && l(e, ["instances[0]", "prompt"], n); const i = s(t, ["image"]); e !== void 0 && i != null && l(e, ["instances[0]", "image"], nn(i)); const r = s(t, ["video"]); return e !== void 0 && r != null && l(e, ["instances[0]", "video"], su(r)), o } function Xg(t) { const e = {}, o = s(t, ["_self"]); o != null && l(e, ["image"], sh(o)); const n = s(t, ["raiFilteredReason"]); n != null && l(e, ["raiFilteredReason"], n); const i = s(t, ["_self"]); return i != null && l(e, ["safetyAttributes"], eu(i)), e } function qs(t) { const e = {}, o = s(t, ["_self"]); o != null && l(e, ["image"], jc(o)); const n = s(t, ["raiFilteredReason"]); n != null && l(e, ["raiFilteredReason"], n); const i = s(t, ["_self"]); i != null && l(e, ["safetyAttributes"], tu(i)); const r = s(t, ["prompt"]); return r != null && l(e, ["enhancedPrompt"], r), e } function Zg(t) { const e = {}, o = s(t, ["_self"]); o != null && l(e, ["mask"], jc(o)); const n = s(t, ["labels"]); if (n != null) { let i = n; Array.isArray(i) && (i = i.map(r => r)), l(e, ["labels"], i) } return e } function Qg(t) { const e = {}, o = s(t, ["video"]); return o != null && l(e, ["video"], Fh(o)), e } function jg(t) { const e = {}, o = s(t, ["_self"]); return o != null && l(e, ["video"], Uh(o)), e } function eh(t) { const e = {}, o = s(t, ["modelSelectionConfig"]); o != null && l(e, ["modelConfig"], o); const n = s(t, ["audioTimestamp"]); n != null && l(e, ["audioTimestamp"], n); const i = s(t, ["candidateCount"]); i != null && l(e, ["candidateCount"], i); const r = s(t, ["enableAffectiveDialog"]); r != null && l(e, ["enableAffectiveDialog"], r); const a = s(t, ["frequencyPenalty"]); a != null && l(e, ["frequencyPenalty"], a); const c = s(t, ["logprobs"]); c != null && l(e, ["logprobs"], c); const f = s(t, ["maxOutputTokens"]); f != null && l(e, ["maxOutputTokens"], f); const u = s(t, ["mediaResolution"]); u != null && l(e, ["mediaResolution"], u); const p = s(t, ["presencePenalty"]); p != null && l(e, ["presencePenalty"], p); const v = s(t, ["responseJsonSchema"]); v != null && l(e, ["responseJsonSchema"], v); const T = s(t, ["responseLogprobs"]); T != null && l(e, ["responseLogprobs"], T); const k = s(t, ["responseMimeType"]); k != null && l(e, ["responseMimeType"], k); const R = s(t, ["responseModalities"]); R != null && l(e, ["responseModalities"], R); const $ = s(t, ["responseSchema"]); $ != null && l(e, ["responseSchema"], $); const N = s(t, ["routingConfig"]); N != null && l(e, ["routingConfig"], N); const P = s(t, ["seed"]); P != null && l(e, ["seed"], P); const W = s(t, ["speechConfig"]); W != null && l(e, ["speechConfig"], nu(W)); const K = s(t, ["stopSequences"]); K != null && l(e, ["stopSequences"], K); const j = s(t, ["temperature"]); j != null && l(e, ["temperature"], j); const le = s(t, ["thinkingConfig"]); le != null && l(e, ["thinkingConfig"], le); const de = s(t, ["topK"]); de != null && l(e, ["topK"], de); const ue = s(t, ["topP"]); if (ue != null && l(e, ["topP"], ue), s(t, ["enableEnhancedCivicAnswers"]) !== void 0) throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI."); return e } function th(t, e) { const o = {}, n = s(e, ["model"]); return n != null && l(o, ["_url", "name"], Ae(t, n)), o } function nh(t, e) { const o = {}, n = s(e, ["model"]); return n != null && l(o, ["_url", "name"], Ae(t, n)), o } function oh(t) { const e = {}; if (s(t, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API."); const o = s(t, ["enableWidget"]); return o != null && l(e, ["enableWidget"], o), e } function ih(t) { const e = {}, o = s(t, ["timeRangeFilter"]); if (o != null && l(e, ["timeRangeFilter"], o), s(t, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API."); return e } function sh(t) { const e = {}, o = s(t, ["bytesBase64Encoded"]); o != null && l(e, ["imageBytes"], oo(o)); const n = s(t, ["mimeType"]); return n != null && l(e, ["mimeType"], n), e } function jc(t) { const e = {}, o = s(t, ["gcsUri"]); o != null && l(e, ["gcsUri"], o); const n = s(t, ["bytesBase64Encoded"]); n != null && l(e, ["imageBytes"], oo(n)); const i = s(t, ["mimeType"]); return i != null && l(e, ["mimeType"], i), e } function Vs(t) { const e = {}; if (s(t, ["gcsUri"]) !== void 0) throw new Error("gcsUri parameter is not supported in Gemini API."); const o = s(t, ["imageBytes"]); o != null && l(e, ["bytesBase64Encoded"], oo(o)); const n = s(t, ["mimeType"]); return n != null && l(e, ["mimeType"], n), e } function nn(t) { const e = {}, o = s(t, ["gcsUri"]); o != null && l(e, ["gcsUri"], o); const n = s(t, ["imageBytes"]); n != null && l(e, ["bytesBase64Encoded"], oo(n)); const i = s(t, ["mimeType"]); return i != null && l(e, ["mimeType"], i), e } function ah(t, e, o) { const n = {}, i = s(e, ["pageSize"]); o !== void 0 && i != null && l(o, ["_query", "pageSize"], i); const r = s(e, ["pageToken"]); o !== void 0 && r != null && l(o, ["_query", "pageToken"], r); const a = s(e, ["filter"]); o !== void 0 && a != null && l(o, ["_query", "filter"], a); const c = s(e, ["queryBase"]); return o !== void 0 && c != null && l(o, ["_url", "models_url"], Jc(t, c)), n } function rh(t, e, o) { const n = {}, i = s(e, ["pageSize"]); o !== void 0 && i != null && l(o, ["_query", "pageSize"], i); const r = s(e, ["pageToken"]); o !== void 0 && r != null && l(o, ["_query", "pageToken"], r); const a = s(e, ["filter"]); o !== void 0 && a != null && l(o, ["_query", "filter"], a); const c = s(e, ["queryBase"]); return o !== void 0 && c != null && l(o, ["_url", "models_url"], Jc(t, c)), n } function lh(t, e) { const o = {}, n = s(e, ["config"]); return n != null && ah(t, n, o), o } function dh(t, e) { const o = {}, n = s(e, ["config"]); return n != null && rh(t, n, o), o } function ch(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); o != null && l(e, ["sdkHttpResponse"], o); const n = s(t, ["nextPageToken"]); n != null && l(e, ["nextPageToken"], n); const i = s(t, ["_self"]); if (i != null) { let r = Wc(i); Array.isArray(r) && (r = r.map(a => xr(a))), l(e, ["models"], r) } return e } function uh(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); o != null && l(e, ["sdkHttpResponse"], o); const n = s(t, ["nextPageToken"]); n != null && l(e, ["nextPageToken"], n); const i = s(t, ["_self"]); if (i != null) { let r = Wc(i); Array.isArray(r) && (r = r.map(a => kr(a))), l(e, ["models"], r) } return e } function fh(t) { const e = {}, o = s(t, ["maskMode"]); o != null && l(e, ["maskMode"], o); const n = s(t, ["segmentationClasses"]); n != null && l(e, ["maskClasses"], n); const i = s(t, ["maskDilation"]); return i != null && l(e, ["dilation"], i), e } function xr(t) { const e = {}, o = s(t, ["name"]); o != null && l(e, ["name"], o); const n = s(t, ["displayName"]); n != null && l(e, ["displayName"], n); const i = s(t, ["description"]); i != null && l(e, ["description"], i); const r = s(t, ["version"]); r != null && l(e, ["version"], r); const a = s(t, ["_self"]); a != null && l(e, ["tunedModelInfo"], _h(a)); const c = s(t, ["inputTokenLimit"]); c != null && l(e, ["inputTokenLimit"], c); const f = s(t, ["outputTokenLimit"]); f != null && l(e, ["outputTokenLimit"], f); const u = s(t, ["supportedGenerationMethods"]); return u != null && l(e, ["supportedActions"], u), e } function kr(t) { const e = {}, o = s(t, ["name"]); o != null && l(e, ["name"], o); const n = s(t, ["displayName"]); n != null && l(e, ["displayName"], n); const i = s(t, ["description"]); i != null && l(e, ["description"], i); const r = s(t, ["versionId"]); r != null && l(e, ["version"], r); const a = s(t, ["deployedModels"]); if (a != null) { let v = a; Array.isArray(v) && (v = v.map(T => xg(T))), l(e, ["endpoints"], v) } const c = s(t, ["labels"]); c != null && l(e, ["labels"], c); const f = s(t, ["_self"]); f != null && l(e, ["tunedModelInfo"], Ah(f)); const u = s(t, ["defaultCheckpointId"]); u != null && l(e, ["defaultCheckpointId"], u); const p = s(t, ["checkpoints"]); if (p != null) { let v = p; Array.isArray(v) && (v = v.map(T => T)), l(e, ["checkpoints"], v) } return e } function ph(t) { const e = {}, o = s(t, ["videoMetadata"]); o != null && l(e, ["videoMetadata"], o); const n = s(t, ["thought"]); n != null && l(e, ["thought"], n); const i = s(t, ["inlineData"]); i != null && l(e, ["inlineData"], ng(i)); const r = s(t, ["fileData"]); r != null && l(e, ["fileData"], kg(r)); const a = s(t, ["thoughtSignature"]); a != null && l(e, ["thoughtSignature"], a); const c = s(t, ["functionCall"]); c != null && l(e, ["functionCall"], c); const f = s(t, ["codeExecutionResult"]); f != null && l(e, ["codeExecutionResult"], f); const u = s(t, ["executableCode"]); u != null && l(e, ["executableCode"], u); const p = s(t, ["functionResponse"]); p != null && l(e, ["functionResponse"], p); const v = s(t, ["text"]); return v != null && l(e, ["text"], v), e } function mh(t) { const e = {}, o = s(t, ["productImage"]); return o != null && l(e, ["image"], nn(o)), e } function gh(t, e) { const o = {}, n = s(t, ["numberOfImages"]); e !== void 0 && n != null && l(e, ["parameters", "sampleCount"], n); const i = s(t, ["baseSteps"]); e !== void 0 && i != null && l(e, ["parameters", "editConfig", "baseSteps"], i); const r = s(t, ["outputGcsUri"]); e !== void 0 && r != null && l(e, ["parameters", "storageUri"], r); const a = s(t, ["seed"]); e !== void 0 && a != null && l(e, ["parameters", "seed"], a); const c = s(t, ["safetyFilterLevel"]); e !== void 0 && c != null && l(e, ["parameters", "safetySetting"], c); const f = s(t, ["personGeneration"]); e !== void 0 && f != null && l(e, ["parameters", "personGeneration"], f); const u = s(t, ["addWatermark"]); e !== void 0 && u != null && l(e, ["parameters", "addWatermark"], u); const p = s(t, ["outputMimeType"]); e !== void 0 && p != null && l(e, ["parameters", "outputOptions", "mimeType"], p); const v = s(t, ["outputCompressionQuality"]); e !== void 0 && v != null && l(e, ["parameters", "outputOptions", "compressionQuality"], v); const T = s(t, ["enhancePrompt"]); e !== void 0 && T != null && l(e, ["parameters", "enhancePrompt"], T); const k = s(t, ["labels"]); return e !== void 0 && k != null && l(e, ["labels"], k), o } function hh(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["_url", "model"], Ae(t, n)); const i = s(e, ["source"]); i != null && vh(i, o); const r = s(e, ["config"]); return r != null && gh(r, o), o } function yh(t) { const e = {}, o = s(t, ["predictions"]); if (o != null) { let n = o; Array.isArray(n) && (n = n.map(i => qs(i))), l(e, ["generatedImages"], n) } return e } function vh(t, e) { const o = {}, n = s(t, ["prompt"]); e !== void 0 && n != null && l(e, ["instances[0]", "prompt"], n); const i = s(t, ["personImage"]); e !== void 0 && i != null && l(e, ["instances[0]", "personImage", "image"], nn(i)); const r = s(t, ["productImages"]); if (e !== void 0 && r != null) { let a = r; Array.isArray(a) && (a = a.map(c => mh(c))), l(e, ["instances[0]", "productImages"], a) } return o } function Th(t) { const e = {}, o = s(t, ["referenceImage"]); o != null && l(e, ["referenceImage"], nn(o)); const n = s(t, ["referenceId"]); n != null && l(e, ["referenceId"], n); const i = s(t, ["referenceType"]); i != null && l(e, ["referenceType"], i); const r = s(t, ["maskImageConfig"]); r != null && l(e, ["maskImageConfig"], fh(r)); const a = s(t, ["controlImageConfig"]); a != null && l(e, ["controlImageConfig"], dg(a)); const c = s(t, ["styleImageConfig"]); c != null && l(e, ["styleImageConfig"], c); const f = s(t, ["subjectImageConfig"]); return f != null && l(e, ["subjectImageConfig"], f), e } function eu(t) { const e = {}, o = s(t, ["safetyAttributes", "categories"]); o != null && l(e, ["categories"], o); const n = s(t, ["safetyAttributes", "scores"]); n != null && l(e, ["scores"], n); const i = s(t, ["contentType"]); return i != null && l(e, ["contentType"], i), e } function tu(t) { const e = {}, o = s(t, ["safetyAttributes", "categories"]); o != null && l(e, ["categories"], o); const n = s(t, ["safetyAttributes", "scores"]); n != null && l(e, ["scores"], n); const i = s(t, ["contentType"]); return i != null && l(e, ["contentType"], i), e } function Eh(t) { const e = {}; if (s(t, ["method"]) !== void 0) throw new Error("method parameter is not supported in Gemini API."); const o = s(t, ["category"]); o != null && l(e, ["category"], o); const n = s(t, ["threshold"]); return n != null && l(e, ["threshold"], n), e } function bh(t) { const e = {}, o = s(t, ["image"]); return o != null && l(e, ["image"], nn(o)), e } function Ch(t, e) { const o = {}, n = s(t, ["mode"]); e !== void 0 && n != null && l(e, ["parameters", "mode"], n); const i = s(t, ["maxPredictions"]); e !== void 0 && i != null && l(e, ["parameters", "maxPredictions"], i); const r = s(t, ["confidenceThreshold"]); e !== void 0 && r != null && l(e, ["parameters", "confidenceThreshold"], r); const a = s(t, ["maskDilation"]); e !== void 0 && a != null && l(e, ["parameters", "maskDilation"], a); const c = s(t, ["binaryColorThreshold"]); e !== void 0 && c != null && l(e, ["parameters", "binaryColorThreshold"], c); const f = s(t, ["labels"]); return e !== void 0 && f != null && l(e, ["labels"], f), o } function wh(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["_url", "model"], Ae(t, n)); const i = s(e, ["source"]); i != null && Sh(i, o); const r = s(e, ["config"]); return r != null && Ch(r, o), o } function Ih(t) { const e = {}, o = s(t, ["predictions"]); if (o != null) { let n = o; Array.isArray(n) && (n = n.map(i => Zg(i))), l(e, ["generatedMasks"], n) } return e } function Sh(t, e) { const o = {}, n = s(t, ["prompt"]); e !== void 0 && n != null && l(e, ["instances[0]", "prompt"], n); const i = s(t, ["image"]); e !== void 0 && i != null && l(e, ["instances[0]", "image"], nn(i)); const r = s(t, ["scribbleImage"]); return e !== void 0 && r != null && l(e, ["instances[0]", "scribble"], bh(r)), o } function nu(t) { const e = {}, o = s(t, ["voiceConfig"]); if (o != null && l(e, ["voiceConfig"], o), s(t, ["multiSpeakerVoiceConfig"]) !== void 0) throw new Error("multiSpeakerVoiceConfig parameter is not supported in Vertex AI."); const n = s(t, ["languageCode"]); return n != null && l(e, ["languageCode"], n), e } function Lh(t) { const e = {}, o = s(t, ["functionDeclarations"]); if (o != null) { let u = o; Array.isArray(u) && (u = u.map(p => p)), l(e, ["functionDeclarations"], u) } if (s(t, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API."); const n = s(t, ["googleSearch"]); n != null && l(e, ["googleSearch"], ih(n)); const i = s(t, ["googleSearchRetrieval"]); if (i != null && l(e, ["googleSearchRetrieval"], i), s(t, ["enterpriseWebSearch"]) !== void 0) throw new Error("enterpriseWebSearch parameter is not supported in Gemini API."); const r = s(t, ["googleMaps"]); r != null && l(e, ["googleMaps"], oh(r)); const a = s(t, ["urlContext"]); a != null && l(e, ["urlContext"], a); const c = s(t, ["computerUse"]); c != null && l(e, ["computerUse"], c); const f = s(t, ["codeExecution"]); return f != null && l(e, ["codeExecution"], f), e } function ou(t) { const e = {}, o = s(t, ["functionDeclarations"]); if (o != null) { let v = o; Array.isArray(v) && (v = v.map(T => Rg(T))), l(e, ["functionDeclarations"], v) } const n = s(t, ["retrieval"]); n != null && l(e, ["retrieval"], n); const i = s(t, ["googleSearch"]); i != null && l(e, ["googleSearch"], i); const r = s(t, ["googleSearchRetrieval"]); r != null && l(e, ["googleSearchRetrieval"], r); const a = s(t, ["enterpriseWebSearch"]); a != null && l(e, ["enterpriseWebSearch"], a); const c = s(t, ["googleMaps"]); c != null && l(e, ["googleMaps"], c); const f = s(t, ["urlContext"]); f != null && l(e, ["urlContext"], f); const u = s(t, ["computerUse"]); u != null && l(e, ["computerUse"], u); const p = s(t, ["codeExecution"]); return p != null && l(e, ["codeExecution"], p), e } function _h(t) { const e = {}, o = s(t, ["baseModel"]); o != null && l(e, ["baseModel"], o); const n = s(t, ["createTime"]); n != null && l(e, ["createTime"], n); const i = s(t, ["updateTime"]); return i != null && l(e, ["updateTime"], i), e } function Ah(t) { const e = {}, o = s(t, ["labels", "google-vertex-llm-tuning-base-model-id"]); o != null && l(e, ["baseModel"], o); const n = s(t, ["createTime"]); n != null && l(e, ["createTime"], n); const i = s(t, ["updateTime"]); return i != null && l(e, ["updateTime"], i), e } function xh(t, e) { const o = {}, n = s(t, ["displayName"]); e !== void 0 && n != null && l(e, ["displayName"], n); const i = s(t, ["description"]); e !== void 0 && i != null && l(e, ["description"], i); const r = s(t, ["defaultCheckpointId"]); return e !== void 0 && r != null && l(e, ["defaultCheckpointId"], r), o } function kh(t, e) { const o = {}, n = s(t, ["displayName"]); e !== void 0 && n != null && l(e, ["displayName"], n); const i = s(t, ["description"]); e !== void 0 && i != null && l(e, ["description"], i); const r = s(t, ["defaultCheckpointId"]); return e !== void 0 && r != null && l(e, ["defaultCheckpointId"], r), o } function Rh(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["_url", "name"], Ae(t, n)); const i = s(e, ["config"]); return i != null && xh(i, o), o } function Dh(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["_url", "model"], Ae(t, n)); const i = s(e, ["config"]); return i != null && kh(i, o), o } function Nh(t, e) { const o = {}, n = s(t, ["outputGcsUri"]); e !== void 0 && n != null && l(e, ["parameters", "storageUri"], n); const i = s(t, ["includeRaiReason"]); e !== void 0 && i != null && l(e, ["parameters", "includeRaiReason"], i); const r = s(t, ["outputMimeType"]); e !== void 0 && r != null && l(e, ["parameters", "outputOptions", "mimeType"], r); const a = s(t, ["outputCompressionQuality"]); e !== void 0 && a != null && l(e, ["parameters", "outputOptions", "compressionQuality"], a); const c = s(t, ["enhanceInputImage"]); e !== void 0 && c != null && l(e, ["parameters", "upscaleConfig", "enhanceInputImage"], c); const f = s(t, ["imagePreservationFactor"]); e !== void 0 && f != null && l(e, ["parameters", "upscaleConfig", "imagePreservationFactor"], f); const u = s(t, ["labels"]); e !== void 0 && u != null && l(e, ["labels"], u); const p = s(t, ["numberOfImages"]); e !== void 0 && p != null && l(e, ["parameters", "sampleCount"], p); const v = s(t, ["mode"]); return e !== void 0 && v != null && l(e, ["parameters", "mode"], v), o } function Ph(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["_url", "model"], Ae(t, n)); const i = s(e, ["image"]); i != null && l(o, ["instances[0]", "image"], nn(i)); const r = s(e, ["upscaleFactor"]); r != null && l(o, ["parameters", "upscaleConfig", "upscaleFactor"], r); const a = s(e, ["config"]); return a != null && Nh(a, o), o } function Mh(t) { const e = {}, o = s(t, ["sdkHttpResponse"]); o != null && l(e, ["sdkHttpResponse"], o); const n = s(t, ["predictions"]); if (n != null) { let i = n; Array.isArray(i) && (i = i.map(r => qs(r))), l(e, ["generatedImages"], i) } return e } function Fh(t) { const e = {}, o = s(t, ["uri"]); o != null && l(e, ["uri"], o); const n = s(t, ["encodedVideo"]); n != null && l(e, ["videoBytes"], oo(n)); const i = s(t, ["encoding"]); return i != null && l(e, ["mimeType"], i), e } function Uh(t) { const e = {}, o = s(t, ["gcsUri"]); o != null && l(e, ["uri"], o); const n = s(t, ["bytesBase64Encoded"]); n != null && l(e, ["videoBytes"], oo(n)); const i = s(t, ["mimeType"]); return i != null && l(e, ["mimeType"], i), e } function $h(t) { const e = {}, o = s(t, ["image"]); o != null && l(e, ["_self"], nn(o)); const n = s(t, ["maskMode"]); return n != null && l(e, ["maskMode"], n), e } function qh(t) { const e = {}, o = s(t, ["image"]); o != null && l(e, ["image"], Vs(o)); const n = s(t, ["referenceType"]); return n != null && l(e, ["referenceType"], n), e } function Vh(t) { const e = {}, o = s(t, ["image"]); o != null && l(e, ["image"], nn(o)); const n = s(t, ["referenceType"]); return n != null && l(e, ["referenceType"], n), e } function iu(t) { const e = {}, o = s(t, ["uri"]); o != null && l(e, ["uri"], o); const n = s(t, ["videoBytes"]); n != null && l(e, ["encodedVideo"], oo(n)); const i = s(t, ["mimeType"]); return i != null && l(e, ["encoding"], i), e } function su(t) { const e = {}, o = s(t, ["uri"]); o != null && l(e, ["gcsUri"], o); const n = s(t, ["videoBytes"]); n != null && l(e, ["bytesBase64Encoded"], oo(n)); const i = s(t, ["mimeType"]); return i != null && l(e, ["mimeType"], i), e }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const Gh = "Content-Type", Oh = "X-Server-Timeout", Hh = "User-Agent", Rr = "x-goog-api-client", Bh = "1.27.0", Jh = `google-genai-sdk/${Bh}`, Wh = "v1beta1", zh = "v1beta", xc = /^\s*data: (.*)(?:\n\n|\r\r|\r\n\r\n)/; class Yh { constructor(e) { var o, n; this.clientOptions = Object.assign(Object.assign({}, e), { project: e.project, location: e.location, apiKey: e.apiKey, vertexai: e.vertexai }); const i = {}; this.clientOptions.vertexai ? (i.apiVersion = (o = this.clientOptions.apiVersion) !== null && o !== void 0 ? o : Wh, i.baseUrl = this.baseUrlFromProjectLocation(), this.normalizeAuthParameters()) : (i.apiVersion = (n = this.clientOptions.apiVersion) !== null && n !== void 0 ? n : zh, i.baseUrl = "https://generativelanguage.googleapis.com/"), i.headers = this.getDefaultHeaders(), this.clientOptions.httpOptions = i, e.httpOptions && (this.clientOptions.httpOptions = this.patchHttpOptions(i, e.httpOptions)) } baseUrlFromProjectLocation() { return this.clientOptions.project && this.clientOptions.location && this.clientOptions.location !== "global" ? `https://${this.clientOptions.location}-aiplatform.googleapis.com/` : "https://aiplatform.googleapis.com/" } normalizeAuthParameters() { if (this.clientOptions.project && this.clientOptions.location) { this.clientOptions.apiKey = void 0; return } this.clientOptions.project = void 0, this.clientOptions.location = void 0 } isVertexAI() { var e; return (e = this.clientOptions.vertexai) !== null && e !== void 0 ? e : !1 } getProject() { return this.clientOptions.project } getLocation() { return this.clientOptions.location } getApiVersion() { if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== void 0) return this.clientOptions.httpOptions.apiVersion; throw new Error("API version is not set.") } getBaseUrl() { if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== void 0) return this.clientOptions.httpOptions.baseUrl; throw new Error("Base URL is not set.") } getRequestUrl() { return this.getRequestUrlInternal(this.clientOptions.httpOptions) } getHeaders() { if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== void 0) return this.clientOptions.httpOptions.headers; throw new Error("Headers are not set.") } getRequestUrlInternal(e) { if (!e || e.baseUrl === void 0 || e.apiVersion === void 0) throw new Error("HTTP options are not correctly set."); const n = [e.baseUrl.endsWith("/") ? e.baseUrl.slice(0, -1) : e.baseUrl]; return e.apiVersion && e.apiVersion !== "" && n.push(e.apiVersion), n.join("/") } getBaseResourcePath() { return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}` } getApiKey() { return this.clientOptions.apiKey } getWebsocketBaseUrl() { const e = this.getBaseUrl(), o = new URL(e); return o.protocol = o.protocol == "http:" ? "ws" : "wss", o.toString() } setBaseUrl(e) { if (this.clientOptions.httpOptions) this.clientOptions.httpOptions.baseUrl = e; else throw new Error("HTTP options are not correctly set.") } constructUrl(e, o, n) { const i = [this.getRequestUrlInternal(o)]; return n && i.push(this.getBaseResourcePath()), e !== "" && i.push(e), new URL(`${i.join("/")}`) } shouldPrependVertexProjectPath(e) { return !(this.clientOptions.apiKey || !this.clientOptions.vertexai || e.path.startsWith("projects/") || e.httpMethod === "GET" && e.path.startsWith("publishers/google/models")) } async request(e) { let o = this.clientOptions.httpOptions; e.httpOptions && (o = this.patchHttpOptions(this.clientOptions.httpOptions, e.httpOptions)); const n = this.shouldPrependVertexProjectPath(e), i = this.constructUrl(e.path, o, n); if (e.queryParams) for (const [a, c] of Object.entries(e.queryParams)) i.searchParams.append(a, String(c)); let r = {}; if (e.httpMethod === "GET") { if (e.body && e.body !== "{}") throw new Error("Request body should be empty for GET request, but got non empty request body") } else r.body = e.body; return r = await this.includeExtraHttpOptionsToRequestInit(r, o, i.toString(), e.abortSignal), this.unaryApiCall(i, r, e.httpMethod) } patchHttpOptions(e, o) { const n = JSON.parse(JSON.stringify(e)); for (const [i, r] of Object.entries(o)) typeof r == "object" ? n[i] = Object.assign(Object.assign({}, n[i]), r) : r !== void 0 && (n[i] = r); return n } async requestStream(e) { let o = this.clientOptions.httpOptions; e.httpOptions && (o = this.patchHttpOptions(this.clientOptions.httpOptions, e.httpOptions)); const n = this.shouldPrependVertexProjectPath(e), i = this.constructUrl(e.path, o, n); (!i.searchParams.has("alt") || i.searchParams.get("alt") !== "sse") && i.searchParams.set("alt", "sse"); let r = {}; return r.body = e.body, r = await this.includeExtraHttpOptionsToRequestInit(r, o, i.toString(), e.abortSignal), this.streamApiCall(i, r, e.httpMethod) } async includeExtraHttpOptionsToRequestInit(e, o, n, i) { if (o && o.timeout || i) { const r = new AbortController, a = r.signal; if (o.timeout && (o == null ? void 0 : o.timeout) > 0) { const c = setTimeout(() => r.abort(), o.timeout); c && typeof c.unref == "function" && c.unref() } i && i.addEventListener("abort", () => { r.abort() }), e.signal = a } return o && o.extraBody !== null && Kh(e, o.extraBody), e.headers = await this.getHeadersInternal(o, n), e } async unaryApiCall(e, o, n) { return this.apiCall(e.toString(), Object.assign(Object.assign({}, o), { method: n })).then(async i => (await kc(i), new Lr(i))).catch(i => { throw i instanceof Error ? i : new Error(JSON.stringify(i)) }) } async streamApiCall(e, o, n) { return this.apiCall(e.toString(), Object.assign(Object.assign({}, o), { method: n })).then(async i => (await kc(i), this.processStreamResponse(i))).catch(i => { throw i instanceof Error ? i : new Error(JSON.stringify(i)) }) } processStreamResponse(e) { var o; return bi(this, arguments, function* () { const i = (o = e == null ? void 0 : e.body) === null || o === void 0 ? void 0 : o.getReader(), r = new TextDecoder("utf-8"); if (!i) throw new Error("Response body is empty"); try { let a = ""; for (; ;) { const { done: c, value: f } = yield Ke(i.read()); if (c) { if (a.trim().length > 0) throw new Error("Incomplete JSON segment at the end"); break } const u = r.decode(f, { stream: !0 }); try { const v = JSON.parse(u); if ("error" in v) { const T = JSON.parse(JSON.stringify(v.error)), k = T.status, R = T.code, $ = `got status: ${k}. ${JSON.stringify(v)}`; if (R >= 400 && R < 600) throw new Us({ message: $, status: R }) } } catch (v) { if (v.name === "ApiError") throw v } a += u; let p = a.match(xc); for (; p;) { const v = p[1]; try { const T = new Response(v, { headers: e == null ? void 0 : e.headers, status: e == null ? void 0 : e.status, statusText: e == null ? void 0 : e.statusText }); yield yield Ke(new Lr(T)), a = a.slice(p[0].length), p = a.match(xc) } catch (T) { throw new Error(`exception parsing stream chunk ${v}. ${T}`) } } } } finally { i.releaseLock() } }) } async apiCall(e, o) { return fetch(e, o).catch(n => { throw new Error(`exception ${n} sending request`) }) } getDefaultHeaders() { const e = {}, o = Jh + " " + this.clientOptions.userAgentExtra; return e[Hh] = o, e[Rr] = o, e[Gh] = "application/json", e } async getHeadersInternal(e, o) { const n = new Headers; if (e && e.headers) { for (const [i, r] of Object.entries(e.headers)) n.append(i, r); e.timeout && e.timeout > 0 && n.append(Oh, String(Math.ceil(e.timeout / 1e3))) } return await this.clientOptions.auth.addAuthHeaders(n, o), n } async uploadFile(e, o) { var n; const i = {}; o != null && (i.mimeType = o.mimeType, i.name = o.name, i.displayName = o.displayName), i.name && !i.name.startsWith("files/") && (i.name = `files/${i.name}`); const r = this.clientOptions.uploader, a = await r.stat(e); i.sizeBytes = String(a.size); const c = (n = o == null ? void 0 : o.mimeType) !== null && n !== void 0 ? n : a.type; if (c === void 0 || c === "") throw new Error("Can not determine mimeType. Please provide mimeType in the config."); i.mimeType = c; const f = await this.fetchUploadUrl(i, o); return r.upload(e, f, this) } async downloadFile(e) { await this.clientOptions.downloader.download(e, this) } async fetchUploadUrl(e, o) { var n; let i = {}; o != null && o.httpOptions ? i = o.httpOptions : i = { apiVersion: "", headers: { "Content-Type": "application/json", "X-Goog-Upload-Protocol": "resumable", "X-Goog-Upload-Command": "start", "X-Goog-Upload-Header-Content-Length": `${e.sizeBytes}`, "X-Goog-Upload-Header-Content-Type": `${e.mimeType}` } }; const r = { file: e }, a = await this.request({ path: ie("upload/v1beta/files", r._url), body: JSON.stringify(r), httpMethod: "POST", httpOptions: i }); if (!a || !(a != null && a.headers)) throw new Error("Server did not return an HttpResponse or the returned HttpResponse did not have headers."); const c = (n = a == null ? void 0 : a.headers) === null || n === void 0 ? void 0 : n["x-goog-upload-url"]; if (c === void 0) throw new Error("Failed to get upload url. Server did not return the x-google-upload-url in the headers"); return c } } async function kc(t) { var e; if (t === void 0) throw new Error("response is undefined"); if (!t.ok) { const o = t.status; let n; !((e = t.headers.get("content-type")) === null || e === void 0) && e.includes("application/json") ? n = await t.json() : n = { error: { message: await t.text(), code: t.status, status: t.statusText } }; const i = JSON.stringify(n); throw o >= 400 && o < 600 ? new Us({ message: i, status: o }) : new Error(i) } } function Kh(t, e) { if (!e || Object.keys(e).length === 0) return; if (t.body instanceof Blob) { console.warn("includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies."); return } let o = {}; if (typeof t.body == "string" && t.body.length > 0) try { const r = JSON.parse(t.body); if (typeof r == "object" && r !== null && !Array.isArray(r)) o = r; else { console.warn("includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body."); return } } catch { console.warn("includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body."); return } function n(r, a) { const c = Object.assign({}, r); for (const f in a) if (Object.prototype.hasOwnProperty.call(a, f)) { const u = a[f], p = c[f]; u && typeof u == "object" && !Array.isArray(u) && p && typeof p == "object" && !Array.isArray(p) ? c[f] = n(p, u) : (p && u && typeof p != typeof u && console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key "${f}". Original type: ${typeof p}, New type: ${typeof u}. Overwriting.`), c[f] = u) } return c } const i = n(o, e); t.body = JSON.stringify(i) }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const Xh = "mcp_used/unknown"; let Zh = !1; function au(t) { for (const e of t) if (Qh(e) || typeof e == "object" && "inputSchema" in e) return !0; return Zh } function ru(t) { var e; const o = (e = t[Rr]) !== null && e !== void 0 ? e : ""; t[Rr] = (o + ` ${Xh}`).trimStart() } function Qh(t) { return t !== null && typeof t == "object" && t instanceof $r } function jh(t, e = 100) { return bi(this, arguments, function* () { let n, i = 0; for (; i < e;) { const r = yield Ke(t.listTools({ cursor: n })); for (const a of r.tools) yield yield Ke(a), i++; if (!r.nextCursor) break; n = r.nextCursor } }) } class $r { constructor(e = [], o) { this.mcpTools = [], this.functionNameToMcpClient = {}, this.mcpClients = e, this.config = o } static create(e, o) { return new $r(e, o) } async initialize() { var e, o, n, i; if (this.mcpTools.length > 0) return; const r = {}, a = []; for (const p of this.mcpClients) try { for (var c = !0, f = (o = void 0, Xi(jh(p))), u; u = await f.next(), e = u.done, !e; c = !0) { i = u.value, c = !1; const v = i; a.push(v); const T = v.name; if (r[T]) throw new Error(`Duplicate function name ${T} found in MCP tools. Please ensure function names are unique.`); r[T] = p } } catch (v) { o = { error: v } } finally { try { !c && !e && (n = f.return) && await n.call(f) } finally { if (o) throw o.error } } this.mcpTools = a, this.functionNameToMcpClient = r } async tool() { return await this.initialize(), ip(this.mcpTools, this.config) } async callTool(e) { await this.initialize(); const o = []; for (const n of e) if (n.name in this.functionNameToMcpClient) { const i = this.functionNameToMcpClient[n.name]; let r; this.config.timeout && (r = { timeout: this.config.timeout }); const a = await i.callTool({ name: n.name, arguments: n.args }, void 0, r); o.push({ functionResponse: { name: n.name, response: a.isError ? { error: a } : a } }) } return o } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */async function ey(t, e, o) { const n = new Xf; let i; o.data instanceof Blob ? i = JSON.parse(await o.data.text()) : i = JSON.parse(o.data), Object.assign(n, i), e(n) } class ty { constructor(e, o, n) { this.apiClient = e, this.auth = o, this.webSocketFactory = n } async connect(e) { var o, n; if (this.apiClient.isVertexAI()) throw new Error("Live music is not supported for Vertex AI."); console.warn("Live music generation is experimental and may change in future versions."); const i = this.apiClient.getWebsocketBaseUrl(), r = this.apiClient.getApiVersion(), a = iy(this.apiClient.getDefaultHeaders()), c = this.apiClient.getApiKey(), f = `${i}/ws/google.ai.generativelanguage.${r}.GenerativeService.BidiGenerateMusic?key=${c}`; let u = () => { }; const p = new Promise(K => { u = K }), v = e.callbacks, T = function () { u({}) }, k = this.apiClient, R = { onopen: T, onmessage: K => { ey(k, v.onmessage, K) }, onerror: (o = v == null ? void 0 : v.onerror) !== null && o !== void 0 ? o : function (K) { }, onclose: (n = v == null ? void 0 : v.onclose) !== null && n !== void 0 ? n : function (K) { } }, $ = this.webSocketFactory.create(f, oy(a), R); $.connect(), await p; const W = { setup: { model: Ae(this.apiClient, e.model) } }; return $.send(JSON.stringify(W)), new ny($, this.apiClient) } } class ny { constructor(e, o) { this.conn = e, this.apiClient = o } async setWeightedPrompts(e) { if (!e.weightedPrompts || Object.keys(e.weightedPrompts).length === 0) throw new Error("Weighted prompts must be set and contain at least one entry."); const o = zm(e); this.conn.send(JSON.stringify({ clientContent: o })) } async setMusicGenerationConfig(e) { e.musicGenerationConfig || (e.musicGenerationConfig = {}); const o = Wm(e); this.conn.send(JSON.stringify(o)) } sendPlaybackControl(e) { const o = { playbackControl: e }; this.conn.send(JSON.stringify(o)) } play() { this.sendPlaybackControl(Ti.PLAY) } pause() { this.sendPlaybackControl(Ti.PAUSE) } stop() { this.sendPlaybackControl(Ti.STOP) } resetContext() { this.sendPlaybackControl(Ti.RESET_CONTEXT) } close() { this.conn.close() } } function oy(t) { const e = {}; return t.forEach((o, n) => { e[n] = o }), e } function iy(t) { const e = new Headers; for (const [o, n] of Object.entries(t)) e.append(o, n); return e }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const sy = "FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI."; async function ay(t, e, o) { const n = new Kf; let i; o.data instanceof Blob ? i = await o.data.text() : o.data instanceof ArrayBuffer ? i = new TextDecoder().decode(o.data) : i = o.data; const r = JSON.parse(i); if (t.isVertexAI()) { const a = Xm(r); Object.assign(n, a) } else Object.assign(n, r); e(n) } class ry { constructor(e, o, n) { this.apiClient = e, this.auth = o, this.webSocketFactory = n, this.music = new ty(this.apiClient, this.auth, this.webSocketFactory) } async connect(e) { var o, n, i, r, a, c; if (e.config && e.config.httpOptions) throw new Error("The Live module does not support httpOptions at request-level in LiveConnectConfig yet. Please use the client-level httpOptions configuration instead."); const f = this.apiClient.getWebsocketBaseUrl(), u = this.apiClient.getApiVersion(); let p; const v = this.apiClient.getHeaders(); e.config && e.config.tools && au(e.config.tools) && ru(v); const T = uy(v); if (this.apiClient.isVertexAI()) p = `${f}/ws/google.cloud.aiplatform.${u}.LlmBidiService/BidiGenerateContent`, await this.auth.addAuthHeaders(T, p); else { const re = this.apiClient.getApiKey(); let ye = "BidiGenerateContent", xe = "key"; re != null && re.startsWith("auth_tokens/") && (console.warn("Warning: Ephemeral token support is experimental and may change in future versions."), u !== "v1alpha" && console.warn("Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection."), ye = "BidiGenerateContentConstrained", xe = "access_token"), p = `${f}/ws/google.ai.generativelanguage.${u}.GenerativeService.${ye}?${xe}=${re}` } let k = () => { }; const R = new Promise(re => { k = re }), $ = e.callbacks, N = function () { var re; (re = $ == null ? void 0 : $.onopen) === null || re === void 0 || re.call($), k({}) }, P = this.apiClient, W = { onopen: N, onmessage: re => { ay(P, $.onmessage, re) }, onerror: (o = $ == null ? void 0 : $.onerror) !== null && o !== void 0 ? o : function (re) { }, onclose: (n = $ == null ? void 0 : $.onclose) !== null && n !== void 0 ? n : function (re) { } }, K = this.webSocketFactory.create(p, cy(T), W); K.connect(), await R; let j = Ae(this.apiClient, e.model); if (this.apiClient.isVertexAI() && j.startsWith("publishers/")) { const re = this.apiClient.getProject(), ye = this.apiClient.getLocation(); j = `projects/${re}/locations/${ye}/` + j } let le = {}; this.apiClient.isVertexAI() && ((i = e.config) === null || i === void 0 ? void 0 : i.responseModalities) === void 0 && (e.config === void 0 ? e.config = { responseModalities: [St.AUDIO] } : e.config.responseModalities = [St.AUDIO]), !((r = e.config) === null || r === void 0) && r.generationConfig && console.warn("Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025)."); const de = (c = (a = e.config) === null || a === void 0 ? void 0 : a.tools) !== null && c !== void 0 ? c : [], ue = []; for (const re of de) if (this.isCallableTool(re)) { const ye = re; ue.push(await ye.tool()) } else ue.push(re); ue.length > 0 && (e.config.tools = ue); const Fe = { model: j, config: e.config, callbacks: e.callbacks }; return this.apiClient.isVertexAI() ? le = Jm(this.apiClient, Fe) : le = Bm(this.apiClient, Fe), delete le.config, K.send(JSON.stringify(le)), new dy(K, this.apiClient) } isCallableTool(e) { return "callTool" in e && typeof e.callTool == "function" } } const ly = { turnComplete: !0 }; class dy { constructor(e, o) { this.conn = e, this.apiClient = o } tLiveClientContent(e, o) { if (o.turns !== null && o.turns !== void 0) { let n = []; try { n = zt(o.turns), e.isVertexAI() || (n = n.map(i => $s(i))) } catch { throw new Error(`Failed to parse client content "turns", type: '${typeof o.turns}'`) } return { clientContent: { turns: n, turnComplete: o.turnComplete } } } return { clientContent: { turnComplete: o.turnComplete } } } tLiveClienttToolResponse(e, o) { let n = []; if (o.functionResponses == null) throw new Error("functionResponses is required."); if (Array.isArray(o.functionResponses) ? n = o.functionResponses : n = [o.functionResponses], n.length === 0) throw new Error("functionResponses is required."); for (const r of n) { if (typeof r != "object" || r === null || !("name" in r) || !("response" in r)) throw new Error(`Could not parse function response, type '${typeof r}'.`); if (!e.isVertexAI() && !("id" in r)) throw new Error(sy) } return { toolResponse: { functionResponses: n } } } sendClientContent(e) { e = Object.assign(Object.assign({}, ly), e); const o = this.tLiveClientContent(this.apiClient, e); this.conn.send(JSON.stringify(o)) } sendRealtimeInput(e) { let o = {}; this.apiClient.isVertexAI() ? o = { realtimeInput: Km(e) } : o = { realtimeInput: Ym(e) }, this.conn.send(JSON.stringify(o)) } sendToolResponse(e) { if (e.functionResponses == null) throw new Error("Tool response parameters are required."); const o = this.tLiveClienttToolResponse(this.apiClient, e); this.conn.send(JSON.stringify(o)) } close() { this.conn.close() } } function cy(t) { const e = {}; return t.forEach((o, n) => { e[n] = o }), e } function uy(t) { const e = new Headers; for (const [o, n] of Object.entries(t)) e.append(o, n); return e }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const Rc = 10; function Dc(t) { var e, o, n; if (!((e = t == null ? void 0 : t.automaticFunctionCalling) === null || e === void 0) && e.disable) return !0; let i = !1; for (const a of (o = t == null ? void 0 : t.tools) !== null && o !== void 0 ? o : []) if (Ci(a)) { i = !0; break } if (!i) return !0; const r = (n = t == null ? void 0 : t.automaticFunctionCalling) === null || n === void 0 ? void 0 : n.maximumRemoteCalls; return r && (r < 0 || !Number.isInteger(r)) || r == 0 ? (console.warn("Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:", r), !0) : !1 } function Ci(t) { return "callTool" in t && typeof t.callTool == "function" } function fy(t) { var e, o, n; return (n = (o = (e = t.config) === null || e === void 0 ? void 0 : e.tools) === null || o === void 0 ? void 0 : o.some(i => Ci(i))) !== null && n !== void 0 ? n : !1 } function py(t) { var e, o, n; return (n = (o = (e = t.config) === null || e === void 0 ? void 0 : e.tools) === null || o === void 0 ? void 0 : o.some(i => !Ci(i))) !== null && n !== void 0 ? n : !1 } function Nc(t) { var e; return !(!((e = t == null ? void 0 : t.automaticFunctionCalling) === null || e === void 0) && e.ignoreCallHistory) }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class my extends So { constructor(e) { super(), this.apiClient = e, this.generateContent = async o => { var n, i, r, a, c; const f = await this.processParamsMaybeAddMcpUsage(o); if (this.maybeMoveToResponseJsonSchem(o), !fy(o) || Dc(o.config)) return await this.generateContentInternal(f); if (py(o)) throw new Error("Automatic function calling with CallableTools and Tools is not yet supported."); let u, p; const v = zt(f.contents), T = (r = (i = (n = f.config) === null || n === void 0 ? void 0 : n.automaticFunctionCalling) === null || i === void 0 ? void 0 : i.maximumRemoteCalls) !== null && r !== void 0 ? r : Rc; let k = 0; for (; k < T && (u = await this.generateContentInternal(f), !(!u.functionCalls || u.functionCalls.length === 0));) { const R = u.candidates[0].content, $ = []; for (const N of (c = (a = o.config) === null || a === void 0 ? void 0 : a.tools) !== null && c !== void 0 ? c : []) if (Ci(N)) { const W = await N.callTool(u.functionCalls); $.push(...W) } k++, p = { role: "user", parts: $ }, f.contents = zt(f.contents), f.contents.push(R), f.contents.push(p), Nc(f.config) && (v.push(R), v.push(p)) } return Nc(f.config) && (u.automaticFunctionCallingHistory = v), u }, this.generateContentStream = async o => { if (this.maybeMoveToResponseJsonSchem(o), Dc(o.config)) { const n = await this.processParamsMaybeAddMcpUsage(o); return await this.generateContentStreamInternal(n) } else return await this.processAfcStream(o) }, this.generateImages = async o => await this.generateImagesInternal(o).then(n => { var i; let r; const a = []; if (n != null && n.generatedImages) for (const f of n.generatedImages) f && (f != null && f.safetyAttributes) && ((i = f == null ? void 0 : f.safetyAttributes) === null || i === void 0 ? void 0 : i.contentType) === "Positive Prompt" ? r = f == null ? void 0 : f.safetyAttributes : a.push(f); let c; return r ? c = { generatedImages: a, positivePromptSafetyAttributes: r, sdkHttpResponse: n.sdkHttpResponse } : c = { generatedImages: a, sdkHttpResponse: n.sdkHttpResponse }, c }), this.list = async o => { var n; const a = { config: Object.assign(Object.assign({}, { queryBase: !0 }), o == null ? void 0 : o.config) }; if (this.apiClient.isVertexAI() && !a.config.queryBase) { if (!((n = a.config) === null || n === void 0) && n.filter) throw new Error("Filtering tuned models list for Vertex AI is not currently supported"); a.config.filter = "labels.tune-type:*" } return new Zi(Io.PAGED_ITEM_MODELS, c => this.listInternal(c), await this.listInternal(a), a) }, this.editImage = async o => { const n = { model: o.model, prompt: o.prompt, referenceImages: [], config: o.config }; return o.referenceImages && o.referenceImages && (n.referenceImages = o.referenceImages.map(i => i.toReferenceImageAPI())), await this.editImageInternal(n) }, this.upscaleImage = async o => { let n = { numberOfImages: 1, mode: "upscale" }; o.config && (n = Object.assign(Object.assign({}, n), o.config)); const i = { model: o.model, image: o.image, upscaleFactor: o.upscaleFactor, config: n }; return await this.upscaleImageInternal(i) }, this.generateVideos = async o => { var n, i, r, a, c, f; if ((o.prompt || o.image || o.video) && o.source) throw new Error("Source and prompt/image/video are mutually exclusive. Please only use source."); return this.apiClient.isVertexAI() || (!((n = o.video) === null || n === void 0) && n.uri && (!((i = o.video) === null || i === void 0) && i.videoBytes) ? o.video = { uri: o.video.uri, mimeType: o.video.mimeType } : !((a = (r = o.source) === null || r === void 0 ? void 0 : r.video) === null || a === void 0) && a.uri && (!((f = (c = o.source) === null || c === void 0 ? void 0 : c.video) === null || f === void 0) && f.videoBytes) && (o.source.video = { uri: o.source.video.uri, mimeType: o.source.video.mimeType })), await this.generateVideosInternal(o) } } maybeMoveToResponseJsonSchem(e) { e.config && e.config.responseSchema && (e.config.responseJsonSchema || Object.keys(e.config.responseSchema).includes("$schema") && (e.config.responseJsonSchema = e.config.responseSchema, delete e.config.responseSchema)) } async processParamsMaybeAddMcpUsage(e) { var o, n, i; const r = (o = e.config) === null || o === void 0 ? void 0 : o.tools; if (!r) return e; const a = await Promise.all(r.map(async f => Ci(f) ? await f.tool() : f)), c = { model: e.model, contents: e.contents, config: Object.assign(Object.assign({}, e.config), { tools: a }) }; if (c.config.tools = a, e.config && e.config.tools && au(e.config.tools)) { const f = (i = (n = e.config.httpOptions) === null || n === void 0 ? void 0 : n.headers) !== null && i !== void 0 ? i : {}; let u = Object.assign({}, f); Object.keys(u).length === 0 && (u = this.apiClient.getDefaultHeaders()), ru(u), c.config.httpOptions = Object.assign(Object.assign({}, e.config.httpOptions), { headers: u }) } return c } async initAfcToolsMap(e) { var o, n, i; const r = new Map; for (const a of (n = (o = e.config) === null || o === void 0 ? void 0 : o.tools) !== null && n !== void 0 ? n : []) if (Ci(a)) { const c = a, f = await c.tool(); for (const u of (i = f.functionDeclarations) !== null && i !== void 0 ? i : []) { if (!u.name) throw new Error("Function declaration name is required."); if (r.has(u.name)) throw new Error(`Duplicate tool declaration name: ${u.name}`); r.set(u.name, c) } } return r } async processAfcStream(e) { var o, n, i; const r = (i = (n = (o = e.config) === null || o === void 0 ? void 0 : o.automaticFunctionCalling) === null || n === void 0 ? void 0 : n.maximumRemoteCalls) !== null && i !== void 0 ? i : Rc; let a = !1, c = 0; const f = await this.initAfcToolsMap(e); return (function (u, p, v) { var T, k; return bi(this, arguments, function* () { for (var R, $, N, P; c < r;) { a && (c++, a = !1); const le = yield Ke(u.processParamsMaybeAddMcpUsage(v)), de = yield Ke(u.generateContentStreamInternal(le)), ue = [], Fe = []; try { for (var W = !0, K = ($ = void 0, Xi(de)), j; j = yield Ke(K.next()), R = j.done, !R; W = !0) { P = j.value, W = !1; const re = P; if (yield yield Ke(re), re.candidates && (!((T = re.candidates[0]) === null || T === void 0) && T.content)) { Fe.push(re.candidates[0].content); for (const ye of (k = re.candidates[0].content.parts) !== null && k !== void 0 ? k : []) if (c < r && ye.functionCall) { if (!ye.functionCall.name) throw new Error("Function call name was not returned by the model."); if (p.has(ye.functionCall.name)) { const xe = yield Ke(p.get(ye.functionCall.name).callTool([ye.functionCall])); ue.push(...xe) } else throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${p.keys()}, mising tool: ${ye.functionCall.name}`) } } } } catch (re) { $ = { error: re } } finally { try { !W && !R && (N = K.return) && (yield Ke(N.call(K))) } finally { if ($) throw $.error } } if (ue.length > 0) { a = !0; const re = new Ki; re.candidates = [{ content: { role: "user", parts: ue } }], yield yield Ke(re); const ye = []; ye.push(...Fe), ye.push({ role: "user", parts: ue }); const xe = zt(v.contents).concat(ye); v.contents = xe } else break } }) })(this, f, e) } async generateContentInternal(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = Lc(this.apiClient, e); return c = ie("{model}:generateContent", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => { const v = Ac(p), T = new Ki; return Object.assign(T, v), T }) } else { const u = Sc(this.apiClient, e); return c = ie("{model}:generateContent", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => { const v = _c(p), T = new Ki; return Object.assign(T, v), T }) } } async generateContentStreamInternal(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = Lc(this.apiClient, e); return c = ie("{model}:streamGenerateContent?alt=sse", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.requestStream({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }), a.then(function (v) { return bi(this, arguments, function* () { var T, k, R, $; try { for (var N = !0, P = Xi(v), W; W = yield Ke(P.next()), T = W.done, !T; N = !0) { $ = W.value, N = !1; const K = $, j = Ac(yield Ke(K.json())); j.sdkHttpResponse = { headers: K.headers }; const le = new Ki; Object.assign(le, j), yield yield Ke(le) } } catch (K) { k = { error: K } } finally { try { !N && !T && (R = P.return) && (yield Ke(R.call(P))) } finally { if (k) throw k.error } } }) }) } else { const u = Sc(this.apiClient, e); return c = ie("{model}:streamGenerateContent?alt=sse", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.requestStream({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }), a.then(function (v) { return bi(this, arguments, function* () { var T, k, R, $; try { for (var N = !0, P = Xi(v), W; W = yield Ke(P.next()), T = W.done, !T; N = !0) { $ = W.value, N = !1; const K = $, j = _c(yield Ke(K.json())); j.sdkHttpResponse = { headers: K.headers }; const le = new Ki; Object.assign(le, j), yield yield Ke(le) } } catch (K) { k = { error: K } } finally { try { !N && !T && (R = P.return) && (yield Ke(R.call(P))) } finally { if (k) throw k.error } } }) }) } } async embedContent(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = Lg(this.apiClient, e); return c = ie("{model}:predict", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => { const v = Ag(p), T = new dc; return Object.assign(T, v), T }) } else { const u = Sg(this.apiClient, e); return c = ie("{model}:batchEmbedContents", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => { const v = _g(p), T = new dc; return Object.assign(T, v), T }) } } async generateImagesInternal(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = Ug(this.apiClient, e); return c = ie("{model}:predict", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => { const v = qg(p), T = new cc; return Object.assign(T, v), T }) } else { const u = Fg(this.apiClient, e); return c = ie("{model}:predict", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => { const v = $g(p), T = new cc; return Object.assign(T, v), T }) } } async editImageInternal(e) { var o, n; let i, r = "", a = {}; if (this.apiClient.isVertexAI()) { const c = bg(this.apiClient, e); return r = ie("{model}:predict", c._url), a = c._query, delete c._url, delete c._query, i = this.apiClient.request({ path: r, queryParams: a, body: JSON.stringify(c), httpMethod: "POST", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(f => f.json().then(u => { const p = u; return p.sdkHttpResponse = { headers: f.headers }, p })), i.then(f => { const u = Cg(f), p = new Gf; return Object.assign(p, u), p }) } else throw new Error("This method is only supported by the Vertex AI.") } async upscaleImageInternal(e) { var o, n; let i, r = "", a = {}; if (this.apiClient.isVertexAI()) { const c = Ph(this.apiClient, e); return r = ie("{model}:predict", c._url), a = c._query, delete c._url, delete c._query, i = this.apiClient.request({ path: r, queryParams: a, body: JSON.stringify(c), httpMethod: "POST", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(f => f.json().then(u => { const p = u; return p.sdkHttpResponse = { headers: f.headers }, p })), i.then(f => { const u = Mh(f), p = new Of; return Object.assign(p, u), p }) } else throw new Error("This method is only supported by the Vertex AI.") } async recontextImage(e) { var o, n; let i, r = "", a = {}; if (this.apiClient.isVertexAI()) { const c = hh(this.apiClient, e); return r = ie("{model}:predict", c._url), a = c._query, delete c._url, delete c._query, i = this.apiClient.request({ path: r, queryParams: a, body: JSON.stringify(c), httpMethod: "POST", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(f => f.json()), i.then(f => { const u = yh(f), p = new Hf; return Object.assign(p, u), p }) } else throw new Error("This method is only supported by the Vertex AI.") } async segmentImage(e) { var o, n; let i, r = "", a = {}; if (this.apiClient.isVertexAI()) { const c = wh(this.apiClient, e); return r = ie("{model}:predict", c._url), a = c._query, delete c._url, delete c._query, i = this.apiClient.request({ path: r, queryParams: a, body: JSON.stringify(c), httpMethod: "POST", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(f => f.json()), i.then(f => { const u = Ih(f), p = new Bf; return Object.assign(p, u), p }) } else throw new Error("This method is only supported by the Vertex AI.") } async get(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = nh(this.apiClient, e); return c = ie("{name}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(p => p.json()), a.then(p => kr(p)) } else { const u = th(this.apiClient, e); return c = ie("{name}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }).then(p => p.json()), a.then(p => xr(p)) } } async listInternal(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = dh(this.apiClient, e); return c = ie("{models_url}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => { const v = uh(p), T = new uc; return Object.assign(T, v), T }) } else { const u = lh(this.apiClient, e); return c = ie("{models_url}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => { const v = ch(p), T = new uc; return Object.assign(T, v), T }) } } async update(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = Dh(this.apiClient, e); return c = ie("{model}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "PATCH", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(p => p.json()), a.then(p => kr(p)) } else { const u = Rh(this.apiClient, e); return c = ie("{name}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "PATCH", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }).then(p => p.json()), a.then(p => xr(p)) } } async delete(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = yg(this.apiClient, e); return c = ie("{name}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "DELETE", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => { const v = Tg(p), T = new fc; return Object.assign(T, v), T }) } else { const u = hg(this.apiClient, e); return c = ie("{name}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "DELETE", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => { const v = vg(p), T = new fc; return Object.assign(T, v), T }) } } async countTokens(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = pg(this.apiClient, e); return c = ie("{model}:countTokens", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => { const v = gg(p), T = new pc; return Object.assign(T, v), T }) } else { const u = fg(this.apiClient, e); return c = ie("{model}:countTokens", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => { const v = mg(p), T = new pc; return Object.assign(T, v), T }) } } async computeTokens(e) { var o, n; let i, r = "", a = {}; if (this.apiClient.isVertexAI()) { const c = sg(this.apiClient, e); return r = ie("{model}:computeTokens", c._url), a = c._query, delete c._url, delete c._query, i = this.apiClient.request({ path: r, queryParams: a, body: JSON.stringify(c), httpMethod: "POST", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(f => f.json().then(u => { const p = u; return p.sdkHttpResponse = { headers: f.headers }, p })), i.then(f => { const u = ag(f), p = new Jf; return Object.assign(p, u), p }) } else throw new Error("This method is only supported by the Vertex AI.") } async generateVideosInternal(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = Jg(this.apiClient, e); return c = ie("{model}:predictLongRunning", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(p => p.json()), a.then(p => { const v = Hg(p), T = new Ps; return Object.assign(T, v), T }) } else { const u = Bg(this.apiClient, e); return c = ie("{model}:predictLongRunning", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "POST", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }).then(p => p.json()), a.then(p => { const v = Og(p), T = new Ps; return Object.assign(T, v), T }) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class gy extends So { constructor(e) { super(), this.apiClient = e } async getVideosOperation(e) { const o = e.operation, n = e.config; if (o.name === void 0 || o.name === "") throw new Error("Operation name is required."); if (this.apiClient.isVertexAI()) { const i = o.name.split("/operations/")[0]; let r; n && "httpOptions" in n && (r = n.httpOptions); const a = await this.fetchPredictVideosOperationInternal({ operationName: o.name, resourceName: i, config: { httpOptions: r } }); return o._fromAPIResponse({ apiResponse: a, isVertexAI: !0 }) } else { const i = await this.getVideosOperationInternal({ operationName: o.name, config: n }); return o._fromAPIResponse({ apiResponse: i, isVertexAI: !1 }) } } async get(e) { const o = e.operation, n = e.config; if (o.name === void 0 || o.name === "") throw new Error("Operation name is required."); if (this.apiClient.isVertexAI()) { const i = o.name.split("/operations/")[0]; let r; n && "httpOptions" in n && (r = n.httpOptions); const a = await this.fetchPredictVideosOperationInternal({ operationName: o.name, resourceName: i, config: { httpOptions: r } }); return o._fromAPIResponse({ apiResponse: a, isVertexAI: !0 }) } else { const i = await this.getVideosOperationInternal({ operationName: o.name, config: n }); return o._fromAPIResponse({ apiResponse: i, isVertexAI: !1 }) } } async getVideosOperationInternal(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = $f(e); return c = ie("{operationName}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(p => p.json()), a } else { const u = Uf(e); return c = ie("{operationName}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }).then(p => p.json()), a } } async fetchPredictVideosOperationInternal(e) { var o, n; let i, r = "", a = {}; if (this.apiClient.isVertexAI()) { const c = kf(e); return r = ie("{resourceName}:fetchPredictOperation", c._url), a = c._query, delete c._url, delete c._query, i = this.apiClient.request({ path: r, queryParams: a, body: JSON.stringify(c), httpMethod: "POST", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(f => f.json()), i } else throw new Error("This method is only supported by the Vertex AI.") } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function hy(t) { const e = {}; if (s(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const o = s(t, ["data"]); o != null && l(e, ["data"], o); const n = s(t, ["mimeType"]); return n != null && l(e, ["mimeType"], n), e } function yy(t) { const e = {}, o = s(t, ["parts"]); if (o != null) { let i = o; Array.isArray(i) && (i = i.map(r => Sy(r))), l(e, ["parts"], i) } const n = s(t, ["role"]); return n != null && l(e, ["role"], n), e } function vy(t, e, o) { const n = {}, i = s(e, ["expireTime"]); o !== void 0 && i != null && l(o, ["expireTime"], i); const r = s(e, ["newSessionExpireTime"]); o !== void 0 && r != null && l(o, ["newSessionExpireTime"], r); const a = s(e, ["uses"]); o !== void 0 && a != null && l(o, ["uses"], a); const c = s(e, ["liveConnectConstraints"]); o !== void 0 && c != null && l(o, ["bidiGenerateContentSetup"], Iy(t, c)); const f = s(e, ["lockAdditionalFields"]); return o !== void 0 && f != null && l(o, ["fieldMask"], f), n } function Ty(t, e) { const o = {}, n = s(e, ["config"]); return n != null && l(o, ["config"], vy(t, n, o)), o } function Ey(t) { const e = {}; if (s(t, ["displayName"]) !== void 0) throw new Error("displayName parameter is not supported in Gemini API."); const o = s(t, ["fileUri"]); o != null && l(e, ["fileUri"], o); const n = s(t, ["mimeType"]); return n != null && l(e, ["mimeType"], n), e } function by(t) { const e = {}; if (s(t, ["authConfig"]) !== void 0) throw new Error("authConfig parameter is not supported in Gemini API."); const o = s(t, ["enableWidget"]); return o != null && l(e, ["enableWidget"], o), e } function Cy(t) { const e = {}, o = s(t, ["timeRangeFilter"]); if (o != null && l(e, ["timeRangeFilter"], o), s(t, ["excludeDomains"]) !== void 0) throw new Error("excludeDomains parameter is not supported in Gemini API."); return e } function wy(t, e) { const o = {}, n = s(t, ["generationConfig"]); e !== void 0 && n != null && l(e, ["setup", "generationConfig"], n); const i = s(t, ["responseModalities"]); e !== void 0 && i != null && l(e, ["setup", "generationConfig", "responseModalities"], i); const r = s(t, ["temperature"]); e !== void 0 && r != null && l(e, ["setup", "generationConfig", "temperature"], r); const a = s(t, ["topP"]); e !== void 0 && a != null && l(e, ["setup", "generationConfig", "topP"], a); const c = s(t, ["topK"]); e !== void 0 && c != null && l(e, ["setup", "generationConfig", "topK"], c); const f = s(t, ["maxOutputTokens"]); e !== void 0 && f != null && l(e, ["setup", "generationConfig", "maxOutputTokens"], f); const u = s(t, ["mediaResolution"]); e !== void 0 && u != null && l(e, ["setup", "generationConfig", "mediaResolution"], u); const p = s(t, ["seed"]); e !== void 0 && p != null && l(e, ["setup", "generationConfig", "seed"], p); const v = s(t, ["speechConfig"]); e !== void 0 && v != null && l(e, ["setup", "generationConfig", "speechConfig"], Ur(v)); const T = s(t, ["thinkingConfig"]); e !== void 0 && T != null && l(e, ["setup", "generationConfig", "thinkingConfig"], T); const k = s(t, ["enableAffectiveDialog"]); e !== void 0 && k != null && l(e, ["setup", "generationConfig", "enableAffectiveDialog"], k); const R = s(t, ["systemInstruction"]); e !== void 0 && R != null && l(e, ["setup", "systemInstruction"], yy(ht(R))); const $ = s(t, ["tools"]); if (e !== void 0 && $ != null) { let de = Ii($); Array.isArray(de) && (de = de.map(ue => _y(wi(ue)))), l(e, ["setup", "tools"], de) } const N = s(t, ["sessionResumption"]); e !== void 0 && N != null && l(e, ["setup", "sessionResumption"], Ly(N)); const P = s(t, ["inputAudioTranscription"]); e !== void 0 && P != null && l(e, ["setup", "inputAudioTranscription"], P); const W = s(t, ["outputAudioTranscription"]); e !== void 0 && W != null && l(e, ["setup", "outputAudioTranscription"], W); const K = s(t, ["realtimeInputConfig"]); e !== void 0 && K != null && l(e, ["setup", "realtimeInputConfig"], K); const j = s(t, ["contextWindowCompression"]); e !== void 0 && j != null && l(e, ["setup", "contextWindowCompression"], j); const le = s(t, ["proactivity"]); return e !== void 0 && le != null && l(e, ["setup", "proactivity"], le), o } function Iy(t, e) { const o = {}, n = s(e, ["model"]); n != null && l(o, ["setup", "model"], Ae(t, n)); const i = s(e, ["config"]); return i != null && l(o, ["config"], wy(i, o)), o } function Sy(t) { const e = {}, o = s(t, ["videoMetadata"]); o != null && l(e, ["videoMetadata"], o); const n = s(t, ["thought"]); n != null && l(e, ["thought"], n); const i = s(t, ["inlineData"]); i != null && l(e, ["inlineData"], hy(i)); const r = s(t, ["fileData"]); r != null && l(e, ["fileData"], Ey(r)); const a = s(t, ["thoughtSignature"]); a != null && l(e, ["thoughtSignature"], a); const c = s(t, ["functionCall"]); c != null && l(e, ["functionCall"], c); const f = s(t, ["codeExecutionResult"]); f != null && l(e, ["codeExecutionResult"], f); const u = s(t, ["executableCode"]); u != null && l(e, ["executableCode"], u); const p = s(t, ["functionResponse"]); p != null && l(e, ["functionResponse"], p); const v = s(t, ["text"]); return v != null && l(e, ["text"], v), e } function Ly(t) { const e = {}, o = s(t, ["handle"]); if (o != null && l(e, ["handle"], o), s(t, ["transparent"]) !== void 0) throw new Error("transparent parameter is not supported in Gemini API."); return e } function _y(t) { const e = {}, o = s(t, ["functionDeclarations"]); if (o != null) { let u = o; Array.isArray(u) && (u = u.map(p => p)), l(e, ["functionDeclarations"], u) } if (s(t, ["retrieval"]) !== void 0) throw new Error("retrieval parameter is not supported in Gemini API."); const n = s(t, ["googleSearch"]); n != null && l(e, ["googleSearch"], Cy(n)); const i = s(t, ["googleSearchRetrieval"]); if (i != null && l(e, ["googleSearchRetrieval"], i), s(t, ["enterpriseWebSearch"]) !== void 0) throw new Error("enterpriseWebSearch parameter is not supported in Gemini API."); const r = s(t, ["googleMaps"]); r != null && l(e, ["googleMaps"], by(r)); const a = s(t, ["urlContext"]); a != null && l(e, ["urlContext"], a); const c = s(t, ["computerUse"]); c != null && l(e, ["computerUse"], c); const f = s(t, ["codeExecution"]); return f != null && l(e, ["codeExecution"], f), e }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Ay(t) { const e = []; for (const o in t) if (Object.prototype.hasOwnProperty.call(t, o)) { const n = t[o]; if (typeof n == "object" && n != null && Object.keys(n).length > 0) { const i = Object.keys(n).map(r => `${o}.${r}`); e.push(...i) } else e.push(o) } return e.join(",") } function xy(t, e) { let o = null; const n = t.bidiGenerateContentSetup; if (typeof n == "object" && n !== null && "setup" in n) { const r = n.setup; typeof r == "object" && r !== null ? (t.bidiGenerateContentSetup = r, o = r) : delete t.bidiGenerateContentSetup } else n !== void 0 && delete t.bidiGenerateContentSetup; const i = t.fieldMask; if (o) { const r = Ay(o); if (Array.isArray(e == null ? void 0 : e.lockAdditionalFields) && (e == null ? void 0 : e.lockAdditionalFields.length) === 0) r ? t.fieldMask = r : delete t.fieldMask; else if (e != null && e.lockAdditionalFields && e.lockAdditionalFields.length > 0 && i !== null && Array.isArray(i) && i.length > 0) { const a = ["temperature", "topK", "topP", "maxOutputTokens", "responseModalities", "seed", "speechConfig"]; let c = []; i.length > 0 && (c = i.map(u => a.includes(u) ? `generationConfig.${u}` : u)); const f = []; r && f.push(r), c.length > 0 && f.push(...c), f.length > 0 ? t.fieldMask = f.join(",") : delete t.fieldMask } else delete t.fieldMask } else i !== null && Array.isArray(i) && i.length > 0 ? t.fieldMask = i.join(",") : delete t.fieldMask; return t } class ky extends So { constructor(e) { super(), this.apiClient = e } async create(e) { var o, n; let i, r = "", a = {}; if (this.apiClient.isVertexAI()) throw new Error("The client.tokens.create method is only supported by the Gemini Developer API."); { const c = Ty(this.apiClient, e); r = ie("auth_tokens", c._url), a = c._query, delete c.config, delete c._url, delete c._query; const f = xy(c, e.config); return i = this.apiClient.request({ path: r, queryParams: a, body: JSON.stringify(f), httpMethod: "POST", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(u => u.json()), i.then(u => u) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */function Ry(t, e) { const o = {}, n = s(t, ["name"]); return n != null && l(o, ["_url", "name"], n), o } function Dy(t, e) { const o = {}, n = s(t, ["name"]); return n != null && l(o, ["_url", "name"], n), o } function Ny(t, e, o) { const n = {}; if (s(t, ["validationDataset"]) !== void 0) throw new Error("validationDataset parameter is not supported in Gemini API."); const i = s(t, ["tunedModelDisplayName"]); if (e !== void 0 && i != null && l(e, ["displayName"], i), s(t, ["description"]) !== void 0) throw new Error("description parameter is not supported in Gemini API."); const r = s(t, ["epochCount"]); e !== void 0 && r != null && l(e, ["tuningTask", "hyperparameters", "epochCount"], r); const a = s(t, ["learningRateMultiplier"]); if (a != null && l(n, ["tuningTask", "hyperparameters", "learningRateMultiplier"], a), s(t, ["exportLastCheckpointOnly"]) !== void 0) throw new Error("exportLastCheckpointOnly parameter is not supported in Gemini API."); if (s(t, ["preTunedModelCheckpointId"]) !== void 0) throw new Error("preTunedModelCheckpointId parameter is not supported in Gemini API."); if (s(t, ["adapterSize"]) !== void 0) throw new Error("adapterSize parameter is not supported in Gemini API."); const c = s(t, ["batchSize"]); e !== void 0 && c != null && l(e, ["tuningTask", "hyperparameters", "batchSize"], c); const f = s(t, ["learningRate"]); if (e !== void 0 && f != null && l(e, ["tuningTask", "hyperparameters", "learningRate"], f), s(t, ["labels"]) !== void 0) throw new Error("labels parameter is not supported in Gemini API."); return n } function Py(t, e, o) { const n = {}, i = s(t, ["validationDataset"]); e !== void 0 && i != null && l(e, ["supervisedTuningSpec"], Ky(i)); const r = s(t, ["tunedModelDisplayName"]); e !== void 0 && r != null && l(e, ["tunedModelDisplayName"], r); const a = s(t, ["description"]); e !== void 0 && a != null && l(e, ["description"], a); const c = s(t, ["epochCount"]); e !== void 0 && c != null && l(e, ["supervisedTuningSpec", "hyperParameters", "epochCount"], c); const f = s(t, ["learningRateMultiplier"]); e !== void 0 && f != null && l(e, ["supervisedTuningSpec", "hyperParameters", "learningRateMultiplier"], f); const u = s(t, ["exportLastCheckpointOnly"]); e !== void 0 && u != null && l(e, ["supervisedTuningSpec", "exportLastCheckpointOnly"], u); const p = s(t, ["adapterSize"]); if (e !== void 0 && p != null && l(e, ["supervisedTuningSpec", "hyperParameters", "adapterSize"], p), s(t, ["batchSize"]) !== void 0) throw new Error("batchSize parameter is not supported in Vertex AI."); if (s(t, ["learningRate"]) !== void 0) throw new Error("learningRate parameter is not supported in Vertex AI."); const v = s(t, ["labels"]); return e !== void 0 && v != null && l(e, ["labels"], v), n } function My(t, e) { const o = {}, n = s(t, ["baseModel"]); n != null && l(o, ["baseModel"], n); const i = s(t, ["preTunedModel"]); i != null && l(o, ["preTunedModel"], i); const r = s(t, ["trainingDataset"]); r != null && l(o, ["tuningTask", "trainingData"], Wy(r)); const a = s(t, ["config"]); return a != null && Ny(a, o), o } function Fy(t, e) { const o = {}, n = s(t, ["baseModel"]); n != null && l(o, ["baseModel"], n); const i = s(t, ["preTunedModel"]); i != null && l(o, ["preTunedModel"], i); const r = s(t, ["trainingDataset"]); r != null && zy(r, o); const a = s(t, ["config"]); return a != null && Py(a, o), o } function Uy(t, e) { const o = {}, n = s(t, ["name"]); return n != null && l(o, ["_url", "name"], n), o } function $y(t, e) { const o = {}, n = s(t, ["name"]); return n != null && l(o, ["_url", "name"], n), o } function qy(t, e, o) { const n = {}, i = s(t, ["pageSize"]); e !== void 0 && i != null && l(e, ["_query", "pageSize"], i); const r = s(t, ["pageToken"]); e !== void 0 && r != null && l(e, ["_query", "pageToken"], r); const a = s(t, ["filter"]); return e !== void 0 && a != null && l(e, ["_query", "filter"], a), n } function Vy(t, e, o) { const n = {}, i = s(t, ["pageSize"]); e !== void 0 && i != null && l(e, ["_query", "pageSize"], i); const r = s(t, ["pageToken"]); e !== void 0 && r != null && l(e, ["_query", "pageToken"], r); const a = s(t, ["filter"]); return e !== void 0 && a != null && l(e, ["_query", "filter"], a), n } function Gy(t, e) { const o = {}, n = s(t, ["config"]); return n != null && qy(n, o), o } function Oy(t, e) { const o = {}, n = s(t, ["config"]); return n != null && Vy(n, o), o } function Hy(t, e) { const o = {}, n = s(t, ["sdkHttpResponse"]); n != null && l(o, ["sdkHttpResponse"], n); const i = s(t, ["nextPageToken"]); i != null && l(o, ["nextPageToken"], i); const r = s(t, ["tunedModels"]); if (r != null) { let a = r; Array.isArray(a) && (a = a.map(c => lu(c))), l(o, ["tuningJobs"], a) } return o } function By(t, e) { const o = {}, n = s(t, ["sdkHttpResponse"]); n != null && l(o, ["sdkHttpResponse"], n); const i = s(t, ["nextPageToken"]); i != null && l(o, ["nextPageToken"], i); const r = s(t, ["tuningJobs"]); if (r != null) { let a = r; Array.isArray(a) && (a = a.map(c => Dr(c))), l(o, ["tuningJobs"], a) } return o } function Jy(t, e) { const o = {}, n = s(t, ["name"]); n != null && l(o, ["model"], n); const i = s(t, ["name"]); return i != null && l(o, ["endpoint"], i), o } function Wy(t, e) { const o = {}; if (s(t, ["gcsUri"]) !== void 0) throw new Error("gcsUri parameter is not supported in Gemini API."); if (s(t, ["vertexDatasetResource"]) !== void 0) throw new Error("vertexDatasetResource parameter is not supported in Gemini API."); const n = s(t, ["examples"]); if (n != null) { let i = n; Array.isArray(i) && (i = i.map(r => r)), l(o, ["examples", "examples"], i) } return o } function zy(t, e, o) { const n = {}, i = s(t, ["gcsUri"]); e !== void 0 && i != null && l(e, ["supervisedTuningSpec", "trainingDatasetUri"], i); const r = s(t, ["vertexDatasetResource"]); if (e !== void 0 && r != null && l(e, ["supervisedTuningSpec", "trainingDatasetUri"], r), s(t, ["examples"]) !== void 0) throw new Error("examples parameter is not supported in Vertex AI."); return n } function lu(t, e) { const o = {}, n = s(t, ["sdkHttpResponse"]); n != null && l(o, ["sdkHttpResponse"], n); const i = s(t, ["name"]); i != null && l(o, ["name"], i); const r = s(t, ["state"]); r != null && l(o, ["state"], Hc(r)); const a = s(t, ["createTime"]); a != null && l(o, ["createTime"], a); const c = s(t, ["tuningTask", "startTime"]); c != null && l(o, ["startTime"], c); const f = s(t, ["tuningTask", "completeTime"]); f != null && l(o, ["endTime"], f); const u = s(t, ["updateTime"]); u != null && l(o, ["updateTime"], u); const p = s(t, ["description"]); p != null && l(o, ["description"], p); const v = s(t, ["baseModel"]); v != null && l(o, ["baseModel"], v); const T = s(t, ["_self"]); return T != null && l(o, ["tunedModel"], Jy(T)), o } function Dr(t, e) { const o = {}, n = s(t, ["sdkHttpResponse"]); n != null && l(o, ["sdkHttpResponse"], n); const i = s(t, ["name"]); i != null && l(o, ["name"], i); const r = s(t, ["state"]); r != null && l(o, ["state"], Hc(r)); const a = s(t, ["createTime"]); a != null && l(o, ["createTime"], a); const c = s(t, ["startTime"]); c != null && l(o, ["startTime"], c); const f = s(t, ["endTime"]); f != null && l(o, ["endTime"], f); const u = s(t, ["updateTime"]); u != null && l(o, ["updateTime"], u); const p = s(t, ["error"]); p != null && l(o, ["error"], p); const v = s(t, ["description"]); v != null && l(o, ["description"], v); const T = s(t, ["baseModel"]); T != null && l(o, ["baseModel"], T); const k = s(t, ["tunedModel"]); k != null && l(o, ["tunedModel"], k); const R = s(t, ["preTunedModel"]); R != null && l(o, ["preTunedModel"], R); const $ = s(t, ["supervisedTuningSpec"]); $ != null && l(o, ["supervisedTuningSpec"], $); const N = s(t, ["tuningDataStats"]); N != null && l(o, ["tuningDataStats"], N); const P = s(t, ["encryptionSpec"]); P != null && l(o, ["encryptionSpec"], P); const W = s(t, ["partnerModelTuningSpec"]); W != null && l(o, ["partnerModelTuningSpec"], W); const K = s(t, ["customBaseModel"]); K != null && l(o, ["customBaseModel"], K); const j = s(t, ["experiment"]); j != null && l(o, ["experiment"], j); const le = s(t, ["labels"]); le != null && l(o, ["labels"], le); const de = s(t, ["outputUri"]); de != null && l(o, ["outputUri"], de); const ue = s(t, ["pipelineJob"]); ue != null && l(o, ["pipelineJob"], ue); const Fe = s(t, ["serviceAccount"]); Fe != null && l(o, ["serviceAccount"], Fe); const re = s(t, ["tunedModelDisplayName"]); re != null && l(o, ["tunedModelDisplayName"], re); const ye = s(t, ["veoTuningSpec"]); return ye != null && l(o, ["veoTuningSpec"], ye), o } function Yy(t, e) { const o = {}, n = s(t, ["sdkHttpResponse"]); n != null && l(o, ["sdkHttpResponse"], n); const i = s(t, ["name"]); i != null && l(o, ["name"], i); const r = s(t, ["metadata"]); r != null && l(o, ["metadata"], r); const a = s(t, ["done"]); a != null && l(o, ["done"], a); const c = s(t, ["error"]); return c != null && l(o, ["error"], c), o } function Ky(t, e) { const o = {}, n = s(t, ["gcsUri"]); n != null && l(o, ["validationDatasetUri"], n); const i = s(t, ["vertexDatasetResource"]); return i != null && l(o, ["validationDatasetUri"], i), o }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Xy extends So { constructor(e) { super(), this.apiClient = e, this.get = async o => await this.getInternal(o), this.list = async (o = {}) => new Zi(Io.PAGED_ITEM_TUNING_JOBS, n => this.listInternal(n), await this.listInternal(o), o), this.tune = async o => { var n; if (this.apiClient.isVertexAI()) if (o.baseModel.startsWith("projects/")) { const i = { tunedModelName: o.baseModel }; !((n = o.config) === null || n === void 0) && n.preTunedModelCheckpointId && (i.checkpointId = o.config.preTunedModelCheckpointId); const r = Object.assign(Object.assign({}, o), { preTunedModel: i }); return r.baseModel = void 0, await this.tuneInternal(r) } else { const i = Object.assign({}, o); return await this.tuneInternal(i) } else { const i = Object.assign({}, o), r = await this.tuneMldevInternal(i); let a = ""; return r.metadata !== void 0 && r.metadata.tunedModel !== void 0 ? a = r.metadata.tunedModel : r.name !== void 0 && r.name.includes("/operations/") && (a = r.name.split("/operations/")[0]), { name: a, state: Sr.JOB_STATE_QUEUED } } } } async getInternal(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = $y(e); return c = ie("{name}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => Dr(p)) } else { const u = Uy(e); return c = ie("{name}", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => lu(p)) } } async listInternal(e) { var o, n, i, r; let a, c = "", f = {}; if (this.apiClient.isVertexAI()) { const u = Oy(e); return c = ie("tuningJobs", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => { const v = By(p), T = new mc; return Object.assign(T, v), T }) } else { const u = Gy(e); return c = ie("tunedModels", u._url), f = u._query, delete u._url, delete u._query, a = this.apiClient.request({ path: c, queryParams: f, body: JSON.stringify(u), httpMethod: "GET", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }).then(p => p.json().then(v => { const T = v; return T.sdkHttpResponse = { headers: p.headers }, T })), a.then(p => { const v = Hy(p), T = new mc; return Object.assign(T, v), T }) } } async cancel(e) { var o, n, i, r; let a = "", c = {}; if (this.apiClient.isVertexAI()) { const f = Dy(e); a = ie("{name}:cancel", f._url), c = f._query, delete f._url, delete f._query, await this.apiClient.request({ path: a, queryParams: c, body: JSON.stringify(f), httpMethod: "POST", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }) } else { const f = Ry(e); a = ie("{name}:cancel", f._url), c = f._query, delete f._url, delete f._query, await this.apiClient.request({ path: a, queryParams: c, body: JSON.stringify(f), httpMethod: "POST", httpOptions: (i = e.config) === null || i === void 0 ? void 0 : i.httpOptions, abortSignal: (r = e.config) === null || r === void 0 ? void 0 : r.abortSignal }) } } async tuneInternal(e) { var o, n; let i, r = "", a = {}; if (this.apiClient.isVertexAI()) { const c = Fy(e); return r = ie("tuningJobs", c._url), a = c._query, delete c._url, delete c._query, i = this.apiClient.request({ path: r, queryParams: a, body: JSON.stringify(c), httpMethod: "POST", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(f => f.json().then(u => { const p = u; return p.sdkHttpResponse = { headers: f.headers }, p })), i.then(f => Dr(f)) } else throw new Error("This method is only supported by the Vertex AI.") } async tuneMldevInternal(e) { var o, n; let i, r = "", a = {}; if (this.apiClient.isVertexAI()) throw new Error("This method is only supported by the Gemini Developer API."); { const c = My(e); return r = ie("tunedModels", c._url), a = c._query, delete c._url, delete c._query, i = this.apiClient.request({ path: r, queryParams: a, body: JSON.stringify(c), httpMethod: "POST", httpOptions: (o = e.config) === null || o === void 0 ? void 0 : o.httpOptions, abortSignal: (n = e.config) === null || n === void 0 ? void 0 : n.abortSignal }).then(f => f.json().then(u => { const p = u; return p.sdkHttpResponse = { headers: f.headers }, p })), i.then(f => Yy(f)) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class Zy { async download(e, o) { throw new Error("Download to file is not supported in the browser, please use a browser compliant download like an <a> tag.") } } const Qy = 1024 * 1024 * 8, jy = 3, ev = 1e3, tv = 2, br = "x-goog-upload-status"; async function nv(t, e, o) { var n, i, r; let a = 0, c = 0, f = new Lr(new Response), u = "upload"; for (a = t.size; c < a;) { const v = Math.min(Qy, a - c), T = t.slice(c, c + v); c + v >= a && (u += ", finalize"); let k = 0, R = ev; for (; k < jy && (f = await o.request({ path: "", body: T, httpMethod: "POST", httpOptions: { apiVersion: "", baseUrl: e, headers: { "X-Goog-Upload-Command": u, "X-Goog-Upload-Offset": String(c), "Content-Length": String(v) } } }), !(!((n = f == null ? void 0 : f.headers) === null || n === void 0) && n[br]));)k++, await iv(R), R = R * tv; if (c += v, ((i = f == null ? void 0 : f.headers) === null || i === void 0 ? void 0 : i[br]) !== "active") break; if (a <= c) throw new Error("All content has been uploaded, but the upload status is not finalized.") } const p = await (f == null ? void 0 : f.json()); if (((r = f == null ? void 0 : f.headers) === null || r === void 0 ? void 0 : r[br]) !== "final") throw new Error("Failed to upload file: Upload status is not finalized."); return p.file } async function ov(t) { return { size: t.size, type: t.type } } function iv(t) { return new Promise(e => setTimeout(e, t)) } class sv { async upload(e, o, n) { if (typeof e == "string") throw new Error("File path is not supported in browser uploader."); return await nv(e, o, n) } async stat(e) { if (typeof e == "string") throw new Error("File path is not supported in browser uploader."); return await ov(e) } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */class av { create(e, o, n) { return new rv(e, o, n) } } class rv { constructor(e, o, n) { this.url = e, this.headers = o, this.callbacks = n } connect() { this.ws = new WebSocket(this.url), this.ws.onopen = this.callbacks.onopen, this.ws.onerror = this.callbacks.onerror, this.ws.onclose = this.callbacks.onclose, this.ws.onmessage = this.callbacks.onmessage } send(e) { if (this.ws === void 0) throw new Error("WebSocket is not connected"); this.ws.send(e) } close() { if (this.ws === void 0) throw new Error("WebSocket is not connected"); this.ws.close() } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const Pc = "x-goog-api-key"; class lv { constructor(e) { this.apiKey = e } async addAuthHeaders(e, o) { if (e.get(Pc) === null) { if (this.apiKey.startsWith("auth_tokens/")) throw new Error("Ephemeral tokens are only supported by the live API."); if (!this.apiKey) throw new Error("API key is missing. Please provide a valid API key."); e.append(Pc, this.apiKey) } } }/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */const dv = "gl-node/"; class Mc { constructor(e) { var o; if (e.apiKey == null) throw new Error("An API Key must be set when running in a browser"); if (e.project || e.location) throw new Error("Vertex AI project based authentication is not supported on browser runtimes. Please do not provide a project or location."); this.vertexai = (o = e.vertexai) !== null && o !== void 0 ? o : !1, this.apiKey = e.apiKey; const n = Af(e.httpOptions, e.vertexai, void 0, void 0); n && (e.httpOptions ? e.httpOptions.baseUrl = n : e.httpOptions = { baseUrl: n }), this.apiVersion = e.apiVersion; const i = new lv(this.apiKey); this.apiClient = new Yh({ auth: i, apiVersion: this.apiVersion, apiKey: this.apiKey, vertexai: this.vertexai, httpOptions: e.httpOptions, userAgentExtra: dv + "web", uploader: new sv, downloader: new Zy }), this.models = new my(this.apiClient), this.live = new ry(this.apiClient, i, new av), this.batches = new zp(this.apiClient), this.chats = new Sm(this.models, this.apiClient), this.caches = new Cm(this.apiClient), this.files = new Mm(this.apiClient), this.operations = new gy(this.apiClient), this.authTokens = new ky(this.apiClient), this.tunings = new Xy(this.apiClient) } } function cv(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } var Cr = { exports: {} }, Fc; function uv() { return Fc || (Fc = 1, (function (t) { (function () { function e() { var o = this; this.versionnumber = "1.2.6", this.imageToSVG = function (n, i, r) { r = o.checkoptions(r), o.loadImage(n, function (a) { i(o.imagedataToSVG(o.getImgdata(a), r)) }, r) }, this.imagedataToSVG = function (n, i) { i = o.checkoptions(i); var r = o.imagedataToTracedata(n, i); return o.getsvgstring(r, i) }, this.imageToTracedata = function (n, i, r) { r = o.checkoptions(r), o.loadImage(n, function (a) { i(o.imagedataToTracedata(o.getImgdata(a), r)) }, r) }, this.imagedataToTracedata = function (n, i) { i = o.checkoptions(i); var r = o.colorquantization(n, i); if (i.layering === 0) for (var a = { layers: [], palette: r.palette, width: r.array[0].length - 2, height: r.array.length - 2 }, c = 0; c < r.palette.length; c++) { var f = o.batchtracepaths(o.internodes(o.pathscan(o.layeringstep(r, c), i.pathomit), i), i.ltres, i.qtres); a.layers.push(f) } else { var u = o.layering(r); i.layercontainerid && o.drawLayers(u, o.specpalette, i.scale, i.layercontainerid); var p = o.batchpathscan(u, i.pathomit), v = o.batchinternodes(p, i), a = { layers: o.batchtracelayers(v, i.ltres, i.qtres), palette: r.palette, width: n.width, height: n.height } } return a }, this.optionpresets = { default: { corsenabled: !1, ltres: 1, qtres: 1, pathomit: 8, rightangleenhance: !0, colorsampling: 2, numberofcolors: 16, mincolorratio: 0, colorquantcycles: 3, layering: 0, strokewidth: 1, linefilter: !1, scale: 1, roundcoords: 1, viewbox: !1, desc: !1, lcpr: 0, qcpr: 0, blurradius: 0, blurdelta: 20 }, posterized1: { colorsampling: 0, numberofcolors: 2 }, posterized2: { numberofcolors: 4, blurradius: 5 }, curvy: { ltres: .01, linefilter: !0, rightangleenhance: !1 }, sharp: { qtres: .01, linefilter: !1 }, detailed: { pathomit: 0, roundcoords: 2, ltres: .5, qtres: .5, numberofcolors: 64 }, smoothed: { blurradius: 5, blurdelta: 64 }, grayscale: { colorsampling: 0, colorquantcycles: 1, numberofcolors: 7 }, fixedpalette: { colorsampling: 0, colorquantcycles: 1, numberofcolors: 27 }, randomsampling1: { colorsampling: 1, numberofcolors: 8 }, randomsampling2: { colorsampling: 1, numberofcolors: 64 }, artistic1: { colorsampling: 0, colorquantcycles: 1, pathomit: 0, blurradius: 5, blurdelta: 64, ltres: .01, linefilter: !0, numberofcolors: 16, strokewidth: 2 }, artistic2: { qtres: .01, colorsampling: 0, colorquantcycles: 1, numberofcolors: 4, strokewidth: 0 }, artistic3: { qtres: 10, ltres: 10, numberofcolors: 8 }, artistic4: { qtres: 10, ltres: 10, numberofcolors: 64, blurradius: 5, blurdelta: 256, strokewidth: 2 }, posterized3: { ltres: 1, qtres: 1, pathomit: 20, rightangleenhance: !0, colorsampling: 0, numberofcolors: 3, mincolorratio: 0, colorquantcycles: 3, blurradius: 3, blurdelta: 20, strokewidth: 0, linefilter: !1, roundcoords: 1, pal: [{ r: 0, g: 0, b: 100, a: 255 }, { r: 255, g: 255, b: 255, a: 255 }] } }, this.checkoptions = function (n) { n = n || {}, typeof n == "string" && (n = n.toLowerCase(), o.optionpresets[n] ? n = o.optionpresets[n] : n = {}); for (var i = Object.keys(o.optionpresets.default), r = 0; r < i.length; r++)n.hasOwnProperty(i[r]) || (n[i[r]] = o.optionpresets.default[i[r]]); return n }, this.colorquantization = function (n, i) { var r = [], a = 0, c, f, u, p = [], v = n.width * n.height, T, k, R, $, N; if (n.data.length < v * 4) { for (var P = new Uint8ClampedArray(v * 4), W = 0; W < v; W++)P[W * 4] = n.data[W * 3], P[W * 4 + 1] = n.data[W * 3 + 1], P[W * 4 + 2] = n.data[W * 3 + 2], P[W * 4 + 3] = 255; n.data = P } for (k = 0; k < n.height + 2; k++)for (r[k] = [], T = 0; T < n.width + 2; T++)r[k][T] = -1; for (i.pal ? N = i.pal : i.colorsampling === 0 ? N = o.generatepalette(i.numberofcolors) : i.colorsampling === 1 ? N = o.samplepalette(i.numberofcolors, n) : N = o.samplepalette2(i.numberofcolors, n), i.blurradius > 0 && (n = o.blur(n, i.blurradius, i.blurdelta)), $ = 0; $ < i.colorquantcycles; $++) { if ($ > 0) for (R = 0; R < N.length; R++)p[R].n > 0 && (N[R] = { r: Math.floor(p[R].r / p[R].n), g: Math.floor(p[R].g / p[R].n), b: Math.floor(p[R].b / p[R].n), a: Math.floor(p[R].a / p[R].n) }), p[R].n / v < i.mincolorratio && $ < i.colorquantcycles - 1 && (N[R] = { r: Math.floor(Math.random() * 255), g: Math.floor(Math.random() * 255), b: Math.floor(Math.random() * 255), a: Math.floor(Math.random() * 255) }); for (T = 0; T < N.length; T++)p[T] = { r: 0, g: 0, b: 0, a: 0, n: 0 }; for (k = 0; k < n.height; k++)for (T = 0; T < n.width; T++) { for (a = (k * n.width + T) * 4, u = 0, f = 1024, R = 0; R < N.length; R++)c = Math.abs(N[R].r - n.data[a]) + Math.abs(N[R].g - n.data[a + 1]) + Math.abs(N[R].b - n.data[a + 2]) + Math.abs(N[R].a - n.data[a + 3]), c < f && (f = c, u = R); p[u].r += n.data[a], p[u].g += n.data[a + 1], p[u].b += n.data[a + 2], p[u].a += n.data[a + 3], p[u].n++, r[k + 1][T + 1] = u } } return { array: r, palette: N } }, this.samplepalette = function (n, i) { for (var r, a = [], c = 0; c < n; c++)r = Math.floor(Math.random() * i.data.length / 4) * 4, a.push({ r: i.data[r], g: i.data[r + 1], b: i.data[r + 2], a: i.data[r + 3] }); return a }, this.samplepalette2 = function (n, i) { for (var r, a = [], c = Math.ceil(Math.sqrt(n)), f = Math.ceil(n / c), u = i.width / (c + 1), p = i.height / (f + 1), v = 0; v < f; v++)for (var T = 0; T < c && a.length !== n; T++)r = Math.floor((v + 1) * p * i.width + (T + 1) * u) * 4, a.push({ r: i.data[r], g: i.data[r + 1], b: i.data[r + 2], a: i.data[r + 3] }); return a }, this.generatepalette = function (n) { var i = [], r, a, c; if (n < 8) for (var f = Math.floor(255 / (n - 1)), u = 0; u < n; u++)i.push({ r: u * f, g: u * f, b: u * f, a: 255 }); else { var p = Math.floor(Math.pow(n, .3333333333333333)), v = Math.floor(255 / (p - 1)), T = n - p * p * p; for (r = 0; r < p; r++)for (a = 0; a < p; a++)for (c = 0; c < p; c++)i.push({ r: r * v, g: a * v, b: c * v, a: 255 }); for (r = 0; r < T; r++)i.push({ r: Math.floor(Math.random() * 255), g: Math.floor(Math.random() * 255), b: Math.floor(Math.random() * 255), a: Math.floor(Math.random() * 255) }) } return i }, this.layering = function (n) { var i = [], r = 0, a = n.array.length, c = n.array[0].length, f, u, p, v, T, k, R, $, N, P, W; for (W = 0; W < n.palette.length; W++)for (i[W] = [], P = 0; P < a; P++)for (i[W][P] = [], N = 0; N < c; N++)i[W][P][N] = 0; for (P = 1; P < a - 1; P++)for (N = 1; N < c - 1; N++)r = n.array[P][N], f = n.array[P - 1][N - 1] === r ? 1 : 0, u = n.array[P - 1][N] === r ? 1 : 0, p = n.array[P - 1][N + 1] === r ? 1 : 0, v = n.array[P][N - 1] === r ? 1 : 0, T = n.array[P][N + 1] === r ? 1 : 0, k = n.array[P + 1][N - 1] === r ? 1 : 0, R = n.array[P + 1][N] === r ? 1 : 0, $ = n.array[P + 1][N + 1] === r ? 1 : 0, i[r][P + 1][N + 1] = 1 + T * 2 + $ * 4 + R * 8, v || (i[r][P + 1][N] = 2 + R * 4 + k * 8), u || (i[r][P][N + 1] = 0 + p * 2 + T * 4 + 8), f || (i[r][P][N] = 0 + u * 2 + 4 + v * 8); return i }, this.layeringstep = function (n, i) { var r = [], a = n.array.length, c = n.array[0].length, f, u; for (u = 0; u < a; u++)for (r[u] = [], f = 0; f < c; f++)r[u][f] = 0; for (u = 1; u < a; u++)for (f = 1; f < c; f++)r[u][f] = (n.array[u - 1][f - 1] === i ? 1 : 0) + (n.array[u - 1][f] === i ? 2 : 0) + (n.array[u][f - 1] === i ? 8 : 0) + (n.array[u][f] === i ? 4 : 0); return r }, this.pointinpoly = function (n, i) { for (var r = !1, a = 0, c = i.length - 1; a < i.length; c = a++)r = i[a].y > n.y != i[c].y > n.y && n.x < (i[c].x - i[a].x) * (n.y - i[a].y) / (i[c].y - i[a].y) + i[a].x ? !r : r; return r }, this.pathscan_combined_lookup = [[[-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1]], [[0, 1, 0, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [0, 2, -1, 0]], [[-1, -1, -1, -1], [-1, -1, -1, -1], [0, 1, 0, -1], [0, 0, 1, 0]], [[0, 0, 1, 0], [-1, -1, -1, -1], [0, 2, -1, 0], [-1, -1, -1, -1]], [[-1, -1, -1, -1], [0, 0, 1, 0], [0, 3, 0, 1], [-1, -1, -1, -1]], [[13, 3, 0, 1], [13, 2, -1, 0], [7, 1, 0, -1], [7, 0, 1, 0]], [[-1, -1, -1, -1], [0, 1, 0, -1], [-1, -1, -1, -1], [0, 3, 0, 1]], [[0, 3, 0, 1], [0, 2, -1, 0], [-1, -1, -1, -1], [-1, -1, -1, -1]], [[0, 3, 0, 1], [0, 2, -1, 0], [-1, -1, -1, -1], [-1, -1, -1, -1]], [[-1, -1, -1, -1], [0, 1, 0, -1], [-1, -1, -1, -1], [0, 3, 0, 1]], [[11, 1, 0, -1], [14, 0, 1, 0], [14, 3, 0, 1], [11, 2, -1, 0]], [[-1, -1, -1, -1], [0, 0, 1, 0], [0, 3, 0, 1], [-1, -1, -1, -1]], [[0, 0, 1, 0], [-1, -1, -1, -1], [0, 2, -1, 0], [-1, -1, -1, -1]], [[-1, -1, -1, -1], [-1, -1, -1, -1], [0, 1, 0, -1], [0, 0, 1, 0]], [[0, 1, 0, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [0, 2, -1, 0]], [[-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1]]], this.pathscan = function (n, i) { for (var r = [], a = 0, c = 0, f = 0, u = 0, p = n[0].length, v = n.length, T = 0, k = !0, R = !1, $, N = 0; N < v; N++)for (var P = 0; P < p; P++)if (n[N][P] == 4 || n[N][P] == 11) for (f = P, u = N, r[a] = {}, r[a].points = [], r[a].boundingbox = [f, u, f, u], r[a].holechildren = [], k = !1, c = 0, R = n[N][P] == 11, T = 1; !k;) { if (r[a].points[c] = {}, r[a].points[c].x = f - 1, r[a].points[c].y = u - 1, r[a].points[c].t = n[u][f], f - 1 < r[a].boundingbox[0] && (r[a].boundingbox[0] = f - 1), f - 1 > r[a].boundingbox[2] && (r[a].boundingbox[2] = f - 1), u - 1 < r[a].boundingbox[1] && (r[a].boundingbox[1] = u - 1), u - 1 > r[a].boundingbox[3] && (r[a].boundingbox[3] = u - 1), $ = o.pathscan_combined_lookup[n[u][f]][T], n[u][f] = $[0], T = $[1], f += $[2], u += $[3], f - 1 === r[a].points[0].x && u - 1 === r[a].points[0].y) if (k = !0, r[a].points.length < i) r.pop(); else { if (r[a].isholepath = !!R, R) { for (var W = 0, K = [-1, -1, p + 1, v + 1], j = 0; j < a; j++)!r[j].isholepath && o.boundingboxincludes(r[j].boundingbox, r[a].boundingbox) && o.boundingboxincludes(K, r[j].boundingbox) && o.pointinpoly(r[a].points[0], r[j].points) && (W = j, K = r[j].boundingbox); r[W].holechildren.push(a) } a++ } c++ } return r }, this.boundingboxincludes = function (n, i) { return n[0] < i[0] && n[1] < i[1] && n[2] > i[2] && n[3] > i[3] }, this.batchpathscan = function (n, i) { var r = []; for (var a in n) n.hasOwnProperty(a) && (r[a] = o.pathscan(n[a], i)); return r }, this.internodes = function (n, i) { var r = [], a = 0, c = 0, f = 0, u = 0, p = 0, v, T; for (v = 0; v < n.length; v++)for (r[v] = {}, r[v].points = [], r[v].boundingbox = n[v].boundingbox, r[v].holechildren = n[v].holechildren, r[v].isholepath = n[v].isholepath, a = n[v].points.length, T = 0; T < a; T++)c = (T + 1) % a, f = (T + 2) % a, u = (T - 1 + a) % a, p = (T - 2 + a) % a, i.rightangleenhance && o.testrightangle(n[v], p, u, T, c, f) && (r[v].points.length > 0 && (r[v].points[r[v].points.length - 1].linesegment = o.getdirection(r[v].points[r[v].points.length - 1].x, r[v].points[r[v].points.length - 1].y, n[v].points[T].x, n[v].points[T].y)), r[v].points.push({ x: n[v].points[T].x, y: n[v].points[T].y, linesegment: o.getdirection(n[v].points[T].x, n[v].points[T].y, (n[v].points[T].x + n[v].points[c].x) / 2, (n[v].points[T].y + n[v].points[c].y) / 2) })), r[v].points.push({ x: (n[v].points[T].x + n[v].points[c].x) / 2, y: (n[v].points[T].y + n[v].points[c].y) / 2, linesegment: o.getdirection((n[v].points[T].x + n[v].points[c].x) / 2, (n[v].points[T].y + n[v].points[c].y) / 2, (n[v].points[c].x + n[v].points[f].x) / 2, (n[v].points[c].y + n[v].points[f].y) / 2) }); return r }, this.testrightangle = function (n, i, r, a, c, f) { return n.points[a].x === n.points[i].x && n.points[a].x === n.points[r].x && n.points[a].y === n.points[c].y && n.points[a].y === n.points[f].y || n.points[a].y === n.points[i].y && n.points[a].y === n.points[r].y && n.points[a].x === n.points[c].x && n.points[a].x === n.points[f].x }, this.getdirection = function (n, i, r, a) { var c = 8; return n < r ? i < a ? c = 1 : i > a ? c = 7 : c = 0 : n > r ? i < a ? c = 3 : i > a ? c = 5 : c = 4 : i < a ? c = 2 : i > a ? c = 6 : c = 8, c }, this.batchinternodes = function (n, i) { var r = []; for (var a in n) n.hasOwnProperty(a) && (r[a] = o.internodes(n[a], i)); return r }, this.tracepath = function (n, i, r) { var a = 0, c, f, u, p = {}; for (p.segments = [], p.boundingbox = n.boundingbox, p.holechildren = n.holechildren, p.isholepath = n.isholepath; a < n.points.length;) { for (c = n.points[a].linesegment, f = -1, u = a + 1; (n.points[u].linesegment === c || n.points[u].linesegment === f || f === -1) && u < n.points.length - 1;)n.points[u].linesegment !== c && f === -1 && (f = n.points[u].linesegment), u++; u === n.points.length - 1 && (u = 0), p.segments = p.segments.concat(o.fitseq(n, i, r, a, u)), u > 0 ? a = u : a = n.points.length } return p }, this.fitseq = function (n, i, r, a, c) { if (c > n.points.length || c < 0) return []; var f = a, u = 0, p = !0, v, T, k, R = c - a; R < 0 && (R += n.points.length); for (var $ = (n.points[c].x - n.points[a].x) / R, N = (n.points[c].y - n.points[a].y) / R, P = (a + 1) % n.points.length, W; P != c;)W = P - a, W < 0 && (W += n.points.length), v = n.points[a].x + $ * W, T = n.points[a].y + N * W, k = (n.points[P].x - v) * (n.points[P].x - v) + (n.points[P].y - T) * (n.points[P].y - T), k > i && (p = !1), k > u && (f = P, u = k), P = (P + 1) % n.points.length; if (p) return [{ type: "L", x1: n.points[a].x, y1: n.points[a].y, x2: n.points[c].x, y2: n.points[c].y }]; var K = f; p = !0, u = 0; var j = (K - a) / R, le = (1 - j) * (1 - j), de = 2 * (1 - j) * j, ue = j * j, Fe = (le * n.points[a].x + ue * n.points[c].x - n.points[K].x) / -de, re = (le * n.points[a].y + ue * n.points[c].y - n.points[K].y) / -de; for (P = a + 1; P != c;)j = (P - a) / R, le = (1 - j) * (1 - j), de = 2 * (1 - j) * j, ue = j * j, v = le * n.points[a].x + de * Fe + ue * n.points[c].x, T = le * n.points[a].y + de * re + ue * n.points[c].y, k = (n.points[P].x - v) * (n.points[P].x - v) + (n.points[P].y - T) * (n.points[P].y - T), k > r && (p = !1), k > u && (f = P, u = k), P = (P + 1) % n.points.length; if (p) return [{ type: "Q", x1: n.points[a].x, y1: n.points[a].y, x2: Fe, y2: re, x3: n.points[c].x, y3: n.points[c].y }]; var ye = K; return o.fitseq(n, i, r, a, ye).concat(o.fitseq(n, i, r, ye, c)) }, this.batchtracepaths = function (n, i, r) { var a = []; for (var c in n) n.hasOwnProperty(c) && a.push(o.tracepath(n[c], i, r)); return a }, this.batchtracelayers = function (n, i, r) { var a = []; for (var c in n) n.hasOwnProperty(c) && (a[c] = o.batchtracepaths(n[c], i, r)); return a }, this.roundtodec = function (n, i) { return +n.toFixed(i) }, this.svgpathstring = function (n, i, r, a) { var c = n.layers[i], f = c[r], u = "", p; if (a.linefilter && f.segments.length < 3) return u; if (u = "<path " + (a.desc ? 'desc="l ' + i + " p " + r + '" ' : "") + o.tosvgcolorstr(n.palette[i], a) + 'd="', a.roundcoords === -1) { for (u += "M " + f.segments[0].x1 * a.scale + " " + f.segments[0].y1 * a.scale + " ", p = 0; p < f.segments.length; p++)u += f.segments[p].type + " " + f.segments[p].x2 * a.scale + " " + f.segments[p].y2 * a.scale + " ", f.segments[p].hasOwnProperty("x3") && (u += f.segments[p].x3 * a.scale + " " + f.segments[p].y3 * a.scale + " "); u += "Z " } else { for (u += "M " + o.roundtodec(f.segments[0].x1 * a.scale, a.roundcoords) + " " + o.roundtodec(f.segments[0].y1 * a.scale, a.roundcoords) + " ", p = 0; p < f.segments.length; p++)u += f.segments[p].type + " " + o.roundtodec(f.segments[p].x2 * a.scale, a.roundcoords) + " " + o.roundtodec(f.segments[p].y2 * a.scale, a.roundcoords) + " ", f.segments[p].hasOwnProperty("x3") && (u += o.roundtodec(f.segments[p].x3 * a.scale, a.roundcoords) + " " + o.roundtodec(f.segments[p].y3 * a.scale, a.roundcoords) + " "); u += "Z " } for (var v = 0; v < f.holechildren.length; v++) { var T = c[f.holechildren[v]]; if (a.roundcoords === -1) for (T.segments[T.segments.length - 1].hasOwnProperty("x3") ? u += "M " + T.segments[T.segments.length - 1].x3 * a.scale + " " + T.segments[T.segments.length - 1].y3 * a.scale + " " : u += "M " + T.segments[T.segments.length - 1].x2 * a.scale + " " + T.segments[T.segments.length - 1].y2 * a.scale + " ", p = T.segments.length - 1; p >= 0; p--)u += T.segments[p].type + " ", T.segments[p].hasOwnProperty("x3") && (u += T.segments[p].x2 * a.scale + " " + T.segments[p].y2 * a.scale + " "), u += T.segments[p].x1 * a.scale + " " + T.segments[p].y1 * a.scale + " "; else for (T.segments[T.segments.length - 1].hasOwnProperty("x3") ? u += "M " + o.roundtodec(T.segments[T.segments.length - 1].x3 * a.scale) + " " + o.roundtodec(T.segments[T.segments.length - 1].y3 * a.scale) + " " : u += "M " + o.roundtodec(T.segments[T.segments.length - 1].x2 * a.scale) + " " + o.roundtodec(T.segments[T.segments.length - 1].y2 * a.scale) + " ", p = T.segments.length - 1; p >= 0; p--)u += T.segments[p].type + " ", T.segments[p].hasOwnProperty("x3") && (u += o.roundtodec(T.segments[p].x2 * a.scale) + " " + o.roundtodec(T.segments[p].y2 * a.scale) + " "), u += o.roundtodec(T.segments[p].x1 * a.scale) + " " + o.roundtodec(T.segments[p].y1 * a.scale) + " "; u += "Z " } if (u += '" />', a.lcpr || a.qcpr) { for (p = 0; p < f.segments.length; p++)f.segments[p].hasOwnProperty("x3") && a.qcpr && (u += '<circle cx="' + f.segments[p].x2 * a.scale + '" cy="' + f.segments[p].y2 * a.scale + '" r="' + a.qcpr + '" fill="cyan" stroke-width="' + a.qcpr * .2 + '" stroke="black" />', u += '<circle cx="' + f.segments[p].x3 * a.scale + '" cy="' + f.segments[p].y3 * a.scale + '" r="' + a.qcpr + '" fill="white" stroke-width="' + a.qcpr * .2 + '" stroke="black" />', u += '<line x1="' + f.segments[p].x1 * a.scale + '" y1="' + f.segments[p].y1 * a.scale + '" x2="' + f.segments[p].x2 * a.scale + '" y2="' + f.segments[p].y2 * a.scale + '" stroke-width="' + a.qcpr * .2 + '" stroke="cyan" />', u += '<line x1="' + f.segments[p].x2 * a.scale + '" y1="' + f.segments[p].y2 * a.scale + '" x2="' + f.segments[p].x3 * a.scale + '" y2="' + f.segments[p].y3 * a.scale + '" stroke-width="' + a.qcpr * .2 + '" stroke="cyan" />'), !f.segments[p].hasOwnProperty("x3") && a.lcpr && (u += '<circle cx="' + f.segments[p].x2 * a.scale + '" cy="' + f.segments[p].y2 * a.scale + '" r="' + a.lcpr + '" fill="white" stroke-width="' + a.lcpr * .2 + '" stroke="black" />'); for (var v = 0; v < f.holechildren.length; v++) { var T = c[f.holechildren[v]]; for (p = 0; p < T.segments.length; p++)T.segments[p].hasOwnProperty("x3") && a.qcpr && (u += '<circle cx="' + T.segments[p].x2 * a.scale + '" cy="' + T.segments[p].y2 * a.scale + '" r="' + a.qcpr + '" fill="cyan" stroke-width="' + a.qcpr * .2 + '" stroke="black" />', u += '<circle cx="' + T.segments[p].x3 * a.scale + '" cy="' + T.segments[p].y3 * a.scale + '" r="' + a.qcpr + '" fill="white" stroke-width="' + a.qcpr * .2 + '" stroke="black" />', u += '<line x1="' + T.segments[p].x1 * a.scale + '" y1="' + T.segments[p].y1 * a.scale + '" x2="' + T.segments[p].x2 * a.scale + '" y2="' + T.segments[p].y2 * a.scale + '" stroke-width="' + a.qcpr * .2 + '" stroke="cyan" />', u += '<line x1="' + T.segments[p].x2 * a.scale + '" y1="' + T.segments[p].y2 * a.scale + '" x2="' + T.segments[p].x3 * a.scale + '" y2="' + T.segments[p].y3 * a.scale + '" stroke-width="' + a.qcpr * .2 + '" stroke="cyan" />'), !T.segments[p].hasOwnProperty("x3") && a.lcpr && (u += '<circle cx="' + T.segments[p].x2 * a.scale + '" cy="' + T.segments[p].y2 * a.scale + '" r="' + a.lcpr + '" fill="white" stroke-width="' + a.lcpr * .2 + '" stroke="black" />') } } return u }, this.getsvgstring = function (n, i) { i = o.checkoptions(i); for (var r = n.width * i.scale, a = n.height * i.scale, c = "<svg " + (i.viewbox ? 'viewBox="0 0 ' + r + " " + a + '" ' : 'width="' + r + '" height="' + a + '" ') + 'version="1.1" xmlns="http://www.w3.org/2000/svg" desc="Created with imagetracer.js version ' + o.versionnumber + '" >', f = 0; f < n.layers.length; f++)for (var u = 0; u < n.layers[f].length; u++)n.layers[f][u].isholepath || (c += o.svgpathstring(n, f, u, i)); return c += "</svg>", c }, this.compareNumbers = function (n, i) { return n - i }, this.torgbastr = function (n) { return "rgba(" + n.r + "," + n.g + "," + n.b + "," + n.a + ")" }, this.tosvgcolorstr = function (n, i) { return 'fill="rgb(' + n.r + "," + n.g + "," + n.b + ')" stroke="rgb(' + n.r + "," + n.g + "," + n.b + ')" stroke-width="' + i.strokewidth + '" opacity="' + n.a / 255 + '" ' }, this.appendSVGString = function (n, i) { var r; i ? (r = document.getElementById(i), r || (r = document.createElement("div"), r.id = i, document.body.appendChild(r))) : (r = document.createElement("div"), document.body.appendChild(r)), r.innerHTML += n }, this.gks = [[.27901, .44198, .27901], [.135336, .228569, .272192, .228569, .135336], [.086776, .136394, .178908, .195843, .178908, .136394, .086776], [.063327, .093095, .122589, .144599, .152781, .144599, .122589, .093095, .063327], [.049692, .069304, .089767, .107988, .120651, .125194, .120651, .107988, .089767, .069304, .049692]], this.blur = function (n, i, r) { var a, c, f, u, p, v, T, k, R, $, N = { width: n.width, height: n.height, data: [] }; if (i = Math.floor(i), i < 1) return n; i > 5 && (i = 5), r = Math.abs(r), r > 1024 && (r = 1024); var P = o.gks[i - 1]; for (c = 0; c < n.height; c++)for (a = 0; a < n.width; a++) { for (v = 0, T = 0, k = 0, R = 0, $ = 0, f = -i; f < i + 1; f++)a + f > 0 && a + f < n.width && (p = (c * n.width + a + f) * 4, v += n.data[p] * P[f + i], T += n.data[p + 1] * P[f + i], k += n.data[p + 2] * P[f + i], R += n.data[p + 3] * P[f + i], $ += P[f + i]); p = (c * n.width + a) * 4, N.data[p] = Math.floor(v / $), N.data[p + 1] = Math.floor(T / $), N.data[p + 2] = Math.floor(k / $), N.data[p + 3] = Math.floor(R / $) } var W = new Uint8ClampedArray(N.data); for (c = 0; c < n.height; c++)for (a = 0; a < n.width; a++) { for (v = 0, T = 0, k = 0, R = 0, $ = 0, f = -i; f < i + 1; f++)c + f > 0 && c + f < n.height && (p = ((c + f) * n.width + a) * 4, v += W[p] * P[f + i], T += W[p + 1] * P[f + i], k += W[p + 2] * P[f + i], R += W[p + 3] * P[f + i], $ += P[f + i]); p = (c * n.width + a) * 4, N.data[p] = Math.floor(v / $), N.data[p + 1] = Math.floor(T / $), N.data[p + 2] = Math.floor(k / $), N.data[p + 3] = Math.floor(R / $) } for (c = 0; c < n.height; c++)for (a = 0; a < n.width; a++)p = (c * n.width + a) * 4, u = Math.abs(N.data[p] - n.data[p]) + Math.abs(N.data[p + 1] - n.data[p + 1]) + Math.abs(N.data[p + 2] - n.data[p + 2]) + Math.abs(N.data[p + 3] - n.data[p + 3]), u > r && (N.data[p] = n.data[p], N.data[p + 1] = n.data[p + 1], N.data[p + 2] = n.data[p + 2], N.data[p + 3] = n.data[p + 3]); return N }, this.loadImage = function (n, i, r) { var a = new Image; r && r.corsenabled && (a.crossOrigin = "Anonymous"), a.onload = function () { var c = document.createElement("canvas"); c.width = a.width, c.height = a.height; var f = c.getContext("2d"); f.drawImage(a, 0, 0), i(c) }, a.src = n }, this.getImgdata = function (n) { var i = n.getContext("2d"); return i.getImageData(0, 0, n.width, n.height) }, this.specpalette = [{ r: 0, g: 0, b: 0, a: 255 }, { r: 128, g: 128, b: 128, a: 255 }, { r: 0, g: 0, b: 128, a: 255 }, { r: 64, g: 64, b: 128, a: 255 }, { r: 192, g: 192, b: 192, a: 255 }, { r: 255, g: 255, b: 255, a: 255 }, { r: 128, g: 128, b: 192, a: 255 }, { r: 0, g: 0, b: 192, a: 255 }, { r: 128, g: 0, b: 0, a: 255 }, { r: 128, g: 64, b: 64, a: 255 }, { r: 128, g: 0, b: 128, a: 255 }, { r: 168, g: 168, b: 168, a: 255 }, { r: 192, g: 128, b: 128, a: 255 }, { r: 192, g: 0, b: 0, a: 255 }, { r: 255, g: 255, b: 255, a: 255 }, { r: 0, g: 128, b: 0, a: 255 }], this.drawLayers = function (n, i, r, a) { r = r || 1; var c, f, u, p, v, T; a ? (T = document.getElementById(a), T || (T = document.createElement("div"), T.id = a, document.body.appendChild(T))) : (T = document.createElement("div"), document.body.appendChild(T)); for (v in n) if (n.hasOwnProperty(v)) { c = n[v][0].length, f = n[v].length; var k = document.createElement("canvas"); k.width = c * r, k.height = f * r; var R = k.getContext("2d"); for (p = 0; p < f; p++)for (u = 0; u < c; u++)R.fillStyle = o.torgbastr(i[n[v][p][u] % i.length]), R.fillRect(u * r, p * r, r, r); T.appendChild(k) } } } t.exports = new e })() })(Cr)), Cr.exports } var fv = uv(); const pv = cv(fv); var Me; (function (t) { t.LOAD = "LOAD", t.EXEC = "EXEC", t.FFPROBE = "FFPROBE", t.WRITE_FILE = "WRITE_FILE", t.READ_FILE = "READ_FILE", t.DELETE_FILE = "DELETE_FILE", t.RENAME = "RENAME", t.CREATE_DIR = "CREATE_DIR", t.LIST_DIR = "LIST_DIR", t.DELETE_DIR = "DELETE_DIR", t.ERROR = "ERROR", t.DOWNLOAD = "DOWNLOAD", t.PROGRESS = "PROGRESS", t.LOG = "LOG", t.MOUNT = "MOUNT", t.UNMOUNT = "UNMOUNT" })(Me || (Me = {})); const mv = (() => { let t = 0; return () => t++ })(), gv = new Error("ffmpeg is not loaded, call `await ffmpeg.load()` first"), hv = new Error("called FFmpeg.terminate()"); var Nt, no, Mn, Co, wo, Fs, It; class yv { constructor() { to(this, Nt, null); to(this, no, {}); to(this, Mn, {}); to(this, Co, []); to(this, wo, []); wt(this, "loaded", !1); to(this, Fs, () => { Te(this, Nt) && (Te(this, Nt).onmessage = ({ data: { id: e, type: o, data: n } }) => { switch (o) { case Me.LOAD: this.loaded = !0, Te(this, no)[e](n); break; case Me.MOUNT: case Me.UNMOUNT: case Me.EXEC: case Me.FFPROBE: case Me.WRITE_FILE: case Me.READ_FILE: case Me.DELETE_FILE: case Me.RENAME: case Me.CREATE_DIR: case Me.LIST_DIR: case Me.DELETE_DIR: Te(this, no)[e](n); break; case Me.LOG: Te(this, Co).forEach(i => i(n)); break; case Me.PROGRESS: Te(this, wo).forEach(i => i(n)); break; case Me.ERROR: Te(this, Mn)[e](n); break }delete Te(this, no)[e], delete Te(this, Mn)[e] }) }); to(this, It, ({ type: e, data: o }, n = [], i) => Te(this, Nt) ? new Promise((r, a) => { const c = mv(); Te(this, Nt) && Te(this, Nt).postMessage({ id: c, type: e, data: o }, n), Te(this, no)[c] = r, Te(this, Mn)[c] = a, i == null || i.addEventListener("abort", () => { a(new DOMException(`Message # ${c} was aborted`, "AbortError")) }, { once: !0 }) }) : Promise.reject(gv)); wt(this, "load", ({ classWorkerURL: e, ...o } = {}, { signal: n } = {}) => (Te(this, Nt) || (Yi(this, Nt, e ? new Worker(new URL(e, import.meta.url), { type: "module" }) : new Worker(new URL("" + new URL("worker-BAOIWoxA.js", import.meta.url).href, import.meta.url), { type: "module" })), Te(this, Fs).call(this)), Te(this, It).call(this, { type: Me.LOAD, data: o }, void 0, n))); wt(this, "exec", (e, o = -1, { signal: n } = {}) => Te(this, It).call(this, { type: Me.EXEC, data: { args: e, timeout: o } }, void 0, n)); wt(this, "ffprobe", (e, o = -1, { signal: n } = {}) => Te(this, It).call(this, { type: Me.FFPROBE, data: { args: e, timeout: o } }, void 0, n)); wt(this, "terminate", () => { const e = Object.keys(Te(this, Mn)); for (const o of e) Te(this, Mn)[o](hv), delete Te(this, Mn)[o], delete Te(this, no)[o]; Te(this, Nt) && (Te(this, Nt).terminate(), Yi(this, Nt, null), this.loaded = !1) }); wt(this, "writeFile", (e, o, { signal: n } = {}) => { const i = []; return o instanceof Uint8Array && i.push(o.buffer), Te(this, It).call(this, { type: Me.WRITE_FILE, data: { path: e, data: o } }, i, n) }); wt(this, "mount", (e, o, n) => { const i = []; return Te(this, It).call(this, { type: Me.MOUNT, data: { fsType: e, options: o, mountPoint: n } }, i) }); wt(this, "unmount", e => { const o = []; return Te(this, It).call(this, { type: Me.UNMOUNT, data: { mountPoint: e } }, o) }); wt(this, "readFile", (e, o = "binary", { signal: n } = {}) => Te(this, It).call(this, { type: Me.READ_FILE, data: { path: e, encoding: o } }, void 0, n)); wt(this, "deleteFile", (e, { signal: o } = {}) => Te(this, It).call(this, { type: Me.DELETE_FILE, data: { path: e } }, void 0, o)); wt(this, "rename", (e, o, { signal: n } = {}) => Te(this, It).call(this, { type: Me.RENAME, data: { oldPath: e, newPath: o } }, void 0, n)); wt(this, "createDir", (e, { signal: o } = {}) => Te(this, It).call(this, { type: Me.CREATE_DIR, data: { path: e } }, void 0, o)); wt(this, "listDir", (e, { signal: o } = {}) => Te(this, It).call(this, { type: Me.LIST_DIR, data: { path: e } }, void 0, o)); wt(this, "deleteDir", (e, { signal: o } = {}) => Te(this, It).call(this, { type: Me.DELETE_DIR, data: { path: e } }, void 0, o)) } on(e, o) { e === "log" ? Te(this, Co).push(o) : e === "progress" && Te(this, wo).push(o) } off(e, o) { e === "log" ? Yi(this, Co, Te(this, Co).filter(n => n !== o)) : e === "progress" && Yi(this, wo, Te(this, wo).filter(n => n !== o)) } } Nt = new WeakMap, no = new WeakMap, Mn = new WeakMap, Co = new WeakMap, wo = new WeakMap, Fs = new WeakMap, It = new WeakMap; var Uc; (function (t) { t.MEMFS = "MEMFS", t.NODEFS = "NODEFS", t.NODERAWFS = "NODERAWFS", t.IDBFS = "IDBFS", t.WORKERFS = "WORKERFS", t.PROXYFS = "PROXYFS" })(Uc || (Uc = {})); const vv = t => new Promise((e, o) => { const n = new FileReader; n.onload = () => { const { result: i } = n; i instanceof ArrayBuffer ? e(new Uint8Array(i)) : e(new Uint8Array) }, n.onerror = i => { var r, a; o(Error(`File could not be read! Code=${((a = (r = i == null ? void 0 : i.target) == null ? void 0 : r.error) == null ? void 0 : a.code) || -1}`)) }, n.readAsArrayBuffer(t) }), wr = async t => { let e; if (typeof t == "string") /data:_data\/([a-zA-Z]*);base64,([^"]*)/.test(t) ? e = atob(t.split(",")[1]).split("").map(o => o.charCodeAt(0)) : e = await (await fetch(t)).arrayBuffer(); else if (t instanceof URL) e = await (await fetch(t)).arrayBuffer(); else if (t instanceof File || t instanceof Blob) e = await vv(t); else return new Uint8Array; return new Uint8Array(e) }; window.addEventListener("DOMContentLoaded", () => {
  var Zl, Ql, jl, ed, td, nd, od, id, sd; let t = null, e = null, o = null, n = null, i = [], r = -1, a = null, c = [], f = -1, u = [], p = -1, v = [], T = -1, k = null, R = [null, null, null, null], $ = null, N = !1, P = [null, null, null], W = [null, null, null], K = null, j = null, le = null, de = null, ue = null, Fe = null, re = "page-usages", ye = null, xe = null, $e = null, Lt = !1, Rt = []; const Qi = d => { if (!d || !d.type) return "other"; const m = String(d.type).toLowerCase(), y = String(d.category || d.mediaCategory || d.kind || d.assetType || "").toLowerCase(), h = String(d.studio || d.sourceStudio || d.origin || "").toLowerCase(), C = String(d.name || "").toLowerCase(), E = String(d.dataUrl || d.url || "").toLowerCase(), b = Array.isArray(d.tags) ? d.tags.map(S => String(S).toLowerCase()) : [], w = y.includes("2d") || h.includes("2d") || h.includes("icon") || b.some(S => S.includes("2d") || S.includes("icon")) || C.includes("2d") || C.includes("icon_") || C.includes("icon-") || E.includes("/2d/") || E.includes("2d_") || E.includes("/icons/") || E.includes("icon"); return m.startsWith("video/") ? w ? "2dVideo" : "video" : m.startsWith("image/") ? "image" : "other" }, Pt = d => { const m = { video: [], image: [], "2dVideo": [], other: [] }; return d.forEach(y => { const h = Qi(y); m[h].push(y) }), [...m.video, ...m.image, ...m["2dVideo"], ...m.other] }; let Un = null, Li = null; const Lo = d => { if (!d) return; d.requestFullscreen, d.webkitRequestFullscreen, d.mozRequestFullScreen, d.msRequestFullscreen, d.requestFullscreen = () => Promise.reject(new Error("Fullscreen disabled")), d.webkitRequestFullscreen = () => Promise.reject(new Error("Fullscreen disabled")), d.mozRequestFullScreen = () => Promise.reject(new Error("Fullscreen disabled")), d.msRequestFullscreen = () => Promise.reject(new Error("Fullscreen disabled")), d.addEventListener("dblclick", y => { y.preventDefault(), y.stopPropagation() }, { once: !1 }); const m = () => { (document.fullscreenElement === d || document.webkitFullscreenElement === d || document.mozFullScreenElement === d || document.msFullscreenElement === d) && (document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.msExitFullscreen && document.msExitFullscreen()) }; document.addEventListener("fullscreenchange", m), document.addEventListener("webkitfullscreenchange", m), document.addEventListener("mozfullscreenchange", m), document.addEventListener("MSFullscreenChange", m) }; let yt = [], qe = [null, null, null], V = null, _e = [], Ie = -1, _o = null; const ji = () => { if (typeof window < "u" && !(localStorage.getItem("isLoggedIn") === "true")) return console.warn("[API Key] User must be logged in to use API key."), ""; if (typeof window < "u") { const d = localStorage.getItem("geminiApiKey") || localStorage.getItem("GEMINI_API_KEY"); if (d) return d } return typeof window < "u" && console.warn("[API Key] No API key found. Please set it in the API Key modal after logging in."), "" }; let _i = null; const qr = () => { if (!_i) { const d = ji(); if (!d) throw new Error("API Key must be set. Please set it in the API Key modal after logging in."); _i = new Mc({ apiKey: d }) } return _i }, Xe = { get models() { return qr().models }, get operations() { return qr().operations } }, du = JSON.stringify({ task: "generate isometric 3D icon", style_lock: !0, subject: "{ICON_SUBJECT}", guidance: { aspect_ratio: "1:1", instruction_strength: "strict", priority_order: ["subject", "style_consistency", "color_palette", "material_spec"], consistency_reference: "Match Creon 3D icon sheet: smooth glossy plastic, floating subject, uniform lighting." }, output: { format: "png", size: "2048x2048", background: "#FFFFFF", alpha: !0, safety_settings: { allowed_content: ["stylized_character"], disallowed_content: ["photographic_realism", "text"] } }, negative_prompt: "photographic realism, fabric texture, gritty, noise, grain, metallic reflections, subsurface scattering, wood grain, glass refraction, text, watermark, drop shadow, vignette, cinematic lighting, background gradients, extra props, multiple subjects, poorly defined limbs, messy geometry, outline, harsh contrast, oversaturated colors", brand_tone: "vibrant, modern, friendly, premium", system: { scalable: !0, interchangeable: !0 }, background: { type: "solid", color: "#FFFFFF", alpha: !0 }, render: { engine: "flash-3d", quality: "ultra-high", resolution: 2048, postprocess: "clean", separation: "by color/lighting/depth only" }, colors: { palette_name: "Creon Blue System", dominant_blue: "#2E6BFF", secondary_blue: "#4FC3F7", neutral_white: "#FFFFFF", warm_accent: "#FFD45A", inherent_colors: "Only if essential for the subject (low saturation pastel skin/hair). No new hues." }, materials: { primary: "smooth high-gloss plastic", secondary: "matte pastel plastic", accents: "translucent frosted plastic", surface_detail: "no noise, no texture, no scratches" }, lighting: { mode: "soft global illumination", source: "dual top-front softboxes with faint rim light", highlights: "broad glossy bloom, no hard speculars", shadows: "internal occlusion only, no ground shadow", exposure: "balanced, no high contrast" }, form: { shapes: "pillowy, inflated, soft-volume forms", edges: "rounded with 85% fillet, zero sharp corners", proportions: "chibi/stylized, simplified anatomy", deformation: "squash-and-stretch for friendliness", surface_finish: "clean, seamless" }, composition: { elements: "single hero subject floating; only props essential to subject", depth: "distinct layering, slight elevation", density: "minimal, focused center", framing: "Subject fully visible and centered with clean margins" }, camera: { type: "isometric", lens: "orthographic", tilt: "35deg", pan: "35deg", distance: "medium shot", focus: "global sharp", motion: "static" }, canvas: { ratio: "1:1", safe_margins: !0 }, background_guidance: "Keep background white, no gradients or props" }, null, 2), Gs = JSON.stringify({ task: "generate isometric 3D icon", style_lock: !0, subject: "{ICON_SUBJECT|backpack}", guidance: { aspect_ratio: "16:9", instruction_strength: "strict", priority_order: ["subject", "style_consistency", "color_palette", "material_spec"], consistency_reference: "Match Creon 3D icon sheet: smooth glossy plastic, floating subject, uniform lighting." }, output: { format: "png", size: "1024x576", width: 1024, height: 576, background: "#FFFFFF", alpha: !0, safety_settings: { allowed_content: ["stylized_character"], disallowed_content: ["photographic_realism", "text"] } }, render: { engine: "flash-3d", quality: "ultra-high", resolution: 1024, width: 1024, height: 576, sampling: "deterministic", postprocess: "clean", separation: "by color/lighting/depth only" }, camera: { type: "isometric", lens: "orthographic", tilt: "35deg", pan: "35deg", distance: "medium shot", focus: "global sharp", motion: "static" }, lighting: { mode: "soft global illumination", source: "dual top-front softboxes with faint rim light", highlights: "broad glossy bloom, no hard speculars", shadows: "internal occlusion only, no ground shadow", exposure: "balanced, no high contrast" }, materials: { primary: "smooth high-gloss plastic", secondary: "matte pastel plastic", accents: "translucent frosted plastic", surface_detail: "no noise, no texture, no scratches" }, colors: { palette_name: "Creon Blue System", dominant_blue: "#2E6BFF", secondary_blue: "#4FC3F7", neutral_white: "#FFFFFF", warm_accent: "#FFD45A", inherent_colors: "Only if essential for the subject (low saturation pastel skin/hair). No new hues." }, form: { shapes: "pillowy, inflated, soft-volume forms", edges: "rounded with 85% fillet, zero sharp corners", proportions: "chibi/stylized, simplified anatomy", deformation: "squash-and-stretch for friendliness", surface_finish: "clean, seamless" }, composition: { elements: "single hero subject floating; only props essential to subject", density: "minimal, generous negative space", framing: "subject centered with equal top/bottom margins, fully contained", depth: "3-layer depth stack with gentle parallax" }, background: { type: "solid", color: "#FFFFFF", environment: "studio cyclorama", ground_contact: "none (floating)" }, brand_tone: "vibrant, modern, friendly, premium, tech-forward", system: { scalable: !0, interchangeable: !0, documentation: "Follow Gemini 2.5 Flash prompt best practices; short explicit fields, clear priority." }, negative_prompt: "photographic realism, fabric texture, gritty, noise, grain, metallic reflections, subsurface scattering, wood grain, glass refraction, text, watermark, drop shadow, ground/drop shadows, vignette, cinematic lighting, background gradients, extra props, multiple subjects, poorly defined limbs, messy geometry, 1024x1024 output, square aspect ratio, outline, harsh contrast, oversaturated colors", safety: { violence: "none", adult: "none", medical: "none", political: "none" } }, null, 2), Os = JSON.stringify({ task: "generate a single 2D vector icon in the precise style of Google Material Symbols.", subject: "{ICON_SUBJECT}", style_lock: !0, controls: { style: { shape: "outlined", fill: { enabled: !1 } }, stroke: { weight: { value: 400, unit: "weight" } }, color: { primary: "#212121" } }, output: { format: "png", size: "1024x1024", background: "#FFFFFF" }, constraints: { single_output: !0, no_variations_or_set: !0 }, negative_prompt: "3D, photo, realism, shading, gradients, textures, raster, pixelated, complex details, multiple icons, variations, set, collage, hand-drawn, overly detailed, skeuomorphic, shadows, outer border, frame, container shape, rounded square backdrop, card outline", brand_tone: "Google Material Design, clean, minimal, consistent, modern, utilitarian", style_rules: { inspiration: "Google Material Symbols (fonts.google.com/icons)", render_type: "outlined", stroke_weight_map: "weight 100-900 -> 1-4px, perfectly uniform stroke width", corner_radius_map: "rounded -> 6-12% | sharp -> 0% | outlined -> 2-4%", grid: "24x24 dp material design icon grid", alignment: "pixel-perfect, centered within the 24x24 grid", geometry: "simple, geometric, bold, with minimal detail", line_caps: "rounded", line_joins: "rounded" }, composition: { elements: "exactly one icon, centered", margin: "15%", forbidden: "no surrounding frame, no border, no container shape, no backdrop; icon strokes only" } }, null, 2), cu = [{ name: "home", tags: ["house", "building", "main"] }, { name: "search", tags: ["find", "magnifying glass", "query"] }, { name: "settings", tags: ["options", "gear", "controls"] }, { name: "favorite", tags: ["heart", "love", "like"] }, { name: "add", tags: ["plus", "create", "new"] }, { name: "delete", tags: ["trash", "remove", "bin"] }, { name: "edit", tags: ["pencil", "change", "modify"] }, { name: "menu", tags: ["hamburger", "navigation", "options"] }, { name: "close", tags: ["exit", "x", "cancel"] }, { name: "person", tags: ["user", "account", "profile"] }, { name: "shopping_cart", tags: ["buy", "purchase", "store"] }, { name: "cloud", tags: ["weather", "sky", "storage"] }, { name: "email", tags: ["mail", "message", "inbox"] }, { name: "lightbulb", tags: ["idea", "suggestion", "hint"] }, { name: "task_alt", tags: ["check", "done", "complete", "ok"] }, { name: "token", tags: ["sparkle", "ai", "gemini"] }, { name: "bolt", tags: ["fast", "energy", "power"] }, { name: "rocket_launch", tags: ["space", "deploy", "start"] }, { name: "palette", tags: ["color", "art", "design"] }, { name: "shield", tags: ["security", "protection", "safe"] }, { name: "done", tags: ["check", "complete", "finished"] }, { name: "info", tags: ["information", "details", "about"] }, { name: "help", tags: ["question", "support", "faq"] }, { name: "warning", tags: ["alert", "caution", "error"] }, { name: "error", tags: ["problem", "issue", "alert"] }, { name: "thumb_up", tags: ["like", "approve", "agree"] }, { name: "thumb_down", tags: ["dislike", "disapprove", "disagree"] }, { name: "visibility", tags: ["eye", "view", "see", "preview"] }, { name: "visibility_off", tags: ["eye", "hide", "hidden", "unsee"] }, { name: "refresh", tags: ["reload", "sync", "update"] }, { name: "logout", tags: ["sign out", "exit", "leave"] }, { name: "login", tags: ["sign in", "enter", "access"] }, { name: "download", tags: ["save", "get", "import"] }, { name: "upload", tags: ["send", "publish", "export"] }, { name: "link", tags: ["url", "connect", "chain"] }, { name: "attach_file", tags: ["paperclip", "attachment", "upload"] }, { name: "share", tags: ["send", "connect", "social"] }, { name: "filter_list", tags: ["sort", "options", "filter"] }, { name: "flag", tags: ["report", "mark", "important"] }, { name: "bookmark", tags: ["save", "favorite", "remember"] }, { name: "print", tags: ["printer", "document", "copy"] }, { name: "launch", tags: ["open", "external", "new tab"] }, { name: "arrow_back", tags: ["left", "previous", "return"] }, { name: "arrow_forward", tags: ["right", "next", "continue"] }, { name: "arrow_upward", tags: ["up", "top", "scroll"] }, { name: "arrow_downward", tags: ["down", "bottom", "scroll"] }, { name: "expand_more", tags: ["down", "arrow", "dropdown"] }, { name: "expand_less", tags: ["up", "arrow", "collapse"] }, { name: "chevron_left", tags: ["back", "arrow", "previous"] }, { name: "chevron_right", tags: ["forward", "arrow", "next"] }, { name: "apps", tags: ["grid", "menu", "dashboard"] }, { name: "more_vert", tags: ["dots", "options", "menu"] }, { name: "more_horiz", tags: ["dots", "options", "menu"] }, { name: "unfold_more", tags: ["expand", "collapse", "arrows"] }, { name: "call", tags: ["phone", "contact", "telephone"] }, { name: "chat", tags: ["message", "talk", "bubble"] }, { name: "forum", tags: ["community", "discussion", "messages"] }, { name: "send", tags: ["submit", "message", "mail"] }, { name: "notifications", tags: ["bell", "alert", "reminders"] }, { name: "format_bold", tags: ["text", "style", "bold"] }, { name: "format_italic", tags: ["text", "style", "italic"] }, { name: "format_underlined", tags: ["text", "style", "underline"] }, { name: "format_align_left", tags: ["text", "style", "align"] }, { name: "format_align_center", tags: ["text", "style", "align"] }, { name: "format_align_right", tags: ["text", "style", "align"] }, { name: "format_quote", tags: ["text", "style", "blockquote"] }, { name: "format_list_bulleted", tags: ["text", "style", "list"] }, { name: "format_list_numbered", tags: ["text", "style", "list"] }, { name: "image", tags: ["photo", "picture", "gallery"] }, { name: "photo_camera", tags: ["camera", "picture", "take photo"] }, { name: "videocam", tags: ["video", "camera", "record"] }, { name: "play_arrow", tags: ["start", "run", "video"] }, { name: "pause", tags: ["stop", "hold", "video"] }, { name: "stop", tags: ["end", "video", "media"] }, { name: "volume_up", tags: ["sound", "audio", "music"] }, { name: "volume_off", tags: ["mute", "sound", "audio"] }, { name: "mic", tags: ["microphone", "record", "voice"] }, { name: "mic_off", tags: ["mute", "microphone", "voice"] }, { name: "fullscreen", tags: ["expand", "view", "screen"] }, { name: "file_present", tags: ["document", "file", "attachment"] }, { name: "folder", tags: ["directory", "files", "storage"] }, { name: "analytics", tags: ["chart", "data", "statistics"] }, { name: "pie_chart", tags: ["data", "graph", "analytics"] }, { name: "database", tags: ["data", "storage", "server"] }, { name: "key", tags: ["password", "login", "security"] }, { name: "lock", tags: ["security", "password", "private"] }, { name: "public", tags: ["world", "global", "internet"] }, { name: "map", tags: ["location", "gps", "navigation"] }, { name: "place", tags: ["location", "marker", "pin"] }, { name: "restaurant", tags: ["food", "dining", "eat"] }, { name: "local_mall", tags: ["shopping", "bag", "store"] }, { name: "work", tags: ["briefcase", "job", "office"] }, { name: "calendar_month", tags: ["date", "schedule", "event"] }, { name: "schedule", tags: ["time", "clock", "watch"] }, { name: "language", tags: ["translate", "web", "global"] }, { name: "code", tags: ["developer", "programming", "script"] }, { name: "terminal", tags: ["console", "code", "developer"] }, { name: "bug_report", tags: ["debug", "issue", "error"] }, { name: "dashboard", tags: ["grid", "layout", "home"] }, { name: "groups", tags: ["people", "team", "users"] }, { name: "science", tags: ["test", "lab", "experiment"] }, { name: "construction", tags: ["tools", "build", "wrench"] }, { name: "psychology", tags: ["brain", "idea", "think"] }, { name: "eco", tags: ["leaf", "nature", "green"] }, { name: "pets", tags: ["animal", "dog", "cat", "paw"] }, { name: "savings", tags: ["money", "piggy bank", "finance"] }, { name: "credit_card", tags: ["payment", "finance", "money"] }, { name: "receipt_long", tags: ["invoice", "bill", "payment"] }, { name: "account_balance", tags: ["bank", "finance", "money"] }, { name: "description", tags: ["file", "document", "text"] }, { name: "bed", tags: ["sleep", "hotel", "rest"] }, { name: "coffee", tags: ["drink", "cup", "cafe"] }, { name: "sports_esports", tags: ["gaming", "controller", "play"] }, { name: "school", tags: ["education", "learn", "student"] }, { name: "celebration", tags: ["party", "event", "confetti"] }, { name: "movie", tags: ["film", "video", "cinema"] }, { name: "music_note", tags: ["sound", "audio", "song"] }, { name: "star", tags: ["favorite", "rating", "special"] }, { name: "sunny", tags: ["weather", "light", "day"] }, { name: "bedtime", tags: ["moon", "night", "dark"] }, { name: "build", tags: ["wrench", "tool", "construct"] }, { name: "fingerprint", tags: ["security", "id", "biometric"] }, { name: "face", tags: ["person", "profile", "user"] }, { name: "verified", tags: ["check", "security", "badge"] }, { name: "support_agent", tags: ["customer service", "help", "headset"] }, { name: "sell", tags: ["tag", "price", "commerce"] }, { name: "store", tags: ["shop", "building", "commerce"] }, { name: "credit_score", tags: ["finance", "money", "rating"] }, { name: "history", tags: ["time", "clock", "rewind"] }, { name: "backup", tags: ["cloud", "upload", "save"] }, { name: "translate", tags: ["language", "words", "international"] }, { name: "sync_alt", tags: ["arrows", "data", "transfer"] }, { name: "record_voice_over", tags: ["speech", "person", "audio"] }, { name: "voice_chat", tags: ["talk", "message", "audio"] }, { name: "location_on", tags: ["pin", "map", "place"] }, { name: "home_repair_service", tags: ["tools", "wrench", "fix"] }, { name: "water_drop", tags: ["liquid", "rain", "aqua"] }, { name: "local_fire_department", tags: ["flame", "hot", "emergency"] }, { name: "flight", tags: ["airplane", "travel", "trip"] }, { name: "directions_car", tags: ["vehicle", "auto", "transportation"] }, { name: "train", tags: ["railway", "subway", "transportation"] }, { name: "local_shipping", tags: ["truck", "delivery", "vehicle"] }, { name: "hotel", tags: ["bed", "sleep", "travel"] }, { name: "local_bar", tags: ["drink", "alcohol", "cocktail"] }, { name: "fitness_center", tags: ["gym", "dumbbell", "workout"] }, { name: "spa", tags: ["wellness", "flower", "relax"] }, { name: "beach_access", tags: ["umbrella", "sand", "summer"] }, { name: "casino", tags: ["dice", "gambling", "game"] }, { name: "child_friendly", tags: ["baby", "stroller", "kid"] }, { name: "photo_album", tags: ["images", "gallery", "book"] }, { name: "camera_alt", tags: ["photo", "picture", "shutter"] }, { name: "control_camera", tags: ["move", "arrows", "position"] }, { name: "linked_camera", tags: ["photo", "sync", "connect"] }, { name: "timer", tags: ["clock", "stopwatch", "time"] }, { name: "audiotrack", tags: ["music", "note", "sound"] }, { name: "playlist_play", tags: ["music", "list", "queue"] }, { name: "album", tags: ["music", "record", "vinyl"] }, { name: "volume_down", tags: ["sound", "audio", "less"] }, { name: "volume_mute", tags: ["sound", "audio", "silent"] }, { name: "subtitles", tags: ["text", "video", "closed captions"] }, { name: "closed_caption", tags: ["cc", "subtitles", "video"] }, { name: "library_music", tags: ["songs", "collection", "audio"] }, { name: "computer", tags: ["desktop", "monitor", "pc"] }, { name: "desktop_windows", tags: ["computer", "monitor", "screen"] }, { name: "phone_iphone", tags: ["mobile", "device", "apple"] }, { name: "smartphone", tags: ["phone", "mobile", "android"] }, { name: "tablet_mac", tags: ["device", "ipad", "apple"] }, { name: "keyboard", tags: ["type", "input", "text"] }, { name: "mouse", tags: ["click", "pointer", "input"] }, { name: "speaker", tags: ["audio", "sound", "stereo"] }, { name: "gamepad", tags: ["controller", "joystick", "play"] }, { name: "watch", tags: ["time", "clock", "smartwatch"] }, { name: "headset_mic", tags: ["gaming", "audio", "support"] }, { name: "memory", tags: ["chip", "processor", "cpu"] }, { name: "router", tags: ["wifi", "internet", "network"] }, { name: "scanner", tags: ["document", "scan", "copy"] }, { name: "security_update_good", tags: ["check", "phone", "safe"] }, { name: "sd_storage", tags: ["card", "memory", "data"] }, { name: "sim_card", tags: ["phone", "mobile", "network"] }, { name: "add_circle", tags: ["plus", "new", "create"] }, { name: "cancel", tags: ["close", "x", "stop"] }, { name: "content_copy", tags: ["duplicate", "file", "clone"] }, { name: "content_cut", tags: ["scissors", "trim", "edit"] }, { name: "content_paste", tags: ["clipboard", "document", "add"] }, { name: "drafts", tags: ["email", "unread", "message"] }, { name: "inbox", tags: ["email", "messages", "mail"] }, { name: "mark_email_read", tags: ["message", "open", "mail"] }, { name: "save", tags: ["disk", "floppy", "document"] }, { name: "sort", tags: ["filter", "order", "arrange"] }, { name: "file_copy", tags: ["duplicate", "document", "clone"] }, { name: "folder_open", tags: ["directory", "files", "storage"] }, { name: "folder_shared", tags: ["directory", "people", "collaboration"] }, { name: "attachment", tags: ["paperclip", "file", "link"] }, { name: "cloud_upload", tags: ["save", "backup", "data"] }, { name: "cloud_download", tags: ["get", "backup", "data"] }, { name: "cloud_done", tags: ["complete", "check", "backup"] }, { name: "grid_view", tags: ["layout", "dashboard", "squares"] }, { name: "view_list", tags: ["layout", "rows", "lines"] }, { name: "view_module", tags: ["layout", "grid", "apps"] }, { name: "view_quilt", tags: ["layout", "grid", "dashboard"] }, { name: "view_stream", tags: ["layout", "list", "rows"] }, { name: "toc", tags: ["table of contents", "list", "menu"] }, { name: "event", tags: ["calendar", "date", "schedule"] }, { name: "date_range", tags: ["calendar", "schedule", "time"] }, { name: "today", tags: ["calendar", "date", "day"] }, { name: "pending", tags: ["clock", "wait", "loading"] }, { name: "published_with_changes", tags: ["sync", "arrows", "approved"] }, { name: "g_translate", tags: ["google", "language", "words"] }, { name: "cookie", tags: ["biscuit", "food", "snack"] }, { name: "icecream", tags: ["dessert", "food", "summer"] }, { name: "cake", tags: ["dessert", "birthday", "party"] }, { name: "local_pizza", tags: ["food", "slice", "italian"] }, { name: "fastfood", tags: ["burger", "fries", "junk"] }, { name: "emoji_emotions", tags: ["smile", "happy", "face"] }, { name: "emoji_events", tags: ["trophy", "winner", "award"] }, { name: "emoji_nature", tags: ["tree", "plant", "forest"] }, { name: "emoji_objects", tags: ["lightbulb", "idea", "stuff"] }, { name: "emoji_people", tags: ["person", "waving", "human"] }, { name: "emoji_symbols", tags: ["music", "heart", "ampersand"] }, { name: "emoji_transportation", tags: ["car", "vehicle", "travel"] }, { name: "sentiment_satisfied", tags: ["happy", "face", "smile"] }], Hs = { "fade-in": { duration: "1s", timing: "forwards", keyframes: "@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }" }, "fade-out": { duration: "1s", timing: "forwards", keyframes: "@keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }" }, bounce: { duration: "1s", timing: "ease", keyframes: "@keyframes bounce { 0%, 20%, 50%, 80%, 100% { transform: translateY(0); } 40% { transform: translateY(-30px); } 60% { transform: translateY(-15px); } }" }, scale: { duration: "1s", timing: "ease", keyframes: "@keyframes scale { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }" }, shake: { duration: "0.82s", timing: "cubic-bezier(.36,.07,.19,.97) both", keyframes: "@keyframes shake { 0% { transform: translate(1px, 1px) rotate(0deg); } 10% { transform: translate(-1px, -2px) rotate(-1deg); } 20% { transform: translate(-3px, 0px) rotate(1deg); } 30% { transform: translate(3px, 2px) rotate(0deg); } 40% { transform: translate(1px, -1px) rotate(1deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); } 60% { transform: translate(-3px, 1px) rotate(0deg); } 70% { translate(3px, 1px) rotate(-1deg); } 80% { transform: translate(-1px, -1px) rotate(1deg); } 90% { transform: translate(1px, 2px) rotate(0deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); } }" }, rotate: { duration: "1s", timing: "linear", keyframes: "@keyframes rotate { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }" }, breathe: { duration: "4s", timing: "ease-in-out", keyframes: "@keyframes breathe { 0% { transform: scale(0.9); } 25% { transform: scale(1); } 50% { transform: scale(0.9); } 75% { transform: scale(1); } 100% { transform: scale(0.9); } }" }, pulse: { duration: "2s", timing: "ease-in-out", keyframes: "@keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }" }, "variable-color": { duration: "5s", timing: "ease-in-out", keyframes: "@keyframes variableColor { 0% { color: #4285F4; } 25% { color: #DB4437; } 50% { color: #F4B400; } 75% { color: #0F9D58; } 100% { color: #4285F4; } }" }, "draw-on": { duration: "1s", timing: "forwards", keyframes: "@keyframes drawOn { from { mask: linear-gradient(to right, #000 0%, #000 0%, transparent 0%, transparent 100%); } to { mask: linear-gradient(to right, #000 0%, #000 100%, transparent 100%, transparent 100%); } }" }, "draw-off": { duration: "1s", timing: "forwards", keyframes: "@keyframes drawOff { from { mask: linear-gradient(to left, #000 0%, #000 0%, transparent 0%, transparent 100%); } to { mask: linear-gradient(to left, #000 0%, #000 100%, transparent 100%, transparent 100%); } }" }, replace: { duration: "1s", timing: "forwards", keyframes: "@keyframes replace { from { clip-path: circle(0% at 50% 50%); } to { clip-path: circle(75% at 50% 50%); } }" } }, g = d => document.querySelector(d), io = d => document.querySelectorAll(d), Vr = io(".nav-item"), Gr = io(".page-container"), Or = g(".app-header"), es = g("#icon-grid"), $n = g(".icon-grid-panel"), so = g("#search-input"), vt = g("#settings-panel"), Bs = g("#settings-close-btn"), Hr = g("#settings-title"), Br = g("#settings-preview-icon"), Ai = g("#convert-to-3d-btn"), xi = g("#generated-image"), Ao = g("#loader"), ts = g("#prompt-display-3d"), qn = g("#prompt-input-3d"), Js = g("#id-3d-placeholder"), xo = g("#id-3d-error-placeholder"), Jr = g("#download-3d-btn"), ns = g("#regenerate-3d-btn"), uu = g("#view-larger-btn"), Ws = g("#toggle-filters-panel-btn"), ko = g("#page-icons"), zs = g("#filters-close-btn"), Mt = g(".filters-panel"), fu = new Set(["page-usages", "page-icons"]), Ro = () => { if (!Or) return; const d = fu.has(re); Or.classList.toggle("header-transparent", d) }; Ro(); const os = g("#image-generate-btn"), ao = g("#image-prompt-subject-input"), Do = g("#image-prompt-display"), hn = g("#result-idle-placeholder"), Ys = g("#page-id-3d .result-placeholder"), tt = g("#page-id-3d .result-image"), ro = g("#page-id-3d .result-video"), Ks = g("#page-id-3d .result-error"), Wr = async () => {
    const d = document.getElementById("animated-samples-container"), m = document.getElementById("result-idle-placeholder"); if (!(!d || !m)) try {
      const y = await fetch("/assets_3d_images.json"); if (!y.ok) throw new Error("Failed to load assets list"); const h = await y.json(); if (h.length === 0) { console.warn("No assets images found"); return } d.innerHTML = ""; const C = document.getElementById("dynamic-placeholder-animations"); C && C.remove(); const E = h.filter((q, te) => te !== 2), b = 1, w = 1, S = E.length * (b + w * 2); d.style.animation = ""; const I = document.createElement("style"); I.id = "dynamic-placeholder-animations", document.head.appendChild(I); const A = q => new Promise((te, Y) => { const Q = new Image; Q.onload = () => te(Q), Q.onerror = () => Y(new Error(`Failed to load: ${q}`)), Q.src = q }), L = []; await Promise.allSettled(E.map(async (q, te) => { try { const Y = await A(q.url); L.push({ img: Y, asset: q, index: te }) } catch { console.warn(`Skipping image that failed to load: ${q.url}`) } })); const x = ["Design without design tools.", "Create 2D, 3D, and motion with one prompt.", "AI that builds your visuals for you.", "Create more. Think less"], _ = 1, M = .8, F = b + w * 2, U = _ + M * 2, Z = w, J = []; for (let q = 0; q < L.length; q++)if (q === 0) J.push(0); else { const Q = J[q - 1] + w + b + M + _ + M / 2; J.push(Q) } const O = J[J.length - 1] + w + b + U; L.forEach(({ img: q, asset: te, index: Y }, Q) => {
        q.alt = "preview", q.className = "sample-preview-img"; const H = J[Q], ee = H + w + b, pe = H / O * 100, se = (H + w) / O * 100, me = (H + w + b) / O * 100, Le = (H + w + b + w) / O * 100, ge = ee / O * 100, he = (ee + M) / O * 100, oe = (ee + M + _) / O * 100, De = (ee + M + _ + M) / O * 100, ze = `fadeInOut-${Y}`, je = `fadeInOut-text-${Y}`, be = `
          @keyframes ${ze} {
            0%, ${pe}% {
              opacity: 0;
              transform: translate(-50%, -50%) scale(0.8);
            }
            ${se}%, ${me}% {
              opacity: 0.2;
              transform: translate(-50%, -50%) scale(1);
            }
            ${Le}%, 100% {
              opacity: 0;
              transform: translate(-50%, -50%) scale(0.8);
            }
          }
        `, et = `
          @keyframes ${je} {
            0%, ${ge}% {
              opacity: 0;
            }
            ${he}%, ${oe}% {
              opacity: 0.4;
            }
            ${De}%, 100% {
              opacity: 0;
            }
          }
        `; I.textContent += be + et, q.style.cssText = `
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          width: 480px;
          height: 480px;
          object-fit: contain;
          border-radius: 16px;
          filter: none;
          background: transparent;
          opacity: 0;
          animation: ${ze} ${O}s ease-in-out infinite;
        `, q.addEventListener("mouseenter", () => { q.style.opacity = "1" }), q.addEventListener("mouseleave", () => { q.style.opacity = "" }); const Qe = document.createElement("div"); Qe.className = "placeholder-text-message", Qe.textContent = x[Q % x.length], Qe.style.cssText = `
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          font-size: 18px;
          font-weight: 600;
          color: var(--text-secondary);
          opacity: 0;
          animation: ${je} ${O}s ease-in-out infinite;
          white-space: nowrap;
        `, d.appendChild(q), d.appendChild(Qe)
      })
    } catch (y) { console.error("Failed to initialize placeholder images:", y), d && (d.innerHTML = "") }
  }, Xs = g("#page-id-3d"); Xs && (new MutationObserver(m => { m.forEach(y => { y.type === "attributes" && y.attributeName === "class" && (y.target.classList.contains("hidden") || Wr()) }) }).observe(Xs, { attributes: !0, attributeFilter: ["class"] }), Xs.classList.contains("hidden") || setTimeout(Wr, 100)), g("#retry-generate-btn"); const Zs = g("#page-id-3d .history-panel"), Qs = g("#history-list"), ki = g("#history-back-btn"), Ri = g("#history-forward-btn"), zr = g("#history-counter"), Vn = g("#page-id-3d .result-item-content .result-content-header"), fe = g("#image-details-panel"), js = g("#details-close-btn"), is = g("#details-preview-image"), No = g("#details-download-btn"); g("#details-copy-btn"), g("#details-delete-btn"); const Po = g("#details-upscale-btn"), Gn = g("#details-fix-btn"), On = g("#details-background-color-picker-3d"), Hn = g("#details-object-color-picker-3d"), Di = g("#shadow-toggle-icons"), Mo = g("#shadow-toggle-3d"), ea = g("#toggle-details-panel-btn"), yn = g('#page-id-3d .preview-switcher .preview-tab-item[data-tab="image"]'), Ft = g('#page-id-3d .preview-switcher .preview-tab-item[data-tab="video"]'), Fo = g("#motion-prompt-placeholder"), ta = g("#details-more-menu-btn"), vn = g("#details-more-menu"), na = g("#details-more-upscale"), oa = g("#details-more-copy"), ia = g("#details-more-delete"), ss = g("#p2d-image-generate-btn"), on = g("#p2d-image-prompt-subject-input"), Ni = g("#p2d-image-prompt-display"), Tn = g("#p2d-result-idle-placeholder"), sa = g("#page-id-2d .result-placeholder"), Ce = g("#page-id-2d .result-image"), Pe = g("#p2d-result-video"), aa = g("#page-id-2d .result-error"); g("#p2d-retry-generate-btn"); const as = g("#page-id-2d .history-panel"), Se = g("#p2d-motion-prompt-placeholder"), lt = g("#p2d-preview-tab-image"), We = g("#p2d-preview-tab-motion"), ra = g("#p2d-generate-motion-from-preview-btn"), Yr = async () => {
    const d = document.getElementById("p2d-animated-samples-container"), m = document.getElementById("p2d-result-idle-placeholder"); if (!(!d || !m)) try {
      const y = await fetch("/assets_2d_images.json"); if (!y.ok) throw new Error("Failed to load assets list"); const h = await y.json(); if (h.length === 0) { console.warn("No assets images found"); return } d.innerHTML = ""; const C = document.getElementById("dynamic-placeholder-animations-2d"); C && C.remove(); const E = h, b = 1, w = 1, S = E.length * (b + w * 2); d.style.animation = ""; const I = document.createElement("style"); I.id = "dynamic-placeholder-animations-2d", document.head.appendChild(I); const A = q => new Promise((te, Y) => { const Q = new Image; Q.onload = () => te(Q), Q.onerror = () => Y(new Error(`Failed to load: ${q}`)), Q.src = q }), L = []; await Promise.allSettled(E.map(async (q, te) => { try { const Y = await A(q.url); L.push({ img: Y, asset: q, index: te }) } catch { console.warn(`Skipping image that failed to load: ${q.url}`) } })); const x = ["Design without design tools.", "Create 2D, 3D, and motion with one prompt.", "AI that builds your visuals for you.", "Create more. Think less"], _ = 1, M = .8, F = b + w * 2, U = _ + M * 2, Z = w, J = []; for (let q = 0; q < L.length; q++)if (q === 0) J.push(0); else { const Q = J[q - 1] + w + b + M + _ + M / 2; J.push(Q) } const O = J[J.length - 1] + w + b + U; L.forEach(({ img: q, asset: te, index: Y }, Q) => {
        q.alt = "preview", q.className = "sample-preview-img"; const H = J[Q], ee = H + w + b, pe = H / O * 100, se = (H + w) / O * 100, me = (H + w + b) / O * 100, Le = (H + w + b + w) / O * 100, ge = ee / O * 100, he = (ee + M) / O * 100, oe = (ee + M + _) / O * 100, De = (ee + M + _ + M) / O * 100, ze = `fadeInOut-2d-${Y}`, je = `fadeInOut-text-2d-${Y}`, be = `
          @keyframes ${ze} {
            0%, ${pe}% {
              opacity: 0;
              transform: translate(-50%, -50%) scale(0.8);
            }
            ${se}%, ${me}% {
              opacity: 0.2;
              transform: translate(-50%, -50%) scale(1);
            }
            ${Le}%, 100% {
              opacity: 0;
              transform: translate(-50%, -50%) scale(0.8);
            }
          }
        `, et = `
          @keyframes ${je} {
            0%, ${ge}% {
              opacity: 0;
            }
            ${he}%, ${oe}% {
              opacity: 0.4;
            }
            ${De}%, 100% {
              opacity: 0;
            }
          }
        `; I.textContent += be + et, q.style.cssText = `
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          width: 320px;
          height: 320px;
          object-fit: contain;
          border-radius: 16px;
          filter: none;
          background: transparent;
          opacity: 0;
          animation: ${ze} ${O}s ease-in-out infinite;
        `, q.addEventListener("mouseenter", () => { q.style.opacity = "1" }), q.addEventListener("mouseleave", () => { q.style.opacity = "" }); const Qe = document.createElement("div"); Qe.className = "placeholder-text-message", Qe.textContent = x[Q % x.length], Qe.style.cssText = `
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          font-size: 18px;
          font-weight: 600;
          color: var(--text-secondary);
          opacity: 0;
          animation: ${je} ${O}s ease-in-out infinite;
          white-space: nowrap;
        `, d.appendChild(q), d.appendChild(Qe)
      })
    } catch (y) { console.error("Failed to initialize 2D placeholder images:", y), d && (d.innerHTML = "") }
  }, Kr = async () => {
    const d = document.getElementById("animated-samples-container-image"), m = document.getElementById("result-idle-placeholder-image"), y = document.querySelector(".result-content-header-image"); if (!(!d || !m)) {
      y && !V ? y.classList.add("hidden") : y && V && y.classList.remove("hidden"); try {
        const C = ["1.png", "2.png", "3.png"].map((B, O) => ({ url: `/assets/image/${B}`, name: B })); if (C.length === 0) { console.warn("No image assets found"); return } d.innerHTML = ""; const E = document.getElementById("dynamic-placeholder-animations-image"); E && E.remove(); const b = 1, w = 1, S = C.length * (b + w * 2); d.style.animation = ""; const I = document.createElement("style"); I.id = "dynamic-placeholder-animations-image", document.head.appendChild(I); const A = B => new Promise((O, q) => { const te = new Image; te.onload = () => O(te), te.onerror = () => q(new Error(`Failed to load: ${B}`)), te.src = B }), L = []; await Promise.allSettled(C.map(async (B, O) => { try { const q = await A(B.url); L.push({ img: q, asset: B, index: O }) } catch { console.warn(`Skipping image that failed to load: ${B.url}`) } })); const x = ["Design without design tools.", "Create 2D, 3D, and motion with one prompt.", "AI that builds your visuals for you.", "Create more. Think less"], _ = 1, M = .8, F = b + w * 2, U = _ + M * 2, Z = w, J = F + U - Z, z = L.length * J; L.forEach(({ img: B, asset: O, index: q }, te) => {
          B.alt = "preview", B.className = "sample-preview-img"; const Q = te * J, H = Q + w + b, ee = Q / z * 100, pe = (Q + w) / z * 100, se = (Q + w + b) / z * 100, me = (Q + w + b + w) / z * 100, Le = H / z * 100, ge = (H + M) / z * 100, he = (H + M + _) / z * 100, oe = (H + M + _ + M) / z * 100, De = `fadeInOut-image-${q}`, ze = `fadeInOut-text-image-${q}`, je = `
          @keyframes ${De} {
            0%, ${ee}% {
              opacity: 0;
              transform: translate(-50%, -50%) scale(0.8);
            }
            ${pe}%, ${se}% {
              opacity: 0.2;
              transform: translate(-50%, -50%) scale(1);
            }
            ${me}%, 100% {
              opacity: 0;
              transform: translate(-50%, -50%) scale(0.8);
            }
          }
        `, be = `
          @keyframes ${ze} {
            0%, ${Le}% {
              opacity: 0;
            }
            ${ge}%, ${he}% {
              opacity: 0.4;
            }
            ${oe}%, 100% {
              opacity: 0;
            }
          }
        `; I.textContent += je + be, B.style.cssText = `
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          width: 320px;
          height: 320px;
          object-fit: contain;
          border-radius: 16px;
          filter: none;
          background: transparent;
          opacity: 0;
          animation: ${De} ${z}s ease-in-out infinite;
        `, B.addEventListener("mouseenter", () => { B.style.opacity = "1" }), B.addEventListener("mouseleave", () => { B.style.opacity = "" }); const et = document.createElement("div"); et.className = "placeholder-text-message", et.textContent = x[te % x.length], et.style.cssText = `
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          font-size: 18px;
          font-weight: 600;
          color: var(--text-secondary);
          opacity: 0;
          animation: ${ze} ${z}s ease-in-out infinite;
          white-space: nowrap;
        `, d.appendChild(B), d.appendChild(et)
        })
      } catch (h) { console.error("Failed to initialize Image Studio placeholder images:", h), d && (d.innerHTML = "") }
    }
  }, la = g("#page-id-2d"); la && (new MutationObserver(m => { m.forEach(y => { y.type === "attributes" && y.attributeName === "class" && (y.target.classList.contains("hidden") || Yr()) }) }).observe(la, { attributes: !0, attributeFilter: ["class"] }), la.classList.contains("hidden") || setTimeout(Yr, 100)); const da = g("#page-image"); da && (new MutationObserver(m => { m.forEach(y => { y.type === "attributes" && y.attributeName === "class" && (y.target.classList.contains("hidden") || Kr()) }) }).observe(da, { attributes: !0, attributeFilter: ["class"] }), da.classList.contains("hidden") || setTimeout(Kr, 100)); const ca = g("#p2d-history-list"), Uo = g("#p2d-history-back-btn"), $o = g("#p2d-history-forward-btn"), ua = g("#p2d-history-counter"), Bn = g("#page-id-2d .result-item-content .result-content-header"), ve = g("#p2d-image-details-panel"), fa = g("#p2d-details-close-btn"), Jn = g("#p2d-details-preview-image"), ot = g("#p2d-download-png-btn"), rs = g("#p2d-download-svg-btn"), qo = g("#p2d-details-copy-btn"), Vo = g("#p2d-details-delete-btn"), pa = g("#p2d-toggle-details-panel-btn"), ma = g('#p2d-image-details-panel .tab-item[data-tab="motion"]'), Xr = g("#p2d-motion-thumbnail-image"), Zr = g("#p2d-motion-thumbnail-label"), lo = g("#p2d-motion-video-container"), Pi = g("#p2d-motion-video-player"); g("#p2d-motion-video-loader"); const ga = g("#p2d-motion-prompt-output"), ft = g("#p2d-motion-prompt-final-english"), ha = g("#p2d-motion-prompt-korean"); g("#p2d-motion-gen-status-text"); const co = g("#p2d-generate-motion-prompt-btn"), sn = g("#p2d-regenerate-motion-prompt-btn"), En = g("#p2d-generate-video-btn"), Ut = g("#p2d-regenerate-video-btn"), $t = g("#p2d-motion-more-menu-btn"), Ve = g("#p2d-motion-more-menu"), ya = g("#p2d-motion-more-regenerate-prompt"), va = g("#p2d-motion-more-regenerate-video"), Go = g(".p2d-motion-actions .download-buttons-row"), Oo = g("#p2d-download-video-btn"), Ho = g("#p2d-download-gif-btn"), Wn = g("#p2d-convert-to-gif-btn"), Bo = g("#p2d-convert-to-webm-btn"), Jo = g("#p2d-convert-to-webp-btn"), Wo = g("#p2d-download-webm-btn"), zo = g("#p2d-download-webp-btn"); g("#p2d-motion-reference-image-input"), g("#p2d-motion-reference-image-container"), g('#image-details-panel .tab-item[data-tab="motion"]'), g('#image-details-panel .details-tab-content[data-tab-content="motion"]'); const Yt = g("#motion-preview-icon"), Qr = g("#motion-thumbnail-image"), jr = g("#motion-thumbnail-label"), Yo = g("#motion-animation-select"), Ko = g("#motion-repeat-select"), Xo = g("#motion-video-container"), Ta = g("#motion-video-player"); g("#motion-video-loader"); const uo = g("#generate-motion-prompt-btn"), an = g("#regenerate-motion-prompt-btn"), bn = g("#generate-video-btn"), qt = g("#regenerate-video-btn"), ls = g("#download-video-btn"), Zo = g("#motion-download-row"), Ea = g("#motion-more-menu-btn"), Cn = g("#motion-more-menu"), ba = g("#motion-more-regenerate-prompt"), Ca = g("#motion-more-regenerate-video"), wa = g("#motion-prompt-output"); g("#motion-gen-status-text"); const Ia = g("#motion-play-btn"), Sa = g("#generate-motion-from-preview-btn"), La = g("#convert-to-lottie-btn"), _a = d => { var E, b, w, S; if (!d) return console.error("[extractVideoDownloadUrl] Operation is null or undefined"), null; console.log("[extractVideoDownloadUrl] Full operation object:", JSON.stringify(d, null, 2)); let m = null; if ((b = (E = d.response) == null ? void 0 : E.generatedVideos) != null && b[0] ? (m = d.response.generatedVideos[0], console.log("[extractVideoDownloadUrl] Found video via operation.response.generatedVideos[0]")) : (w = d.generatedVideos) != null && w[0] ? (m = d.generatedVideos[0], console.log("[extractVideoDownloadUrl] Found video via operation.generatedVideos[0]")) : (S = d.response) != null && S.video ? (m = d.response.video, console.log("[extractVideoDownloadUrl] Found video via operation.response.video")) : d.video ? (m = d.video, console.log("[extractVideoDownloadUrl] Found video via operation.video")) : d.response && typeof d.response == "object" && (m = d.response, console.log("[extractVideoDownloadUrl] Using operation.response as video entry")), !m) return console.error("[extractVideoDownloadUrl] No video entry found in operation"), console.error("[extractVideoDownloadUrl] Available keys:", Object.keys(d)), d.response && console.error("[extractVideoDownloadUrl] Response keys:", Object.keys(d.response)), null; console.log("[extractVideoDownloadUrl] Video entry:", JSON.stringify(m, null, 2)); const y = m.video ?? m, h = [y.downloadUri, y.uri, y.url, y.signedUri, y.downloadUrl, y.videoUri, m.videoUri, m.uri, m.downloadUri, m.url, m.downloadUrl, m.signedUri]; if (y.uris && Array.isArray(y.uris) && h.push(...y.uris), m.uris && Array.isArray(m.uris) && h.push(...m.uris), m.video) { const I = m.video; h.push(I.downloadUri, I.uri, I.url, I.signedUri, I.downloadUrl) } console.log("[extractVideoDownloadUrl] Candidates:", h); const C = h.find(I => typeof I == "string" && I.length > 0); return C ? (console.log("[extractVideoDownloadUrl] Found valid URL:", C), C) : (console.error("[extractVideoDownloadUrl] No valid URL found in candidates"), null) }; g("#image-modal"), g("#image-modal-view"), g("#image-modal-close-btn"), g("#image-modal-regenerate-btn"), g("#image-modal-download-btn"); const ke = g("#motion-category-modal"), nt = g("#motion-category-list"), Aa = g("#motion-category-close-btn"), Kt = g('#result-item-main-image .preview-tab-item[data-tab="image"]'), Xt = g('#result-item-main-image .preview-tab-item[data-tab="motion"]'), Vt = g("#motion-prompt-placeholder-image"), wn = g("#result-image-image"), Zt = g("#result-video-image"), el = g("#motion-thumbnail-image-image"), tl = g("#motion-thumbnail-label-image"), fo = g("#generate-motion-prompt-btn-image"), rn = g("#regenerate-motion-prompt-btn-image"), In = g("#generate-video-btn-image"), Gt = g("#regenerate-video-btn-image"), po = g("#download-video-btn-image"), Mi = g("#motion-more-menu-btn-image"), Tt = g("#motion-more-menu-image"), xa = g("#motion-more-regenerate-prompt-image"), ka = g("#motion-more-regenerate-video-image"), Ra = g("#motion-download-row-image"), Sn = g("#image-details-panel-image"), Da = g('#image-details-panel-image .tab-item[data-tab="detail"]'), Qo = g('#image-details-panel-image .tab-item[data-tab="motion"]'), Na = g("#generate-motion-from-preview-btn-image"), X = g("#image-generation-loader-modal"), _t = g("#image-generation-loader-text"), Et = g("#video-generation-loader-modal"), jo = g("#video-loader-message"), we = g("#p2d-loader-modal"), Ue = g("#p2d-loader-message"), ei = g("#main-generation-loader-modal"), ds = g("#main-generation-loader-text"), Fi = g("#p2d-revert-background-btn"), Pa = g("#p2d-preview-result-btn"), Ma = g("#p2d-compare-btn"); g("#p2d-copy-svg-btn"); const cs = g("#p2d-svg-preview-modal"), zn = g("#p2d-compare-modal"); g("#page-usages"); const us = g(".explore-main"); g("#main-reference-container"); const Oe = g("#main-reference-drop-zone"), Fa = g("#main-generate-with-text-btn"), Ua = g("#main-attach-image-btn"), mo = g("#main-remove-reference-btn"), ln = g("#explore-feed"), Ot = g("#explore-details-modal"), $a = g("#explore-details-close-btn"), nl = g("#explore-details-title"), qa = g("#explore-details-preview-container"), ol = g("#explore-details-info"), ti = g("#explore-details-prompt"), il = g("#explore-details-prompt-code"), ni = g("#explore-details-no-prompt"), Va = g("#explore-details-download-btn"), oi = g("#explore-upload-input"); g("#explore-search-input"); const Ga = g("#explore-upload-btn"); g("#explore-content-modal-overlay"), g("#explore-content-modal-title"), g("#explore-content-modal-view-container"), g("#explore-content-modal-close-btn"), g("#explore-content-modal-delete-btn"), g("#explore-content-modal-download-btn"); const Ln = g("#upload-choice-modal"), Oa = g("#upload-choice-close-btn"), Ha = g("#upload-from-device-btn"); g("#rename-modal-overlay"), g("#rename-modal-form"), g("#rename-modal-input"), g("#rename-modal-cancel"); const fs = g("#download-svg-btn"), ps = g("#download-png-btn"), Yn = g("#color-picker"), ii = g("#snippet-tabs"), sl = io("#snippet-tabs .snippet-tab-item"), si = g("#snippet-code"), ms = g("#copy-snippet-btn"), gs = g(".settings-footer"), Qt = d => { if (!d) return; const m = d.closest(".color-input"), y = m == null ? void 0 : m.querySelector(".color-value"); y && (y.textContent = d.value.toUpperCase()) }, pu = () => { document.querySelectorAll('.color-input input[type="color"]').forEach(m => { const y = () => Qt(m); y(), m.addEventListener("input", y), m.addEventListener("change", y) }) }, hs = () => { try { localStorage.setItem("imageLibrary", JSON.stringify(yt)) } catch (d) { console.error("Failed to save image library to localStorage", d) } }, mu = () => { try { const d = localStorage.getItem("imageLibrary"); d && (yt = JSON.parse(d)) } catch (d) { console.error("Failed to load image library from localStorage", d), yt = [] } }, Ui = () => {
    const d = (m, y, h, C) => {
      !m || !y || (m.innerHTML = "", yt.length === 0 ? y.classList.remove("hidden") : (y.classList.add("hidden"), yt.forEach((E, b) => {
        const w = document.createElement("div"); w.className = "library-item", w.dataset.id = E.id, w.title = "Click to add to an empty reference slot", w.innerHTML = `
            <img src="${E.dataUrl}" alt="Saved image ${b + 1}" class="library-item-img">
            <button class="library-item-delete-btn icon-button" aria-label="Delete image ${b + 1}">
              <span class="material-symbols-outlined">delete</span>
            </button>
          `; const S = w.querySelector(".library-item-delete-btn"); S == null || S.addEventListener("click", I => { I.stopPropagation(), yt.splice(b, 1), hs(), Ui(), G({ type: "success", title: "Deleted", body: "Image removed from library." }) }), w.addEventListener("click", () => { const I = g(C), A = h.findIndex(L => L === null); A !== -1 && I ? fetch(E.dataUrl).then(L => L.blob()).then(L => { const x = new File([L], `library_ref_${E.id}.${E.mimeType.split("/")[1] || "png"}`, { type: E.mimeType }), _ = I.querySelector(`.image-drop-zone[data-index="${A}"]`); _ && (ar(x, _, h), G({ type: "success", title: "Image Added", body: "Image added as a reference." })) }) : G({ type: "error", title: "No Empty Slots", body: "All reference image slots are full." }) }), m.appendChild(w)
      })))
    }; d(g("#image-library-list"), g("#image-library-placeholder"), P, "#edit-reference-image-container-3d"), d(g("#p2d-image-library-list"), g("#p2d-image-library-placeholder"), R, "#p2d-edit-reference-image-container-3d")
  }, $i = d => { if (!d) return; const m = d.querySelectorAll(".tab-item"), y = d.querySelectorAll(".tab-content, .details-tab-content"); m.forEach(h => { h.addEventListener("click", () => { const C = h.dataset.tab; if (m.forEach(E => E.classList.remove("active")), h.classList.add("active"), y.forEach(E => { const b = E.dataset.tabContent || E.dataset.tab; E.classList.toggle("hidden", b !== C), E.classList.toggle("active", b === C) }), d.id === "image-details-panel" && C === "history") { console.log("[3D Studio] History tab clicked via setupTabs"), console.log("[3D Studio] Current image:", n), console.log("[3D Studio] History count before init:", v.length), console.log("[3D Studio] History items:", v); const E = document.querySelector("#result-item-main"); if (E) { const b = E.querySelector('.preview-tab-item[data-tab="image"]'), w = E.querySelector('.preview-tab-item[data-tab="video"]'); if (b) { b.classList.add("active"), w && w.classList.remove("active"); const S = g("#result-image"), I = g("#result-video"), A = g("#result-idle-placeholder"), L = g("#motion-prompt-placeholder"); S && S.classList.remove("hidden"), I && I.classList.add("hidden"), A && A.classList.add("hidden"), L && L.classList.add("hidden") } } v.length === 0 && n && (console.log("[3D Studio] History is empty, initializing with current image"), Zn(n), console.log("[3D Studio] History after init:", v)), setTimeout(() => { var w; console.log("[3D Studio] Force update history (0ms) - tab should be visible now"); const b = (w = document.getElementById("3d-details-history-list")) == null ? void 0 : w.closest('.details-tab-content[data-tab-content="history"]'); console.log("[3D Studio] Tab visible check:", b ? !b.classList.contains("hidden") : "tab not found"), jt() }, 0), setTimeout(() => { console.log("[3D Studio] Force update history (50ms)"), jt() }, 50), setTimeout(() => { console.log("[3D Studio] Force update history (100ms)"), jt() }, 100), setTimeout(() => { console.log("[3D Studio] Force update history (300ms)"), jt() }, 300), setTimeout(() => { console.log("[3D Studio] Force update history (500ms)"), jt() }, 500) } if (d.id === "image-details-panel") { if (C === "detail") { const E = document.querySelector("#result-item-main"); if (E) { const b = E.querySelector('.preview-tab-item[data-tab="image"]'), w = E.querySelector('.preview-tab-item[data-tab="video"]'); if (b) { b.classList.add("active"), w && w.classList.remove("active"); const S = g("#result-image"), I = g("#result-video"), A = g("#result-idle-placeholder"), L = g("#motion-prompt-placeholder"); S && (S.classList.remove("hidden"), setTimeout(() => S.classList.add("visible"), 50)), I && I.classList.add("hidden"), A && A.classList.add("hidden"), L && L.classList.add("hidden") } } } else if (C === "motion") { const E = document.querySelector("#result-item-main"); if (E) { const b = E.querySelector('.preview-tab-item[data-tab="image"]'), w = E.querySelector('.preview-tab-item[data-tab="video"]'); if (w) { w.classList.add("active"), b && b.classList.remove("active"); const S = E.querySelector(".result-content-header"); S && S.classList.remove("hidden"); const I = g("#result-image"), A = g("#result-video"), L = g("#result-idle-placeholder"), x = g("#motion-prompt-placeholder"); I && (I.classList.add("hidden"), I.classList.remove("visible")), n && n.videoDataUrl ? (A && (A.src = n.videoDataUrl, A.classList.remove("hidden")), x && x.classList.add("hidden")) : (A && A.classList.add("hidden"), x && (x.classList.remove("hidden"), x.style.display = "flex", x.style.position = "absolute", x.style.inset = "0", x.style.zIndex = "2")), L && L.classList.add("hidden") } } } } if (d.id === "p2d-image-details-panel" && C === "history") { if (console.log("[2D Studio] History tab clicked via setupTabs"), console.log("[2D Studio] Current image:", a), console.log("[2D Studio] History count before init:", u.length), console.log("[2D Studio] History items:", u), lt && a) { lt.classList.add("active"), We == null || We.classList.remove("active"); const E = g("#p2d-result-image"), b = g("#p2d-result-video"), w = g("#p2d-motion-prompt-placeholder"); E && E.classList.remove("hidden"), b && b.classList.add("hidden"), w && w.classList.add("hidden") } u.length === 0 && a && (console.log("[2D Studio] History is empty, initializing with current image"), Xn(a), console.log("[2D Studio] History after init:", u)), setTimeout(() => { var b; console.log("[2D Studio] Force update history (0ms) - tab should be visible now"); const E = (b = g("#p2d-details-history-list")) == null ? void 0 : b.closest('.details-tab-content[data-tab-content="history"]'); console.log("[2D Studio] Tab visible check:", E ? !E.classList.contains("hidden") : "tab not found"), At() }, 0), setTimeout(() => { console.log("[2D Studio] Force update history (50ms)"), At() }, 50), setTimeout(() => { console.log("[2D Studio] Force update history (100ms)"), At() }, 100), setTimeout(() => { console.log("[2D Studio] Force update history (300ms)"), At() }, 300), setTimeout(() => { console.log("[2D Studio] Force update history (500ms)"), At() }, 500) } if (d.id === "image-details-panel-image") { if (C === "detail") Kt && V && Kt.click(); else if (C === "motion") Xt && V && Xt.click(); else if (C === "history" && Kt && V) { Kt.classList.add("active"), Xt == null || Xt.classList.remove("active"); const E = g("#result-image-image"), b = g("#result-video-image"), w = g("#motion-prompt-placeholder-image"); E && E.classList.remove("hidden"), b && b.classList.add("hidden"), w && w.classList.add("hidden") } } d.id === "p2d-image-details-panel" && (C === "motion" ? We && !We.classList.contains("active") && We.click() : C === "detail" && lt && !lt.classList.contains("active") && lt.click()), d.id === "settings-panel" && gs && gs.classList.toggle("hidden", C !== "details") }) }) }, G = d => { const m = g("#banner-toast"), y = g("#banner-toast-icon"), h = g("#banner-toast-title"), C = g("#banner-toast-body"); if (!(!m || !y || !h || !C)) { if (Li && clearTimeout(Li), d.type === "success") { m.classList.add("hidden"); return } m.className = "banner-toast", m.classList.add(d.type), m.classList.remove("hidden"), y.textContent = d.type === "success" ? "check_circle" : "error", h.textContent = d.title, C.textContent = d.body, Li = window.setTimeout(() => { m.classList.add("hidden") }, d.duration || 5e3) } }, _n = d => { var b; const m = window.confetti; if (!m) { console.warn("canvas-confetti not loaded"); return } const y = document.querySelector('canvas[style*="position: fixed"]'); y && (y.style.zIndex = "10000"); let h = .5, C = .5; if (d) { const w = d.getBoundingClientRect(), S = window.innerWidth, I = window.innerHeight, A = (b = d.querySelector(".loader")) == null ? void 0 : b.parentElement; if (A) { const L = A.getBoundingClientRect(); h = L.left / S + L.width / 2 / S, C = L.top / I + L.height / 2 / I } else h = w.left / S + w.width / 2 / S, C = w.top / I + w.height / 2 / I } const E = { spread: 180, ticks: 200, gravity: 1, decay: .94, startVelocity: 30, colors: ["#FFFFFF", "#2962FF"], origin: { x: h, y: C }, shapes: ["circle"] }; m({ ...E, particleCount: 250, scalar: .6 }), m({ ...E, particleCount: 200, scalar: .5 }), m({ ...E, particleCount: 150, scalar: .4 }), setTimeout(() => { const w = document.querySelector('canvas[style*="position: fixed"]'); w && (w.style.zIndex = "10000") }, 10) }, qi = d => { var h, C; if (!d) return; const m = (h = d.querySelector(".loader")) == null ? void 0 : h.parentElement, y = d.querySelector(".loader"); if (m && y) { m.querySelectorAll('div[style*="border-radius: 50%"]').forEach(w => w.remove()), y.classList.remove("hidden"); const b = d.querySelector('p[id*="loader"], h3'); b && (b.textContent = ((C = b.textContent) == null ? void 0 : C.replace("Complete", "")) || "", b.style.color = "", b.style.fontWeight = "") } }, Re = (d, m) => { d && (d.classList.toggle("loading", m), d.disabled = m) }, Dt = d => new Promise((m, y) => { const h = new FileReader; h.onloadend = () => { typeof h.result == "string" ? m(h.result.split(",")[1]) : y(new Error("Failed to convert blob to base64")) }, h.onerror = y, h.readAsDataURL(d) }), gu = d => new Promise((m, y) => { const h = new Image; h.onload = () => { const C = h.naturalWidth || h.width, E = h.naturalHeight || h.height; if (!C || !E) { y(new Error("Invalid image dimensions")); return } m({ width: C, height: E }) }, h.onerror = () => y(new Error("Failed to load image dimensions")), h.src = d }), hu = (d, m) => { if (!d || !m) return null; const y = (b, w) => w === 0 ? b : y(w, b % w), h = Math.round(d), C = Math.round(m); if (h <= 0 || C <= 0) return null; const E = y(h, C); return E ? `${Math.round(h / E)}:${Math.round(C / E)}` : null }, yu = (d, m) => ({ id: d.id, data: d.data, mimeType: d.mimeType, subject: d.subject, styleConstraints: d.styleConstraints, timestamp: d.timestamp, modificationType: m }), vu = () => { if (V) if (!V.rightPanelHistory || V.rightPanelHistory.length === 0) V.rightPanelHistory = [yu(V, "Original")]; else { const d = V.rightPanelHistory[0]; d && (d.modificationType = "Original", d.id = V.id) } }, al = d => { if (V) if (vu(), V.rightPanelHistory || (V.rightPanelHistory = []), V.rightPanelHistory.push(d), V.data = d.data, V.mimeType = d.mimeType, V.timestamp = d.timestamp, V.modificationType = "Original", Ie !== -1 && _e[Ie]) _e[Ie] = V; else { const m = _e.findIndex(y => y.id === V.id); m !== -1 && (_e[m] = V, Ie = m) } }, rl = () => { let d = !1; for (let m = _e.length - 1; m >= 0; m--) { const y = _e[m]; y && y.modificationType && y.modificationType !== "Original" && (_e.splice(m, 1), d = !0, Ie > m ? Ie-- : Ie === m && (Ie = Math.max(0, Ie - 1))) } return _e.length === 0 ? (V = null, Ie = -1) : Ie >= _e.length && (Ie = _e.length - 1), d }, ll = d => { d.preventDefault(); const y = d.currentTarget.dataset.page; if (!y || y === re) return; if (Vr.forEach(C => { C.classList.toggle("active", C.dataset.page === y) }), document.querySelectorAll(".bottom-nav-item").forEach(C => { const E = C.dataset.page; C.classList.toggle("active", E === y) }), Gr.forEach(C => { C.classList.toggle("hidden", C.id !== y) }), re = y, Ro(), y === "page-image") { const C = document.querySelector(".result-content-header-image"); C && V && C.classList.remove("hidden") } typeof window.updateHomePlaceholders == "function" && window.updateHomePlaceholders(), Ba(), setTimeout(() => { typeof pn == "function" && pn() }, 100) }, An = g("#mobile-menu-toggle"), go = g("#main-nav"), ho = g("#mobile-menu-backdrop"), Tu = () => { if (go && go.classList.add("mobile-menu-open"), ho && ho.classList.add("active"), An) { An.setAttribute("aria-expanded", "true"); const d = An.querySelector(".material-symbols-outlined"); d && (d.textContent = "close") } document.body.classList.add("no-scroll") }, Ba = () => { if (go && go.classList.remove("mobile-menu-open"), ho && ho.classList.remove("active"), An) { An.setAttribute("aria-expanded", "false"); const d = An.querySelector(".material-symbols-outlined"); d && (d.textContent = "menu") } document.body.classList.remove("no-scroll") }; An == null || An.addEventListener("click", d => { d.stopPropagation(), go != null && go.classList.contains("mobile-menu-open") ? Ba() : Tu() }), ho == null || ho.addEventListener("click", () => { Ba() }); const Eu = d => { document.body.dataset.theme !== d && (document.body.dataset.theme = d, localStorage.setItem("theme", d)) }, bu = async () => {
    const d = g("#changelog-section"); if (d) try {
      const m = await fetch("changelog.json"); if (!m.ok) { console.warn("Changelog file not found, using default"); return } const h = (await m.json()).filter(E => E.active); if (h.length === 0) { d.innerHTML = ""; return } const C = h[0]; d.innerHTML = `
        <div class="changelog-item">
          <div class="changelog-dot"></div>
          <span class="changelog-text">${C.text}</span>
          <span class="changelog-arrow"></span>
        </div>
      `} catch (m) { console.error("Failed to load changelog:", m), d.innerHTML = "" }
  }, dl = () => { const d = g("#weight-slider"), m = g("#weight-value"); d && m && (m.textContent = `Value: ${d.value}`) }, Ja = () => { const d = g("#optical-size-slider"); if (!d) return; const m = Number(d.min) || 0, h = (Number(d.max) || 100) - m, C = Number(d.value), E = h === 0 ? 0 : (C - m) / h * 100; d.style.background = `linear-gradient(to right, var(--accent-color) 0%, var(--accent-color) ${E}%, var(--input-bg) ${E}%, var(--input-bg) 100%)` }, Wa = () => { var w, S, I, A; const d = ((w = document.querySelector('input[name="icon-family"]:checked')) == null ? void 0 : w.value) || "Outlined", m = (S = g("#fill-toggle")) != null && S.checked ? 1 : 0, y = ((I = g("#weight-slider")) == null ? void 0 : I.value) || "400", h = ((A = g("#optical-size-slider")) == null ? void 0 : A.value) || "24", C = `material-symbols-${d.toLowerCase()}`, E = `'FILL' ${m}, 'wght' ${y}, 'opsz' ${h}`; io("#icon-grid .icon-item > span:first-child, #settings-preview-icon, #motion-preview-icon").forEach(L => { L.classList.contains("material-icons") || (L.classList.remove("material-symbols-outlined", "material-symbols-rounded", "material-symbols-sharp"), L.classList.add(C), L.style.fontVariationSettings = E) }) }, za = () => { const d = g("#export-size-input"), m = Yn, y = g("#settings-preview-icon"), h = g("#motion-preview-icon"); if (!d || !m || !y || !h) return; const C = d.value || "48", E = m.value || "#0F172A"; y.style.fontSize = `${C}px`, y.style.color = E, h.style.color = E, Qt(m) }, Cu = () => { if (!Yt || !Yo || !Ko) return; e && clearTimeout(e), Yt.style.animation = ""; const d = Yo.value, m = Hs[d]; if (!m) return; const y = Ko.value === "infinite" ? "infinite" : "1", h = parseFloat(m.duration) * 1e3, C = `anim-style-${d}`; if (!document.getElementById(C)) { const E = document.createElement("style"); E.id = C, E.innerHTML = m.keyframes, document.head.appendChild(E) } Yt.offsetWidth, Yt.style.animation = `${d} ${m.duration} ${m.timing} ${y}`, y !== "infinite" && (e = window.setTimeout(() => { Yt.style.animation = "" }, h)) }, Ya = async (d, m, y, h, C, E, b = [], w, S = 1) => { var I, A; Re(E, !0), m == null || m.classList.add("hidden"), m == null || m.classList.remove("visible"); try { const L = [{ text: d }], x = b.filter(q => q != null); console.log(`[3D Studio] Reference images count: ${x.length} out of ${b.length} total slots`); const M = (await Promise.all(x.map(async (q, te) => { if (!q) return console.warn(`[3D Studio] Reference image ${te} is null/undefined`), null; try { if (q.file) return console.log(`[3D Studio] Processing reference image ${te + 1} from file: ${q.file.name}, type: ${q.file.type}`), { inlineData: { data: await Dt(q.file), mimeType: q.file.type } }; if (q.dataUrl) { const Y = q.dataUrl.match(/^data:([^;]+);base64,(.+)$/); if (Y) { const Q = Y[1], H = Y[2]; return console.log(`[3D Studio] Processing reference image ${te + 1} from dataUrl, type: ${Q}, size: ${H.length} chars`), { inlineData: { data: H, mimeType: Q } } } else console.warn(`[3D Studio] Reference image ${te + 1} dataUrl format invalid`) } else console.warn(`[3D Studio] Reference image ${te + 1} has no file or dataUrl`) } catch (Y) { console.error(`[3D Studio] Error processing reference image ${te + 1}:`, Y) } return null }))).filter(q => q !== null); console.log(`[3D Studio] Successfully processed ${M.length} reference images out of ${x.length} provided`), L.push(...M), console.log(`[3D Studio] Calling AI API with ${L.length} total parts (1 text + ${M.length} images):`, { textParts: L.filter(q => q.text).length, imageParts: L.filter(q => q.inlineData).length, totalParts: L.length }); const F = { responseModalities: [St.IMAGE], temperature: S }; w && (F.aspectRatio = w, console.log("Setting aspectRatio to:", w)); const U = await Xe.models.generateContent({ model: "gemini-2.5-flash-image", contents: { parts: L }, config: F }); console.log("API response received:", U); const Z = (I = U.candidates) == null ? void 0 : I[0], J = Z == null ? void 0 : Z.content, z = J == null ? void 0 : J.parts, B = z == null ? void 0 : z[0], O = B == null ? void 0 : B.inlineData; if (O && O.data && O.mimeType) { console.log("Image data extracted successfully, mimeType:", O.mimeType); const q = O, te = `data:${q.mimeType};base64,${q.data}`; let Y = q.data, Q = q.mimeType; try { const ee = new Image; await new Promise((oe, De) => { ee.onload = oe, ee.onerror = De, ee.src = te }); const pe = 1024, se = 576, me = pe / se, Le = ee.width / ee.height; console.log(`Resizing image from ${ee.width}x${ee.height} to ${pe}x${se} (16:9 ratio)`); const ge = document.createElement("canvas"); ge.width = pe, ge.height = se; const he = ge.getContext("2d"); if (he) { he.fillStyle = "#FFFFFF", he.fillRect(0, 0, pe, se); const oe = Math.min(pe / ee.width, se / ee.height), De = ee.width * oe, ze = ee.height * oe, je = (pe - De) / 2, be = (se - ze) / 2; he.drawImage(ee, je, be, De, ze); const Qe = ge.toDataURL(q.mimeType).match(/^data:[^;]+;base64,(.+)$/); Qe && (Y = Qe[1], console.log(`Image resized to ${pe}x${se} without cropping (letterboxing)`)) } } catch (ee) { console.warn("Failed to resize image, using original:", ee) } const H = `data:${Q};base64,${Y}`; return m && (m.src = H, m.classList.remove("hidden"), setTimeout(() => m.classList.add("visible"), 50)), { data: Y, mimeType: Q } } else throw console.error("Invalid API response structure:", { hasCandidates: !!U.candidates, candidateCount: (A = U.candidates) == null ? void 0 : A.length, hasContent: !!(Z != null && Z.content), hasParts: !!z, partsCount: z == null ? void 0 : z.length, hasInlineData: !!O, inlineDataKeys: O ? Object.keys(O) : null }), new Error("No image data received from API.") } catch (L) { return console.error("Image generation failed:", L), null } finally { Re(E, !1) } }, cl = () => { const d = g("#p2d-weight-slider"), m = g("#p2d-weight-value"); d && m && (m.textContent = `Value: ${d.value}`) }, Vi = () => { if (Ni) try { const d = JSON.parse(Os), m = on.value || "a friendly robot", y = "outlined", h = document.querySelector("#p2d-fill-toggle").checked, C = document.querySelector("#p2d-weight-slider"), E = C ? parseInt(C.value, 10) : 400, b = document.querySelector("#p2d-color-picker").value; d.subject = m, d.controls.style.shape = y, d.controls.style.fill.enabled = h, d.controls.stroke.weight.value = E, d.controls.color.primary = b, Ni.value = JSON.stringify(d, null, 2) } catch (d) { console.error("Failed to parse or update 2D prompt", d), Ni.value = Os.replace("{ICON_SUBJECT}", on.value || "a friendly robot") } }, wu = async () => { var m; if (!on.value) { G({ type: "error", title: "Input Required", body: "Please enter a subject for your icon." }), on.focus(); return } Vi(), qi(we), we && Ue && (Ue.textContent = "Generating icon", we.classList.remove("hidden")); let d = null; try { const y = document.querySelector("#p2d-fill-toggle").checked, h = document.querySelector("#p2d-weight-slider"), C = h ? parseInt(h.value, 10) : 400, E = new Set; y ? R[0] && E.add(R[0]) : R[1] && E.add(R[1]), C <= 300 ? R[2] && E.add(R[2]) : C >= 500 ? R[3] && E.add(R[3]) : C === 400 && R[1] && E.add(R[1]); const b = Array.from(E); if (d = await Ya(Ni.value, Ce, sa, aa, Tn, ss, b), d) { const w = { id: `img_2d_${Date.now()}`, data: d.data, mimeType: d.mimeType, subject: on.value, styleConstraints: Ni.value, timestamp: Date.now(), modificationType: "Original", motionPrompt: null, videoDataUrl: void 0 }; a = w, c.splice(f + 1), c.push(w), f = c.length - 1, Xn(w), await Xa(w); const S = `data:${w.mimeType};base64,${w.data}`, I = { id: w.id, dataUrl: S, mimeType: w.mimeType }; yt.unshift(I), yt.length > 20 && yt.pop(), hs(), Ui(), dn(), ve == null || ve.classList.remove("hidden"), ve == null || ve.classList.add("is-open"), yo(), pn(), setTimeout(() => { pn() }, 100), setTimeout(() => { pn() }, 300); const A = (m = g("#p2d-details-history-list")) == null ? void 0 : m.closest(".details-tab-content"); A && !A.classList.contains("hidden") && At(), we && (_n(we), we.classList.add("hidden")) } } catch (y) { console.error("Error generating 2D image:", y), G({ type: "error", title: "Generation Failed", body: "Failed to generate icon. Please try again." }), we && we.classList.add("hidden") } }, Kn = () => { if (!a) return; const d = !!a.motionPrompt, m = !!a.videoDataUrl; if (ga && ft && ha) if (d) { const E = a.motionPrompt.english, b = a.motionPrompt.korean; (ft.value.trim() === "" || ft.dataset.originalPrompt === E) && (ft.value = E), ft.dataset.originalPrompt = E, ha.textContent = b, ga.classList.remove("hidden") } else ga.classList.add("hidden"), ft.value = "", ha.textContent = ""; if (Pi && lo) if (m) { const E = a.videoDataUrl; Pi.src !== E && (Pi.src = E), lo.classList.remove("hidden"), lo.classList.remove("loading") } else Pi.pause(), Pi.removeAttribute("src"), lo.classList.add("hidden"); const y = !!a.gifDataUrl; if (Oo) if (m) { const E = a.videoDataUrl; Oo.href = E, Oo.download = `${a.subject.replace(/\s+/g, "_")}_motion.mp4`, Oo.classList.remove("hidden") } else Oo.classList.add("hidden"), Oo.removeAttribute("href"); if (Ho) if (y) { const E = a.gifDataUrl; Ho.href = E, Ho.download = `${a.subject.replace(/\s+/g, "_")}_motion.gif`, Ho.classList.remove("hidden") } else Ho.classList.add("hidden"), Ho.removeAttribute("href"); const h = !!a.webmDataUrl; if (Wo) if (h) { const E = a.webmDataUrl; Wo.href = E, Wo.download = `${a.subject.replace(/\s+/g, "_")}_motion.webm`, Wo.classList.remove("hidden") } else Wo.classList.add("hidden"), Wo.removeAttribute("href"); const C = !!a.webpDataUrl; if (zo) if (C) { const E = a.webpDataUrl; zo.href = E, zo.download = `${a.subject.replace(/\s+/g, "_")}_motion.webp`, zo.classList.remove("hidden") } else zo.classList.add("hidden"), zo.removeAttribute("href"); if (Wn && (m && !y ? Wn.classList.remove("hidden") : Wn.classList.add("hidden")), Bo && (m && !h ? Bo.classList.remove("hidden") : Bo.classList.add("hidden")), Jo && (m && !C ? Jo.classList.remove("hidden") : Jo.classList.add("hidden")), co && sn && En && Ut && (m ? (co.classList.add("hidden"), sn.classList.add("hidden"), En.classList.add("hidden"), Ut.classList.add("hidden"), $t == null || $t.classList.remove("hidden"), Ve == null || Ve.classList.add("hidden"), Go && (Go.style.display = "flex")) : d ? (co.classList.add("hidden"), sn.classList.remove("hidden"), En.classList.remove("hidden"), Ut.classList.add("hidden"), $t == null || $t.classList.add("hidden"), Ve == null || Ve.classList.add("hidden"), Go && (Go.style.display = "none")) : (co.classList.remove("hidden"), sn.classList.add("hidden"), En.classList.add("hidden"), Ut.classList.add("hidden"), $t == null || $t.classList.add("hidden"), Ve == null || Ve.classList.add("hidden"), Go && (Go.style.display = "none"))), Xr && Zr && a) { const E = `data:${a.mimeType};base64,${a.data}`; Xr.src = E, Zr.textContent = a.subject } if (Pe) if (m) { const E = a.videoDataUrl; Pe.src !== E && (Pe.src = E, Lo(Pe)), We != null && We.classList.contains("active") && (Pe.classList.remove("hidden"), Se == null || Se.classList.add("hidden")) } else Pe.pause(), Pe.removeAttribute("src"), Pe.classList.add("hidden"), We != null && We.classList.contains("active") && (Se == null || Se.classList.toggle("hidden", !d)); !m && !d && (Se == null || Se.classList.add("hidden")) }, dn = () => { var A; if (!a || !Ce || !Tn || !sa || !aa || !Bn) return; Ce.src = `data:${a.mimeType};base64,${a.data}`, Ce.classList.remove("hidden"), setTimeout(() => Ce.classList.add("visible"), 50), Tn.classList.add("hidden"), sa.classList.add("hidden"), aa.classList.add("hidden"), Bn.classList.remove("hidden"), Jn && (Jn.src = Ce.src), ot && (ot.href = Ce.src, ot.download = `${a.subject.replace(/\s+/g, "_")}.png`, ot.classList.remove("hidden")), rs && rs.classList.add("hidden"); const d = a.modificationType === "BG Removed" || a.modificationType === "SVG", m = g("#p2d-details-preview-container"), y = g("#p2d-preview-checkerboard-checkbox"), h = g("#p2d-preview-checkerboard-toggle"), C = g("#p2d-result-media-container"), E = g("#p2d-result-checkerboard-toggle"); if (C && (C.style.backgroundImage = "", C.style.backgroundColor = "#ffffff"), E && (E.style.display = "none"), d) { h && (h.style.display = "flex"); const L = (x, _) => { x && (_ ? (x.style.backgroundColor = "", x.style.backgroundImage = "repeating-linear-gradient(45deg, #f0f0f0 25%, transparent 25%, transparent 75%, #f0f0f0 75%, #f0f0f0), repeating-linear-gradient(45deg, #f0f0f0 25%, #ffffff 25%, #ffffff 75%, #f0f0f0 75%, #f0f0f0)", x.style.backgroundPosition = "0 0, 8px 8px", x.style.backgroundSize = "16px 16px") : (x.style.backgroundImage = "", x.style.backgroundColor = "#ffffff")) }; y ? L(m, y.checked) : L(m, !0) } else h && (h.style.display = "none"), m && (m.style.backgroundImage = "", m.style.backgroundColor = "#ffffff"); $ = `data:${a.mimeType};base64,${a.data}`; const w = g("#p2d-remove-background-btn"); N = !1; const S = g("#p2d-convert-to-svg-btn"), I = g("#p2d-action-buttons-container"); w && w.classList.remove("hidden"), S && (S.style.display = "none", S.classList.add("hidden")), I && (I.style.gridTemplateColumns = "1fr"), Pe && ((A = Pe.pause) == null || A.call(Pe), Pe.classList.add("hidden"), Pe.removeAttribute("src")), Se == null || Se.classList.add("hidden"), lt == null || lt.classList.add("active"), We == null || We.classList.remove("active"), Kn() }, Xn = d => { var m, y; if (console.log("[2D Studio] resetRightHistoryForBaseAsset2d called with:", { id: d.id, hasData: !!d.data, dataLength: ((m = d.data) == null ? void 0 : m.length) || 0, mimeType: d.mimeType }), k = d.id, d.rightPanelHistory && d.rightPanelHistory.length > 0) console.log("[2D Studio] Using existing right panel history for item:", d.id), u = [...d.rightPanelHistory], p = (u.length > 0, 0); else { u = []; const h = { ...d, modificationType: "Original" }; u.push(h), p = 0, d.rightPanelHistory = [...u], console.log("[2D Studio] History reset with Original entry:", { id: h.id, hasData: !!h.data, dataLength: ((y = h.data) == null ? void 0 : y.length) || 0, mimeType: h.mimeType, modificationType: h.modificationType }) } N = !1, $ = `data:${d.mimeType};base64,${d.data}`, setTimeout(() => { At() }, 0) }, Zn = d => { var m, y; if (console.log("[3D Studio] resetRightHistoryForBaseAsset3d called with:", { id: d.id, hasData: !!d.data, dataLength: ((m = d.data) == null ? void 0 : m.length) || 0, mimeType: d.mimeType }), d.rightPanelHistory && d.rightPanelHistory.length > 0) console.log("[3D Studio] Using existing right panel history for item:", d.id), v = [...d.rightPanelHistory], T = (v.length > 0, 0); else { v = []; const h = { ...d, modificationType: "Original" }; v.push(h), T = 0, d.rightPanelHistory = [...v], console.log("[3D Studio] Reset history with Original entry:", { id: h.id, hasData: !!h.data, dataLength: ((y = h.data) == null ? void 0 : y.length) || 0, mimeType: h.mimeType, modificationType: h.modificationType }) } setTimeout(() => { jt() }, 0) }, At = () => {
    const d = g("#p2d-details-history-list"); if (!d) { console.warn("[2D Studio] History list element not found"); return } const m = d.closest('.details-tab-content[data-tab-content="history"]'); if (!m) { console.warn("[2D Studio] History tab content not found"); return } if (console.log("[2D Studio] updateDetailsPanelHistory2d called"), console.log("[2D Studio] History count:", u.length), console.log("[2D Studio] Current image:", a), console.log("[2D Studio] History tab visible:", !m.classList.contains("hidden")), console.log("[2D Studio] History tab classes:", m.className), u.length === 0 && a && (console.log("[2D Studio] History is empty, initializing with current image"), Xn(a), console.log("[2D Studio] History after init:", u.length), console.log("[2D Studio] History items after init:", u)), u.length === 0) { console.log("[2D Studio] No history items, showing empty state"), d.innerHTML = '<p style="padding: var(--spacing-4); text-align: center; color: var(--text-secondary);">No Fix history available</p>'; return } d.innerHTML = "", console.log("[2D Studio] Rendering history items:", u.map(E => ({ id: E.id, modificationType: E.modificationType, hasData: !!E.data, hasMimeType: !!E.mimeType }))); const y = u.find(E => E.modificationType === "Original");[...u].reverse().forEach((E, b) => {
      var J; const w = u.length - 1 - b, S = w === p; console.log(`[2D Studio] Rendering history item ${w}:`, { id: E.id, modificationType: E.modificationType, hasData: !!E.data, dataLength: ((J = E.data) == null ? void 0 : J.length) || 0, mimeType: E.mimeType }); let I = E.modificationType || "Original", A = "Original"; I === "Regenerated" || I === "Fix" ? A = "Color Changed" : I === "BG Removed" ? A = "Remove BG" : I === "SVG" && (A = "SVG"); const L = I === "BG Removed" || I === "SVG", x = document.createElement("button"); x.type = "button", x.className = "details-history-item-thumbnail", x.dataset.index = String(w), x.setAttribute("aria-label", `Load history item ${w + 1}: ${A}`), x.style.cssText = `
            position: relative;
            width: 100%;
            aspect-ratio: 1;
            border: ${S ? "2px solid var(--accent-color)" : "1px solid var(--border-color)"};
            border-radius: var(--border-radius-md);
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s ease;
            outline: none;
            background: transparent;
            padding: 0;
        `; const _ = document.createElement("div"); _.style.cssText = `
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        `, L ? (_.style.backgroundImage = "repeating-linear-gradient(45deg, #f0f0f0 25%, transparent 25%, transparent 75%, #f0f0f0 75%, #f0f0f0), repeating-linear-gradient(45deg, #f0f0f0 25%, #ffffff 25%, #ffffff 75%, #f0f0f0 75%, #f0f0f0)", _.style.backgroundPosition = "0 0, 8px 8px", _.style.backgroundSize = "16px 16px") : _.style.backgroundColor = "#ffffff"; const M = document.createElement("img"); if (E.data && E.mimeType) { const z = `data:${E.mimeType};base64,${E.data}`; console.log(`[2D Studio] Setting image src for item ${w}, data length:`, E.data.length, "mimeType:", E.mimeType), M.src = z, M.loading = "lazy", M.style.cssText = "width: 100%; height: 100%; object-fit: contain; pointer-events: none;", M.alt = `History item ${w + 1}`, M.onerror = B => { var O; console.error(`[2D Studio]  Failed to load thumbnail for item ${w}:`, B), console.error("[2D Studio] Image src preview:", z.substring(0, 100) + "..."), console.error("[2D Studio] Item data:", { id: E.id, hasData: !!E.data, dataLength: (O = E.data) == null ? void 0 : O.length, mimeType: E.mimeType }), M.style.display = "none", _.innerHTML = '<span class="material-symbols-outlined" style="font-size: 24px; color: var(--text-secondary); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">image</span>' }, M.onload = () => { console.log(`[2D Studio]  Thumbnail loaded successfully for item ${w}:`, E.id) }, _.appendChild(M), console.log(`[2D Studio] Image element appended to thumbnail container for item ${w}`) } else console.warn(`[2D Studio]  Missing data for history item ${w}:`, { hasData: !!E.data, hasMimeType: !!E.mimeType, itemId: E.id, modificationType: E.modificationType }), _.innerHTML = '<span class="material-symbols-outlined" style="font-size: 24px; color: var(--text-secondary); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">image</span>'; const F = document.createElement("div"); F.style.cssText = `
            position: absolute;
            top: 8px;
            left: 8px;
            padding: 4px 8px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: var(--border-radius-sm);
            font-size: 11px;
            font-weight: 600;
            z-index: 2;
            pointer-events: none;
        `, F.textContent = A, _.appendChild(F), x.appendChild(_); let U = null; if (y && E.modificationType && E.modificationType !== "Original") {
        U = document.createElement("button"), U.className = "history-compare-btn", U.innerHTML = '<span class="material-symbols-outlined">compare</span>', U.setAttribute("aria-label", "Compare with Original"), U.style.cssText = `
                position: absolute;
                bottom: 8px;
                right: 8px;
                width: 32px;
                height: 32px;
                border-radius: 50%;
                background-color: rgba(0, 0, 0, 0.7);
                color: white;
                border: none;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                opacity: 0;
                transition: opacity 0.2s ease;
                z-index: 3;
                pointer-events: auto;
            `; const z = U.querySelector(".material-symbols-outlined"); z && (z.style.cssText = "font-size: 18px;"), _.appendChild(U), x.addEventListener("mouseenter", () => { U && (U.style.opacity = "1") }), x.addEventListener("mouseleave", () => { U && (U.style.opacity = "0") }), U.addEventListener("click", B => { B.stopPropagation(); const O = g("#p2d-compare-modal"), q = g("#p2d-compare-original"), te = g("#p2d-compare-current"), Y = g("#p2d-compare-slider"), Q = g("#p2d-compare-divider"), H = g("#compare-left-label-2d"); if (!O || !q || !te || !Y || !Q) { console.error("[2D Compare] Modal elements not found"); return } H && (H.textContent = "After"), q.src = `data:${y.mimeType};base64,${y.data}`, te.src = `data:${E.mimeType};base64,${E.data}`; const ee = I === "BG Removed" || I === "SVG", pe = y.modificationType === "BG Removed" || y.modificationType === "SVG", se = te.parentElement, me = q.parentElement; se && (ee ? (se.style.backgroundColor = "", se.style.backgroundImage = "repeating-linear-gradient(45deg, #f0f0f0 25%, transparent 25%, transparent 75%, #f0f0f0 75%, #f0f0f0), repeating-linear-gradient(45deg, #f0f0f0 25%, #ffffff 25%, #ffffff 75%, #f0f0f0 75%, #f0f0f0)", se.style.backgroundPosition = "0 0, 8px 8px", se.style.backgroundSize = "16px 16px") : (se.style.backgroundColor = "#ffffff", se.style.backgroundImage = "")), me && (pe ? (me.style.backgroundColor = "", me.style.backgroundImage = "repeating-linear-gradient(45deg, #f0f0f0 25%, transparent 25%, transparent 75%, #f0f0f0 75%, #f0f0f0), repeating-linear-gradient(45deg, #f0f0f0 25%, #ffffff 25%, #ffffff 75%, #f0f0f0 75%, #f0f0f0)", me.style.backgroundPosition = "0 0, 8px 8px", me.style.backgroundSize = "16px 16px") : (me.style.backgroundColor = "#ffffff", me.style.backgroundImage = "")); const Le = me == null ? void 0 : me.querySelector("label"), ge = () => { const he = Y.valueAsNumber; Q.style.left = `${he}%`, me && (me.style.clipPath = `inset(0 0 0 ${he}%)`), H && (H.style.right = `calc(${100 - he}% + 32px)`), Le && (Le.style.left = `calc(${he}% + 32px)`) }; me && (me.style.clipPath = "inset(0 0 0 50%)"), Y.removeEventListener("input", ge), Y.addEventListener("input", ge), Y.value = "50", ge(), O.classList.remove("hidden") })
      } x.addEventListener("click", () => { if (p = w, a = u[w], Ce && a) { Ce.src = `data:${a.mimeType};base64,${a.data}`; const z = g("#p2d-result-media-container"), B = g("#p2d-result-checkerboard-toggle"); z && (z.style.backgroundImage = "", z.style.backgroundColor = "#ffffff"), B && (B.style.display = "none") } if (Jn && a) { Jn.src = `data:${a.mimeType};base64,${a.data}`; const z = a.modificationType === "BG Removed" || a.modificationType === "SVG", B = g("#p2d-details-preview-container"), O = g("#p2d-preview-checkerboard-checkbox"), q = g("#p2d-preview-checkerboard-toggle"), te = g("#p2d-result-media-container"), Y = g("#p2d-result-checkerboard-checkbox"), Q = g("#p2d-result-checkerboard-toggle"); if (z) { q && (q.style.display = "flex"), Q && (Q.style.display = "flex"); const H = (ee, pe) => { ee && (pe ? (ee.style.backgroundColor = "", ee.style.backgroundImage = "repeating-linear-gradient(45deg, #f0f0f0 25%, transparent 25%, transparent 75%, #f0f0f0 75%, #f0f0f0), repeating-linear-gradient(45deg, #f0f0f0 25%, #ffffff 25%, #ffffff 75%, #f0f0f0 75%, #f0f0f0)", ee.style.backgroundPosition = "0 0, 8px 8px", ee.style.backgroundSize = "16px 16px") : (ee.style.backgroundImage = "", ee.style.backgroundColor = "#ffffff")) }; O ? H(B, O.checked) : H(B, !0), Y ? H(te, Y.checked) : H(te, !0) } else q && (q.style.display = "none"), Q && (Q.style.display = "none"), B && (B.style.backgroundImage = "", B.style.backgroundColor = "#ffffff"), te && (te.style.backgroundImage = "", te.style.backgroundColor = "#ffffff") } if (ot && a) { const z = `data:${a.mimeType};base64,${a.data}`; ot.href = z, ot.download = `${a.subject.replace(/\s+/g, "_")}.png`, ot.classList.remove("hidden") } rs && rs.classList.add("hidden"), dn(), At() }), d.appendChild(x), console.log(`[2D Studio] Added history item ${w} to DOM:`, E.id), console.log("[2D Studio] DOM children count:", d.children.length), d.querySelector(`[data-index="${w}"]`) ? console.log(`[2D Studio] Verified element ${w} exists in DOM`) : console.error(`[2D Studio] Failed to find added element with index ${w} in DOM`)
    }), console.log(`[2D Studio]  Rendered ${u.length} history items`), console.log("[2D Studio] Final DOM children count:", d.children.length), console.log("[2D Studio] History list element:", d), console.log("[2D Studio] History list computed styles:", { display: window.getComputedStyle(d).display, gridTemplateColumns: window.getComputedStyle(d).gridTemplateColumns, visibility: window.getComputedStyle(d).visibility, opacity: window.getComputedStyle(d).opacity, width: window.getComputedStyle(d).width, height: window.getComputedStyle(d).height }), console.log("[2D Studio] History list parent:", d.parentElement); const C = d.closest(".details-tab-content"); if (console.log("[2D Studio] History tab content:", C), C) { const E = C; console.log("[2D Studio] History tab content computed styles:", { display: window.getComputedStyle(E).display, visibility: window.getComputedStyle(E).visibility, opacity: window.getComputedStyle(E).opacity, hasHiddenClass: E.classList.contains("hidden") }) } Array.from(d.children).forEach((E, b) => { console.log(`[2D Studio] Child ${b}:`, { tagName: E.tagName, className: E.className, styles: { display: window.getComputedStyle(E).display, width: window.getComputedStyle(E).width, height: window.getComputedStyle(E).height, visibility: window.getComputedStyle(E).visibility } }) })
  }, jt = () => {
    const d = document.getElementById("3d-details-history-list"); if (!d) { console.warn("[3D Studio] History list element not found"); return } const m = d.closest('.details-tab-content[data-tab-content="history"]'); if (!m) { console.warn("[3D Studio] History tab content not found"); return } if (console.log("[3D Studio] updateDetailsPanelHistory3d called"), console.log("[3D Studio] History count:", v.length), console.log("[3D Studio] Current image:", n), console.log("[3D Studio] History tab visible:", !m.classList.contains("hidden")), console.log("[3D Studio] History tab classes:", m.className), v.length === 0 && n && (console.log("[3D Studio] History is empty, initializing with current image"), Zn(n), console.log("[3D Studio] History after init:", v.length), console.log("[3D Studio] History items after init:", v)), v.length === 0) { console.log("[3D Studio] No history items, showing empty state"), d.innerHTML = '<p style="padding: var(--spacing-4); text-align: center; color: var(--text-secondary);">No history available</p>'; return } d.innerHTML = "", console.log("[3D Studio] Cleared history list innerHTML"), console.log("[3D Studio] Rendering history items:", v.map(C => { var E; return { id: C.id, modificationType: C.modificationType, hasData: !!C.data, dataLength: ((E = C.data) == null ? void 0 : E.length) || 0, dataPreview: C.data ? C.data.substring(0, 50) + "..." : "no data", hasMimeType: !!C.mimeType, mimeType: C.mimeType } })); const y = v.find(C => C.modificationType === "Original");[...v].reverse().forEach((C, E) => {
      var Z; const b = v.length - 1 - E, w = b === T; console.log(`[3D Studio] Rendering history item ${b}:`, { id: C.id, modificationType: C.modificationType, hasData: !!C.data, dataLength: ((Z = C.data) == null ? void 0 : Z.length) || 0, mimeType: C.mimeType }); let S = C.modificationType || "Original", I = "Original"; S === "Regenerated" || S === "Fix" ? I = "Color Changed" : S === "BG Removed" ? I = "Remove BG" : S === "SVG" && (I = "SVG"); const A = document.createElement("button"); A.type = "button", A.className = "details-history-item-thumbnail", A.dataset.index = String(b), A.setAttribute("aria-label", `Load history item ${b + 1}: ${I}`), A.style.cssText = `
            position: relative;
            width: 100%;
            aspect-ratio: 1;
            border: ${w ? "2px solid var(--accent-color)" : "1px solid var(--border-color)"};
            border-radius: var(--border-radius-md);
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s ease;
            outline: none;
            background: transparent;
            padding: 0;
        `; const L = document.createElement("div"), x = S === "BG Removed" || S === "SVG"; L.style.cssText = `
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        `, x ? (L.style.backgroundImage = "repeating-linear-gradient(45deg, #f0f0f0 25%, transparent 25%, transparent 75%, #f0f0f0 75%, #f0f0f0), repeating-linear-gradient(45deg, #f0f0f0 25%, #ffffff 25%, #ffffff 75%, #f0f0f0 75%, #f0f0f0)", L.style.backgroundPosition = "0 0, 8px 8px", L.style.backgroundSize = "16px 16px") : L.style.backgroundColor = "#ffffff"; const _ = document.createElement("img"); if (C.data && C.mimeType) { const J = `data:${C.mimeType};base64,${C.data}`; console.log(`[3D Studio] Setting image src for item ${b}, data length:`, C.data.length, "mimeType:", C.mimeType), _.src = J, _.loading = "lazy", _.style.cssText = "width: 100%; height: 100%; object-fit: contain; pointer-events: none;", _.alt = `History item ${b + 1}`, _.onerror = z => { console.error(`[3D Studio]  Failed to load thumbnail for item ${b}:`, z), console.error("[3D Studio] Image src preview:", J.substring(0, 100) + "..."), _.style.display = "none", L.innerHTML = '<span class="material-symbols-outlined" style="font-size: 24px; color: var(--text-secondary); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">image</span>' }, _.onload = () => { console.log(`[3D Studio]  Thumbnail loaded successfully for item ${b}:`, C.id) }, L.appendChild(_), console.log(`[3D Studio] Image element appended to thumbnail container for item ${b}`) } else console.warn(`[3D Studio]  Missing data for history item ${b}:`, { hasData: !!C.data, hasMimeType: !!C.mimeType, itemId: C.id, modificationType: C.modificationType }), L.innerHTML = '<span class="material-symbols-outlined" style="font-size: 24px; color: var(--text-secondary); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">image</span>'; const M = document.createElement("div"); M.style.cssText = `
            position: absolute;
            top: 8px;
            left: 8px;
            padding: 4px 8px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: var(--border-radius-sm);
            font-size: 11px;
            font-weight: 600;
            z-index: 2;
            pointer-events: none;
        `, M.textContent = I, L.appendChild(M), A.appendChild(L); let F = null; if (y && C.id !== y.id) {
        F = document.createElement("button"), F.className = "history-compare-btn", F.innerHTML = '<span class="material-symbols-outlined">compare</span>', F.setAttribute("aria-label", "Compare with Original"), F.style.cssText = `
                position: absolute;
                bottom: 8px;
                right: 8px;
                width: 32px;
                height: 32px;
                border-radius: 50%;
                background-color: rgba(0, 0, 0, 0.7);
                color: white;
                border: none;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                opacity: 0;
                transition: opacity 0.2s ease;
                z-index: 3;
                pointer-events: auto;
            `; const J = F.querySelector(".material-symbols-outlined"); J && (J.style.cssText = "font-size: 18px;"), L.appendChild(F), A.addEventListener("mouseenter", () => { F && (F.style.opacity = "1") }), A.addEventListener("mouseleave", () => { F && (F.style.opacity = "0") }), F.addEventListener("click", z => { z.stopPropagation(); const B = g("#compare-modal-3d"), O = g("#compare-original-3d"), q = g("#compare-current-3d"), te = g("#compare-slider-3d"), Y = g("#compare-divider-3d"), Q = g("#compare-left-label-3d"); if (!B || !O || !q || !te || !Y) { console.error("[3D Compare] Modal elements not found"); return } Q && (Q.textContent = "After"), O.src = `data:${y.mimeType};base64,${y.data}`, q.src = `data:${C.mimeType};base64,${C.data}`; const H = S === "BG Removed" || S === "SVG", ee = y.modificationType === "BG Removed" || y.modificationType === "SVG", pe = q.parentElement, se = O.parentElement; pe && (H ? (pe.style.backgroundColor = "", pe.style.backgroundImage = "repeating-linear-gradient(45deg, #f0f0f0 25%, transparent 25%, transparent 75%, #f0f0f0 75%, #f0f0f0), repeating-linear-gradient(45deg, #f0f0f0 25%, #ffffff 25%, #ffffff 75%, #f0f0f0 75%, #f0f0f0)", pe.style.backgroundPosition = "0 0, 8px 8px", pe.style.backgroundSize = "16px 16px") : (pe.style.backgroundColor = "#ffffff", pe.style.backgroundImage = "")), se && (ee ? (se.style.backgroundColor = "", se.style.backgroundImage = "repeating-linear-gradient(45deg, #f0f0f0 25%, transparent 25%, transparent 75%, #f0f0f0 75%, #f0f0f0), repeating-linear-gradient(45deg, #f0f0f0 25%, #ffffff 25%, #ffffff 75%, #f0f0f0 75%, #f0f0f0)", se.style.backgroundPosition = "0 0, 8px 8px", se.style.backgroundSize = "16px 16px") : (se.style.backgroundColor = "#ffffff", se.style.backgroundImage = "")); const me = se == null ? void 0 : se.querySelector("label"), Le = () => { const ge = te.valueAsNumber; Y.style.left = `${ge}%`, se && (se.style.clipPath = `inset(0 0 0 ${ge}%)`), Q && (Q.style.right = `calc(${100 - ge}% + 32px)`), me && (me.style.left = `calc(${ge}% + 32px)`) }; se && (se.style.clipPath = "inset(0 0 0 50%)"), te.removeEventListener("input", Le), te.addEventListener("input", Le), te.value = "50", Le(), B.classList.remove("hidden") })
      } A.addEventListener("click", () => { T = b, n = v[b]; const J = document.querySelector("#page-id-3d .result-image"); if (J && n) { J.src = `data:${n.mimeType};base64,${n.data}`, J.classList.remove("hidden"), J.classList.add("visible"); const O = g("#result-media-container-3d"); O && (O.style.backgroundImage = "", O.style.backgroundColor = "#ffffff") } const z = g("#details-preview-image"); if (z && n) { z.src = `data:${n.mimeType};base64,${n.data}`; const O = n.modificationType === "BG Removed" || n.modificationType === "SVG", q = g("#details-preview-container-3d"), te = g("#details-preview-checkerboard-checkbox-3d"), Y = g("#details-preview-checkerboard-toggle-3d"); if (O) { Y && (Y.style.display = "flex"); const Q = (H, ee) => { H && (ee ? (H.style.backgroundColor = "", H.style.backgroundImage = "repeating-linear-gradient(45deg, #f0f0f0 25%, transparent 25%, transparent 75%, #f0f0f0 75%, #f0f0f0), repeating-linear-gradient(45deg, #f0f0f0 25%, #ffffff 25%, #ffffff 75%, #f0f0f0 75%, #f0f0f0)", H.style.backgroundPosition = "0 0, 8px 8px", H.style.backgroundSize = "16px 16px") : (H.style.backgroundImage = "", H.style.backgroundColor = "#ffffff")) }; te ? Q(q, te.checked) : Q(q, !0) } else Y && (Y.style.display = "none"), q && (q.style.backgroundImage = "", q.style.backgroundColor = "#ffffff") } const B = g("#details-download-btn"); if (B && n) { const O = `data:${n.mimeType};base64,${n.data}`; B.href = O, B.download = `${n.subject.replace(/\s+/g, "_")}.png` } jt() }), d.appendChild(A), console.log(`[3D Studio] Added history item ${b} to DOM:`, C.id), console.log("[3D Studio] DOM children count:", d.children.length), d.querySelector(`[data-index="${b}"]`) ? console.log(`[3D Studio] Verified element ${b} exists in DOM`) : console.error(`[3D Studio] Failed to find added element with index ${b} in DOM`)
    }), console.log(`[3D Studio]  Rendered ${v.length} history items`), console.log("[3D Studio] Final DOM children count:", d.children.length), console.log("[3D Studio] History list computed styles:", { display: window.getComputedStyle(d).display, gridTemplateColumns: window.getComputedStyle(d).gridTemplateColumns, visibility: window.getComputedStyle(d).visibility, opacity: window.getComputedStyle(d).opacity, width: window.getComputedStyle(d).width, height: window.getComputedStyle(d).height })
  }, yo = () => {
    if (!as || !ca || !ua || !Uo || !$o) return; if (c.length === 0) { as.classList.add("hidden"); return } as.classList.remove("hidden"), ca.innerHTML = ""; const d = c.filter(h => !h.modificationType || h.modificationType === "Original"); if (d.length === 0) { as.classList.add("hidden"); return } d.forEach((h, C) => {
      const E = c.findIndex(A => A.id === h.id), b = document.createElement("li"); b.className = "history-item", E === f && b.classList.add("selected"), b.dataset.index = String(E); const S = new Date(h.timestamp).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }); b.innerHTML = `
        <div class="history-item-main">
            <div style="position: relative;">
            <img src="data:${h.mimeType};base64,${h.data}" class="history-thumbnail" alt="History item thumbnail">
            </div>
            <div class="history-item-info">
            <span class="history-item-label">${h.subject}</span>
            <span class="history-item-timestamp">${S}</span>
            </div>
            <button class="history-item-delete-btn" aria-label="Delete history item">
                <span class="material-symbols-outlined">delete</span>
            </button>
        </div>
        `; const I = b.querySelector(".history-item-delete-btn"); I == null || I.addEventListener("click", A => { if (A.stopPropagation(), c.length === 1) { G({ type: "error", title: "Cannot Delete", body: "Cannot delete the last item in history." }); return } c.splice(E, 1), f >= E && f > 0 ? f-- : f >= c.length && (f = c.length - 1), c.length > 0 ? (a = c[f], Xn(a), dn()) : (a = null, Ce.src = "", Ce.classList.add("hidden"), Tn == null || Tn.classList.remove("hidden"), Bn == null || Bn.classList.add("hidden")), yo(), G({ type: "success", title: "Deleted", body: "Item removed from history." }) }), b.addEventListener("click", () => { var x; f = E; const A = c[f]; a = A, Xn(A), dn(), yo(); const L = (x = g("#p2d-details-history-list")) == null ? void 0 : x.closest(".details-tab-content"); L && !L.classList.contains("hidden") && At() }), ca.prepend(b)
    }); const m = c.filter(h => !h.modificationType || h.modificationType === "Original"), y = m.findIndex(h => { var C; return ((C = c[f]) == null ? void 0 : C.id) === h.id }); m.length > 0 && y !== -1 ? (ua.textContent = `${y + 1} / ${m.length}`, Uo.disabled = y <= 0, $o.disabled = y >= m.length - 1) : (ua.textContent = "0 / 0", Uo.disabled = !0, $o.disabled = !0)
  }, cn = (d, m) => { const y = d.querySelector(".style-image-preview"), h = d.querySelector(".drop-zone-prompt"), C = d.querySelector(".remove-style-image-btn"); y && h && C && (y.src = m, y.classList.remove("hidden"), h == null || h.classList.add("hidden"), C.classList.remove("hidden")) }, Ka = d => { const m = d.querySelector(".style-image-preview"), y = d.querySelector(".drop-zone-prompt"), h = d.querySelector(".remove-style-image-btn"); m && y && h && (m.src = "", m.classList.add("hidden"), y.classList.remove("hidden"), h.classList.add("hidden")) }, ai = async d => { const m = `data:${d.mimeType};base64,${d.data}`; try { const h = await (await fetch(m)).blob(), E = { file: new File([h], `generated_frame.${d.mimeType.split("/")[1] || "png"}`, { type: d.mimeType }), dataUrl: m }; K = E, j = E; const b = document.querySelector('#motion-reference-image-container .image-drop-zone[data-index="0"]'), w = document.querySelector('#motion-reference-image-container .image-drop-zone[data-index="1"]'); b && cn(b, m), w && cn(w, m) } catch (y) { console.error("Failed to set initial motion frames:", y) } }, ul = async d => { const m = `data:${d.mimeType};base64,${d.data}`; try { const h = await (await fetch(m)).blob(), E = { file: new File([h], `generated_frame_studio.${d.mimeType.split("/")[1] || "png"}`, { type: d.mimeType }), dataUrl: m }; ue = E, Fe = E; const b = document.querySelector('#motion-reference-image-container-image .image-drop-zone[data-index="0"]'), w = document.querySelector('#motion-reference-image-container-image .image-drop-zone[data-index="1"]'); b && cn(b, m), w && cn(w, m) } catch (y) { console.error("Failed to set initial motion frames for Image Studio:", y) } }, Xa = async d => { const m = `data:${d.mimeType};base64,${d.data}`; try { const h = await (await fetch(m)).blob(), E = { file: new File([h], `generated_frame_2d.${d.mimeType.split("/")[1] || "png"}`, { type: d.mimeType }), dataUrl: m }; le = E, de = E; const b = document.querySelector('#p2d-motion-reference-image-container .image-drop-zone[data-index="0"]'), w = document.querySelector('#p2d-motion-reference-image-container .image-drop-zone[data-index="1"]'); b && cn(b, m), w && cn(w, m) } catch (y) { console.error("Failed to set initial motion frames for 2D Studio:", y) } }, ys = () => { try { const d = JSON.parse(Gs), m = ao.value || "a friendly robot"; d.subject = m, Mo != null && Mo.checked ? (typeof d.negative_prompt == "string" && (d.negative_prompt = d.negative_prompt.replace(", ground/drop shadows", "")), d.lighting && (d.lighting.shadows = "soft ground shadow beneath the object")) : (typeof d.negative_prompt == "string" && !d.negative_prompt.includes("ground/drop shadows") && (d.negative_prompt += ", ground/drop shadows"), d.lighting && (d.lighting.shadows = "internal occlusion only, no ground shadow")); const y = g("#background-color-picker-3d"); y && d.background && (d.background.color = y.value); const h = g("#object-color-picker-3d"); return h && d.colors && (d.colors.dominant_blue = h.value), Do && (Do.value = JSON.stringify(d, null, 2)), d } catch (d) { console.error("Failed to build 3D prompt template", d); try { const m = JSON.parse(Gs); return Do && (Do.value = JSON.stringify(m, null, 2)), m } catch (m) { return console.error("Failed to parse default 3D prompt template", m), Do && (Do.value = ""), {} } } }, fl = (d, m = "", y = !1) => { var B; const h = d.subject || "a friendly robot", C = ((B = d.background) == null ? void 0 : B.color) || "#FFFFFF", E = d.colors || {}, b = d.materials || {}, w = d.lighting || {}, S = d.form || {}, I = d.composition || {}, A = d.guidance || {}, L = d.camera || {}, x = d.negative_prompt || "", _ = []; _.push(" CRITICAL STYLE REQUIREMENT "), _.push("You MUST generate this icon in the EXACT same visual style as the reference Creon 3D icon sheet."), _.push("The style is NON-NEGOTIABLE and must be applied to ANY subject, regardless of what the subject is."), _.push("STYLE CHARACTERISTICS (MANDATORY FOR ALL ICONS):"), _.push("- Smooth, glossy plastic material with high-gloss finish"), _.push("- Isometric 3D perspective (35deg tilt, 35deg pan, orthographic lens)"), _.push("- Soft, uniform lighting with no harsh shadows"), _.push("- Color palette: Dominant blue (#2E6BFF), secondary blue (#4FC3F7), white (#FFFFFF), warm accent yellow (#FFD45A)"), _.push("- Pillowy, inflated, soft-volume forms with rounded edges (85% fillet)"), _.push("- Chibi/stylized proportions, simplified anatomy"), _.push("- Floating subject with no ground contact"), _.push("- Clean white background (#FFFFFF)"), _.push("- Single hero subject, minimal composition"), _.push("- No photographic realism, no textures, no noise, no grain"), _.push("- Consistent rendering quality matching the reference sheet exactly"), _.push(""), _.push(`SUBJECT: Generate an isometric 3D icon of ${h}.`), m && m.trim() && (_.push(`Additional instruction: ${m.trim()}.`), _.push(" IMPORTANT: Apply the additional instruction while MAINTAINING the exact style described above. The style must NEVER change regardless of the subject or instruction.")); const M = A.aspect_ratio || "16:9"; if (M === "16:9" ? _.push(" OUTPUT REQUIREMENT: Output must be exactly 1024x576 pixels (16:9 landscape). Never return a square or 1024x1024 image. Maintain landscape orientation with width greater than height.") : _.push(` OUTPUT REQUIREMENT: Output must follow ${M} aspect ratio and provided width/height.`), _.push(""), _.push(" STYLE CONSISTENCY ENFORCEMENT:"), _.push("- The visual style described above is ABSOLUTE and must be applied to this specific subject."), _.push("- Do NOT adapt the style to the subject - adapt the subject to the style."), _.push("- Every icon must look like it came from the same design system, regardless of what it represents."), _.push("- Maintain the exact same material properties, lighting setup, color palette, and rendering quality."), y) _.push(" FIX MODE: Maintain the existing model, proportions, silhouette, and camera. Only adjust colors as specified."), _.push(`Background color: ${C}. Main palette: ${E.dominant_blue || "#2E6BFF"} and ${E.neutral_white || "#FFFFFF"}.`); else { _.push(" COLOR SPECIFICATION:"), _.push(`Background: solid ${C}.`); const O = []; E.dominant_blue && O.push(`dominant blue ${E.dominant_blue}`), E.secondary_blue && O.push(`secondary blue ${E.secondary_blue}`), E.neutral_white && O.push(`neutral white ${E.neutral_white}`), E.warm_accent && O.push(`warm accent ${E.warm_accent} used sparingly`), O.length && (_.push(`Color palette (MUST USE): ${O.join(", ")}.`), _.push(" Apply these colors while maintaining the exact style. The color palette is part of the style identity.")), E.inherent_colors && _.push(`Inherent colors: ${E.inherent_colors}.`) } const F = []; b.primary && F.push(`primary material ${b.primary}`), b.secondary && F.push(`secondary material ${b.secondary}`), b.accents && F.push(`accents ${b.accents}`), b.surface_detail && F.push(`surface detail ${b.surface_detail}`), F.length && (_.push(` MATERIALS (MANDATORY): ${F.join(", ")}.`), _.push(" These material properties are FIXED and must be applied to every icon regardless of subject.")); const U = []; S.shapes && U.push(S.shapes), S.edges && U.push(S.edges), S.proportions && U.push(S.proportions), S.deformation && U.push(S.deformation), S.surface_finish && U.push(S.surface_finish), U.length && (_.push(` FORM (MANDATORY): ${U.join(", ")}.`), _.push(" These form characteristics define the visual identity and must be consistent across all icons.")); const Z = []; w.mode && Z.push(w.mode), w.source && Z.push(w.source), w.highlights && Z.push(`highlights ${w.highlights}`), w.shadows && Z.push(`shadows ${w.shadows}`), w.exposure && Z.push(`exposure ${w.exposure}`), Z.length && (_.push(` LIGHTING (MANDATORY): ${Z.join(", ")}.`), _.push(" This lighting setup is FIXED and creates the signature look. Must be identical for all icons.")); const J = []; L.type && J.push(L.type), L.lens && J.push(`${L.lens} lens`), L.tilt && J.push(`tilt ${L.tilt}`), L.pan && J.push(`pan ${L.pan}`), L.distance && J.push(L.distance), L.focus && J.push(`focus ${L.focus}`), L.motion && J.push(`motion ${L.motion}`), J.length && (_.push(` CAMERA (MANDATORY): ${J.join(", ")}.`), _.push(" This camera angle is FIXED and creates the isometric perspective. Must be identical for all icons.")); const z = []; return I.elements && z.push(I.elements), I.density && z.push(I.density), I.framing && z.push(I.framing), I.depth && z.push(I.depth), z.length && (_.push(` COMPOSITION (MANDATORY): ${z.join(", ")}.`), _.push(" This composition structure is FIXED and ensures visual consistency across all icons.")), y || _.push(" LAYOUT REQUIREMENT: Ensure the subject remains centered, floating, and fully contained within the frame with clean margins."), _.push(""), _.push(" FINAL STYLE ENFORCEMENT:"), _.push("- Maintain the specified aspect ratio (1024x576 for 16:9)."), _.push("- Do NOT introduce additional objects, text, watermarks, or background elements."), _.push("- The style must be IDENTICAL to the reference Creon 3D icon sheet."), _.push("- Every visual element (material, lighting, color, form, camera) must match the reference style exactly."), _.push("- The subject can change, but the style CANNOT change."), x && (_.push(""), _.push(` NEGATIVE PROMPT (MUST AVOID): ${x}.`), _.push(" These elements are FORBIDDEN and would break the style consistency.")), _.push(""), _.push(" REMINDER: This icon must look like it was created by the same artist, using the same tools, with the same style guide, as all other icons in the reference sheet. The visual language is FIXED and UNIVERSAL."), _.join(" ") }, Iu = async () => { if (!ao.value) { G({ type: "error", title: "Input Required", body: "Please enter a subject for your image." }), ao.focus(); return } qi(X), _t && (_t.textContent = "Generating image"), X == null || X.classList.remove("hidden"); let d = null; try { const m = ys(), y = JSON.stringify(m, null, 2), h = fl(m); if (d = await Ya(h, tt, Ys, Ks, hn, os, P, "16:9"), d) { const C = { id: `img_${Date.now()}`, data: d.data, mimeType: d.mimeType, subject: ao.value, styleConstraints: y, timestamp: Date.now(), videoDataUrl: void 0, motionPrompt: null }; await ai(C), n = C, i.splice(r + 1), i.push(C), r = i.length - 1, Zn(C); const E = `data:${C.mimeType};base64,${C.data}`, b = { id: C.id, dataUrl: E, mimeType: C.mimeType }; yt.unshift(b), yt.length > 20 && yt.pop(), hs(), Ui(), xn(), fe == null || fe.classList.remove("hidden"), fe == null || fe.classList.add("is-open"), li(), pn(), setTimeout(() => { pn() }, 100), setTimeout(() => { pn() }, 300), jt(), X && (_n(X), X.classList.add("hidden")) } } catch (m) { console.error("Error generating 3D image:", m), G({ type: "error", title: "Generation Failed", body: "Failed to generate image. Please try again." }), X && X.classList.add("hidden") } }, Za = async () => { console.log("handleGenerateImageMain called"); const d = document.getElementById("generate-input"), m = document.getElementById("studio-selector"); if (!(d != null && d.value.trim())) { console.log("No input provided"), G({ type: "error", title: "Input Required", body: "Please enter a prompt for your image." }), d == null || d.focus(); return } const y = d.value.trim(), h = (m == null ? void 0 : m.value) || "3d"; console.log("User prompt:", y, "Selected studio:", h), ds && (h === "icon" ? ds.textContent = "Generating icon" : ds.textContent = "Generating image"), ei && (console.log("Showing loading modal"), ei.classList.remove("hidden")); const C = document.getElementById("generate-btn"); C && (C.classList.add("loading"), C.setAttribute("disabled", "true")); try { let E, b; if (h === "icon") { const S = JSON.parse(Os); S.subject = y || "a friendly robot"; const I = !1, A = 400; S.controls.style.fill.enabled = I, S.controls.style.weight = A, b = JSON.stringify(S, null, 2), E = b } else { const S = JSON.parse(Gs); S.subject = y || "a friendly robot", b = JSON.stringify(S, null, 2), E = fl(S) } console.log("Generated prompt:", E), console.log("Calling generateImage..."); const w = await Ya(E, null, null, null, null, C, _o ? [{ dataUrl: _o, file: null }] : [], h === "3d" ? "16:9" : void 0, 1); if (console.log("Image generation result:", w), w && w.data && w.mimeType) { const S = { id: h === "icon" ? `img_2d_${Date.now()}` : `img_main_${Date.now()}`, data: w.data, mimeType: w.mimeType, subject: y, styleConstraints: b, timestamp: Date.now(), videoDataUrl: void 0, motionPrompt: null, modificationType: "Original" }; console.log("Created new image object:", S), h === "3d" && await Su(S); const I = `data:${S.mimeType};base64,${S.data}`, A = { id: S.id, dataUrl: I, mimeType: S.mimeType }; yt.unshift(A), yt.length > 20 && yt.splice(20), ei && ei.classList.add("hidden"), G({ type: "success", title: "Image Generated!", body: h === "icon" ? "Your icon has been created successfully." : "Your 3D image has been created successfully." }), _n(), h === "icon" ? (console.log("Navigating to 2D Studio..."), Lu(S)) : (console.log("Navigating to 3D Studio..."), _u(S)) } else throw console.error("Image generation returned invalid data:", w), new Error("Image generation failed: Invalid response data") } catch (E) { console.error("Error generating image:", E), ei && ei.classList.add("hidden"), G({ type: "error", title: "Generation Failed", body: "Failed to generate image. Please try again." }) } finally { C && (C.classList.remove("loading"), C.removeAttribute("disabled")) } }, Su = async d => { if (d) try { const m = `data:${d.mimeType};base64,${d.data}`; d.videoDataUrl = m, d.motionPrompt = null } catch (m) { console.error("Error setting initial motion frames:", m) } }, Lu = d => { const m = document.getElementById("page-id-2d"); if (m) { document.querySelectorAll(".page-container").forEach(h => { h.classList.add("hidden") }), m.classList.remove("hidden"), document.querySelectorAll(".nav-item").forEach(h => { h.classList.remove("active") }); const y = document.querySelector('[data-page="page-id-2d"]'); y && y.classList.add("active"), re = "page-id-2d", Ro(), a = d, c.splice(f + 1), c.push(d), f = c.length - 1, Xn(d), setTimeout(() => { Au(d) }, 100) } }, _u = d => { const m = document.getElementById("page-id-3d"); if (m) { document.querySelectorAll(".page-container").forEach(C => { C.classList.add("hidden") }), m.classList.remove("hidden"), document.querySelectorAll(".nav-item").forEach(C => { C.classList.remove("active") }); const y = document.querySelector('[data-page="page-id-3d"]'); y && y.classList.add("active"), re = "page-id-3d", Ro(), n = d, i = [d], r = 0, ai(d), v = [{ ...d, modificationType: "Original" }], T = 0, hs(), Ui(), setTimeout(() => { xu(d) }, 100) } }, Au = d => { console.log("update2DStudioUIWithImage called with:", d), on && d.subject && (on.value = d.subject, Vi()), dn(), ve == null || ve.classList.remove("hidden"), ve == null || ve.classList.add("is-open"), yo(), setTimeout(() => { At() }, 100) }, xu = d => { var B, O; console.log("update3DStudioUIWithImage called with:", d); const m = document.querySelector("#page-id-3d .result-image"); if (m && d.data && d.mimeType) { const q = `data:${d.mimeType};base64,${d.data}`; console.log("Setting result image src:", q.substring(0, 50) + "..."), console.log("Result image element found:", m), m.src = q, m.classList.remove("hidden"), m.classList.add("visible"), m.onload = () => { console.log("Result image loaded successfully"), console.log("Image dimensions:", m.naturalWidth, "x", m.naturalHeight) }, m.onerror = te => { console.error("Error loading result image:", te), console.error("Failed dataUrl:", q.substring(0, 100)) } } else console.error("Result image element not found or invalid image data", { resultImage: !!m, hasData: !!d.data, hasMimeType: !!d.mimeType, imageDataKeys: Object.keys(d) }); const y = g("#prompt-display-3d"); y && d.styleConstraints && (y.value = d.styleConstraints); const h = g("#user-prompt-3d"); h && d.subject && (h.value = d.subject); const C = g("#image-prompt-subject-input"); C && d.subject && (C.value = d.subject); const E = g("#id-3d-placeholder"), b = g("#id-3d-error-placeholder"), w = g("#result-placeholder"), S = document.querySelector("#page-id-3d #result-idle-placeholder"), I = document.querySelector("#page-id-3d #motion-prompt-placeholder"); E && E.classList.add("hidden"), b && b.classList.add("hidden"), w && w.classList.add("hidden"), S && S.classList.add("hidden"), I && I.classList.add("hidden"); const A = document.querySelector("#page-id-3d .result-container"); A ? (A.classList.remove("hidden"), console.log("Result container shown")) : console.error("Result container not found"); const L = `data:${d.mimeType};base64,${d.data}`, x = g("#details-preview-image"), _ = g("#details-download-btn"); x && _ && (x.src = L, _.href = L, _.download = `${d.subject.replace(/\s+/g, "_")}.png`, console.log("Details panel preview and download updated")); const M = g("#motion-thumbnail-image"), F = g("#motion-thumbnail-label"); if (M && F && (M.src = L, F.textContent = d.subject, console.log("Motion thumbnail updated")), d.styleConstraints) try { const q = JSON.parse(d.styleConstraints), te = g("#details-background-color-picker-3d"), Y = g("#details-object-color-picker-3d"); te && ((B = q.background) != null && B.color) && (te.value = q.background.color, Qt(te), console.log("Background color updated:", q.background.color)), Y && ((O = q.colors) != null && O.dominant_blue) && (Y.value = q.colors.dominant_blue, Qt(Y), console.log("Object color updated:", q.colors.dominant_blue)) } catch (q) { console.error("Failed to parse style constraints:", q) } const U = g("#image-details-panel"); U && (U.classList.remove("hidden"), U.classList.add("is-open"), console.log("Details panel shown"), n && v.length === 0 && (console.log("[3D Studio] Initializing empty history with current image"), Zn(n)), setTimeout(() => { jt() }, 100)); const Z = document.querySelector("#page-id-3d .preview-switcher"); Z && Z.classList.remove("hidden"); const J = document.querySelector('#page-id-3d .preview-switcher-btn[data-view="image"]'), z = document.querySelector('#page-id-3d .preview-switcher-btn[data-view="video"]'); J && J.classList.add("active"), z && z.classList.remove("active"), Es(), ja(), console.log("3D Studio UI updated successfully") }, pl = d => { const m = new FileReader; m.onload = y => { var w; const h = (w = y.target) == null ? void 0 : w.result; _o = h; const C = Oe == null ? void 0 : Oe.querySelector(".drop-zone-preview"), E = Oe == null ? void 0 : Oe.querySelector(".drop-zone-prompt"); C && E && (C.src = h, C.classList.remove("hidden"), E.classList.add("hidden")), mo && mo.classList.remove("hidden"); const b = Oe == null ? void 0 : Oe.querySelector(".drop-zone-overlay"); b && b.classList.remove("hidden") }, m.readAsDataURL(d) }, ku = () => { _o = null; const d = Oe == null ? void 0 : Oe.querySelector(".drop-zone-preview"), m = Oe == null ? void 0 : Oe.querySelector(".drop-zone-prompt"); d && m && (d.src = "", d.classList.add("hidden"), m.classList.remove("hidden")), mo && mo.classList.add("hidden"); const y = Oe == null ? void 0 : Oe.querySelector(".drop-zone-overlay"); y && y.classList.add("hidden") }, ri = g("#image-temperature-input-image"), ml = g("#image-temperature-label"), gl = () => { let d = 1; return ri && (d = parseFloat(ri.value || ""), Number.isNaN(d) && (d = 1), d = Math.min(1, Math.max(.1, d)), ri.value = d.toFixed(1), ml && (ml.textContent = d.toFixed(1))), d }; ri == null || ri.addEventListener("input", () => { gl() }); const Ru = async () => {
    var A, L, x, _, M, F, U, Z, J, z, B, O, q, te, Y, Q; const d = g("#image-prompt-subject-input-image"), m = ((A = d == null ? void 0 : d.value) == null ? void 0 : A.trim()) || "", y = gl(), h = g("#image-generation-loader-modal"), C = g("#image-generate-btn-image"), E = g(".result-image-image"), b = g(".result-placeholder"), w = g("#result-idle-placeholder-image"), S = g(".result-error"), I = g("#image-prompt-display-image"); _t && (_t.textContent = "Generating image"), h == null || h.classList.remove("hidden"), b == null || b.classList.add("hidden"), w == null || w.classList.add("hidden"), E == null || E.classList.add("hidden"), S == null || S.classList.add("hidden"), Re(C, !0); try {
      const H = qe.filter(pe => pe !== null).length; if (H >= 2) {
        if (!m) { G({ type: "error", title: "Prompt Required", body: "Please enter a prompt." }), Re(C, !1), h == null || h.classList.add("hidden"); return } console.log(`[Image Studio] Starting composition with ${H} reference images`), console.log("[Image Studio] User prompt:", m); const se = `You are creating a composed image based on the user's description and ${H === 2 ? "two" : "three"} reference images.
User's request: "${m}"
Instructions:
1. Analyze all reference images
2. Integrate the elements from the reference images according to the user's description
3. The final image should look natural and cohesive, not a weird hybrid
4. Maintain the style and quality of the reference images
Make sure the result is photorealistic and aesthetically pleasing.`; console.log("[Image Studio] Composition prompt:", se); const me = []; me.push({ text: se }); for (let he = 0; he < qe.length; he++)qe[he] && (console.log(`[Image Studio] Adding reference image ${he + 1}`), me.push({ inlineData: { data: await Dt(qe[he].file), mimeType: qe[he].file.type } })); console.log("[Image Studio] Sending request with", me.length, "parts"); const Le = await Xe.models.generateContent({ model: "gemini-2.5-flash-image", contents: { parts: me }, config: { responseModalities: [St.IMAGE], temperature: y } }); console.log("[Image Studio] Composition complete"); const ge = (M = (_ = (x = (L = Le.candidates) == null ? void 0 : L[0]) == null ? void 0 : x.content) == null ? void 0 : _.parts) == null ? void 0 : M[0]; if (ge && ge.inlineData) { const { data: he, mimeType: oe } = ge.inlineData, De = `data:${oe};base64,${he}`; E.src = De, E.classList.remove("hidden"), w == null || w.classList.add("hidden"), b == null || b.classList.add("hidden"); const ze = document.querySelector(".result-content-header-image"); ze && ze.classList.remove("hidden"), h && (_n(h), h.classList.add("hidden")), I && (I.value = "Subject placed in scene"); const je = Date.now(); V = { id: `img_${je}`, data: he, mimeType: oe, subject: ((F = qe[0]) == null ? void 0 : F.file.name) || "", styleConstraints: ((U = qe[1]) == null ? void 0 : U.file.name) || "", timestamp: je, modificationType: "Original", rightPanelHistory: [{ id: `img_${je}`, data: he, mimeType: oe, subject: ((Z = qe[0]) == null ? void 0 : Z.file.name) || "", styleConstraints: ((J = qe[1]) == null ? void 0 : J.file.name) || "", timestamp: je, modificationType: "Original" }] }, _e.push(V), Ie = _e.length - 1; const be = g("#image-studio-history-panel"); be == null || be.classList.remove("hidden"); const et = g("#image-details-panel-image"), Qe = g("#details-preview-image-image"), mn = g("#details-download-btn-image"); Qe && (Qe.src = De), mn && (mn.href = De), await ul(V), et == null || et.classList.remove("hidden"), et == null || et.classList.add("is-open"), Qn(), Ts(), G({ type: "success", title: "Composed!", body: "Image composition completed." }) }
      } else { const pe = qe[0] || qe[1]; if (pe && !m) { G({ type: "error", title: "Prompt Required", body: "Please enter a prompt to edit the image." }), Re(C, !1), h == null || h.classList.add("hidden"); return } const se = []; m && se.push({ text: m }); for (let ge = 0; ge < qe.length; ge++)qe[ge] && (console.log(`[Image Studio] Adding reference image ${ge + 1}`), se.push({ inlineData: { data: await Dt(qe[ge].file), mimeType: qe[ge].file.type } })); if (console.log(`[Image Studio] Sending request with ${se.length} parts`), console.log("[Image Studio] Model: gemini-2.5-flash-image"), console.log("[Image Studio] Temperature:", y), console.log("[Image Studio] Has AI instance:", !!Xe), !Xe || !Xe.models || !Xe.models.generateContent) throw new Error("AI instance not properly initialized. Please check your API key."); const Le = (q = (O = (B = (z = (await Xe.models.generateContent({ model: "gemini-2.5-flash-image", contents: { parts: se }, config: { responseModalities: [St.IMAGE], temperature: y } })).candidates) == null ? void 0 : z[0]) == null ? void 0 : B.content) == null ? void 0 : O.parts) == null ? void 0 : q[0]; if (Le && Le.inlineData) { const { data: ge, mimeType: he } = Le.inlineData, oe = `data:${he};base64,${ge}`; E.src = oe, E.classList.remove("hidden"), w == null || w.classList.add("hidden"), b == null || b.classList.add("hidden"); const De = document.querySelector(".result-content-header-image"); De && De.classList.remove("hidden"), h && (_n(h), h.classList.add("hidden")), I && (I.value = m || "Based on reference image"); const ze = Date.now(); V = { id: `img_${ze}`, data: ge, mimeType: he, subject: ((te = qe[0]) == null ? void 0 : te.file.name) || m || "", styleConstraints: m || "", timestamp: ze, modificationType: "Original", rightPanelHistory: [{ id: `img_${ze}`, data: ge, mimeType: he, subject: ((Y = qe[0]) == null ? void 0 : Y.file.name) || m || "", styleConstraints: m || "", timestamp: ze, modificationType: "Original" }] }, _e.push(V), Ie = _e.length - 1; const je = g("#image-studio-history-panel"); je == null || je.classList.remove("hidden"); const be = g("#image-details-panel-image"), et = g("#details-preview-image-image"), Qe = g("#details-download-btn-image"); et && (et.src = oe), Qe && (Qe.href = oe), await ul(V), be == null || be.classList.remove("hidden"), be == null || be.classList.add("is-open"), Qn(), Ts(), G({ type: "success", title: "Success!", body: pe && m ? "Image edited successfully." : "Image generated successfully." }) } else G({ type: "error", title: "Missing Input", body: "Please upload images or enter a prompt." }) }
    } catch (H) { console.error("Image generation failed:", H), console.error("Error details:", { name: H == null ? void 0 : H.name, message: H == null ? void 0 : H.message, stack: H == null ? void 0 : H.stack }); let ee = "Could not generate image."; (Q = H == null ? void 0 : H.message) != null && Q.includes("Failed to fetch") ? ee = "Network error. Please check your connection and API key." : H != null && H.message && (ee = H.message), G({ type: "error", title: "Generation Failed", body: ee }), S == null || S.classList.remove("hidden") } finally { Re(C, !1), h == null || h.classList.add("hidden") }
  }, Du = /cinematic|movie|film look|film-style|film style/gi, Qa = "Keep the existing subject gently looping while preserving its original pose and design.", vo = d => { if (!d) return Qa; let m = d.replace(Du, " "); if (m = m.replace(/\s+/g, " ").trim(), !m) return Qa; const y = [/\badd(?:ing)?\b.*\bnew\b/i, /\bintroduce(?:s|d|ing)?\b/i, /\btransform(?:s|ed|ing)?\b/i, /\bturn(?:s|ed)? into\b/i, /\bmorph(?:s|ed|ing)?\b/i, /\breplace(?:s|d|ing)?\b/i, /\bswap(?:s|ped|ping)?\b/i, /\bchange(?:s|d|ing)?\b.*\binto\b/i, /\bcompletely\b.*\bchange\b/i, /\bbrand new\b/i]; let E = m.split(new RegExp("(?<=[.!?])\\s+")).map(b => b.trim()).filter(b => b.length > 0 && !y.some(w => w.test(b))).join(" "); return E || (E = Qa), /keep the subject fully visible/i.test(E) || (E += " Keep the subject fully visible within the frame."), !/maintain the original/i.test(E) && !/preserve the original/i.test(E) && (E += " Maintain the original proportions, accessories, and style."), E.trim() }, hl = async () => { var d; if (!n || !n.motionPrompt || !K) { G({ type: "error", title: "Missing Data", body: "Cannot generate video without an image and motion prompt." }); return } Re(bn, !0), Re(qt, !0), Et && jo && (Et.classList.remove("hidden"), jo.textContent = "Generating Video..."); try { const m = document.getElementById("motion-prompt-final-english").value, y = vo(m), h = "16:9", C = `CRITICAL: Do NOT create new content. Only animate the existing content from the source image. Keep the exact same subject, colors, style, and composition. Only add movement to the existing elements. Movement Instructions: ${y}. Do not add new objects, characters, or elements. Do not change the appearance, colors, proportions, or design of existing elements. Preserve the exact background from the source image. Maintain the exact same visual style and design. no black bars, no letterboxing, full-frame composition, fill the entire frame. Maintain full frame coverage with no black bars, borders, or letterboxing. Keep the entire image visible. Preserve the exact background from the source image without any cropping or black bars. CRITICAL NEGATIVE PROMPT: black bars, letterboxing, black borders, black edges, cinematic crop, pillarbox, narrow frame, cropped edges, missing background, new objects, new characters, new elements, changing appearance, changing colors. Use 16:9 aspect ratio.`, E = { numberOfVideos: 1, resolution: "1080p", aspectRatio: "16:9" }, b = ((d = document.querySelector('input[name="motion-model"]:checked')) == null ? void 0 : d.value) || "veo-3.1-fast-generate-preview", w = g("#motion-prompt-final-english"); w && (w.value = C); const S = { model: b, prompt: C, config: E }; K && (S.image = { imageBytes: await Dt(K.file), mimeType: K.file.type }), j && (S.config.lastFrame = { imageBytes: await Dt(j.file), mimeType: j.file.type }); let I = await Xe.models.generateVideos(S); for (ye = I; !I.done;)await new Promise(F => setTimeout(F, 1e4)), I = await Xe.operations.getVideosOperation({ operation: I }), ye = I; const A = _a(I); if (!A) throw console.error("[3D Video] Missing download link. Operation response:", JSON.stringify(I, null, 2)), new Error("Video generation succeeded but no download link was found."); const L = await fetch(`${A}&key=${ji()}`); if (!L.ok) throw new Error(`Failed to download video: ${L.statusText}`); const x = await L.blob(), _ = URL.createObjectURL(x); n.videoDataUrl = _; const M = i.find(F => F.id === n.id); M && (M.videoDataUrl = _), ro && (ro.src = _, Lo(ro), ro.classList.remove("hidden"), tt == null || tt.classList.add("hidden"), Fo == null || Fo.classList.add("hidden")), Ft == null || Ft.click(), Es(), G({ type: "success", title: "Video Generated!", body: "Your animated image is ready." }) } catch (m) { console.error("Video generation failed:", m), G({ type: "error", title: "Video Failed", body: "Something went wrong during video generation." }), Xo && Xo.classList.remove("loading") } finally { Re(bn, !1), Re(qt, !1), ye = null, Et == null || Et.classList.add("hidden") } }, yl = async () => { var d; if (!V || !V.motionPrompt || !ue) { G({ type: "error", title: "Missing Data", body: "Cannot generate video without an image and motion prompt." }); return } Re(In, !0), Re(Gt, !0), Et && jo && (Et.classList.remove("hidden"), jo.textContent = "Generating Video..."); try { const m = document.getElementById("motion-prompt-final-english-image").value, y = vo(m), h = "16:9", C = `CRITICAL: Do NOT create new content. Only animate the existing content from the source image. Keep the exact same subject, colors, style, and composition. Only add movement to the existing elements. Movement Instructions: ${y}. Do not add new objects, characters, or elements. Do not change the appearance, colors, proportions, or design of existing elements. Preserve the exact background from the source image. Maintain the exact same visual style and design. no black bars, no letterboxing, full-frame composition, fill the entire frame. Maintain full frame coverage with no black bars, borders, or letterboxing. Keep the entire image visible. Preserve the exact background from the source image without any cropping or black bars. CRITICAL NEGATIVE PROMPT: black bars, letterboxing, black borders, black edges, cinematic crop, pillarbox, narrow frame, cropped edges, missing background, new objects, new characters, new elements, changing appearance, changing colors. Use 16:9 aspect ratio.`, E = { numberOfVideos: 1, resolution: "1080p", aspectRatio: "16:9" }, b = ((d = document.querySelector('input[name="motion-model-image"]:checked')) == null ? void 0 : d.value) || "veo-3.1-fast-generate-preview", w = g("#motion-prompt-final-english-image"); w && (w.value = C); const S = { model: b, prompt: C, config: E }; ue && (S.image = { imageBytes: await Dt(ue.file), mimeType: ue.file.type }), Fe && (S.config.lastFrame = { imageBytes: await Dt(Fe.file), mimeType: Fe.file.type }); let I = await Xe.models.generateVideos(S); for (ye = I; !I.done;)await new Promise(F => setTimeout(F, 1e4)), I = await Xe.operations.getVideosOperation({ operation: I }), ye = I; const A = _a(I); if (!A) throw console.error("[Image Studio Video] Missing download link. Operation response:", JSON.stringify(I, null, 2)), new Error("Video generation succeeded but no download link was found."); const L = await fetch(`${A}&key=${ji()}`); if (!L.ok) throw new Error(`Failed to download video: ${L.statusText}`); const x = await L.blob(), _ = URL.createObjectURL(x); V.videoDataUrl = _; const M = _e.find(F => F.id === V.id); M && (M.videoDataUrl = _), Zt && (Zt.src = _, Zt.classList.remove("hidden"), wn == null || wn.classList.add("hidden"), Vt == null || Vt.classList.add("hidden")), Xt && (Xt.classList.add("active"), Kt == null || Kt.classList.remove("active")), Ts(), G({ type: "success", title: "Video Generated!", body: "Your animated image is ready." }) } catch (m) { console.error("Video generation failed:", m), G({ type: "error", title: "Video Failed", body: "Something went wrong during video generation." }); const y = g("#motion-video-container-image"); y && y.classList.remove("loading") } finally { Re(In, !1), Re(Gt, !1), ye = null, Et == null || Et.classList.add("hidden") } }, Nu = [{ name: "jsDelivr", coreURL: "https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/esm/ffmpeg-core.js", wasmURL: "https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/esm/ffmpeg-core.wasm" }, { name: "unpkg", coreURL: "https://unpkg.com/@ffmpeg/core@0.12.6/dist/esm/ffmpeg-core.js", wasmURL: "https://unpkg.com/@ffmpeg/core@0.12.6/dist/esm/ffmpeg-core.wasm" }], vs = async () => { if (Lt && $e) return console.log("[FFmpeg] Using cached instance"), $e; let d = null; for (const m of Nu) try { console.log(`[FFmpeg] Initializing FFmpeg via ${m.name}...`), G({ type: "success", title: "Loading Video Converter", body: `Preparing FFmpeg (${m.name}). This may take a moment.` }); const y = new yv; return y.on("log", ({ message: h }) => { console.log("[FFmpeg]", h) }), console.log(`[FFmpeg] Loading core from ${m.coreURL}`), await y.load({ coreURL: m.coreURL, wasmURL: m.wasmURL }), $e = y, Lt = !0, console.log("[FFmpeg] Loaded successfully"), y } catch (y) { d = y, console.error(`[FFmpeg] Failed to load from ${m.name}:`, y), console.error("[FFmpeg] Error details:", { name: y == null ? void 0 : y.name, message: y == null ? void 0 : y.message, stack: y == null ? void 0 : y.stack }), $e = null, Lt = !1 } throw G({ type: "error", title: "FFmpeg Error", body: "Unable to load the video converter. Please check your network connection and try again." }), d || new Error("Failed to load FFmpeg from all sources") }, Pu = async d => { let m = null; try { console.log("[GIF Conversion] Starting...", d), Re(Wn, !0), m = window.setTimeout(() => { throw console.error("[GIF Conversion] Timeout after 3 minutes"), G({ type: "error", title: "Conversion Timeout", body: "GIF conversion is taking too long. Please try again or use a shorter video." }), new Error("Conversion timeout") }, 180 * 1e3), console.log("[GIF Conversion] Loading FFmpeg..."); const y = await vs(); let h = [], C = Date.now(); const E = ({ message: F }) => { if (console.log("[FFmpeg Progress]", F), h.push(F), C = Date.now(), Ue && h.length > 0) { const U = h[h.length - 1]; (U.includes("frame=") || U.includes("size=")) && (Ue.textContent = `Converting to GIF... ${U}`) } }; y.on("log", E), console.log("[GIF Conversion] Fetching video file..."); const b = await wr(d), w = b instanceof Uint8Array ? b.length : b.byteLength || 0; if (console.log("[GIF Conversion] Video data fetched, size:", w), w === 0) throw new Error("Video file is empty"); console.log("[GIF Conversion] Writing input file..."), await y.writeFile("input.mp4", b), console.log("[GIF Conversion] Input file written successfully"), console.log("[GIF Conversion] Converting to GIF..."), Ue && (Ue.textContent = "Converting to GIF... This may take a minute."); let S = null; S = window.setInterval(() => { Date.now() - C > 3e4 && (console.warn("[GIF Conversion] No progress for 30 seconds, conversion may be stuck"), Ue && (Ue.textContent = "Conversion is taking longer than expected...")) }, 1e4); try { await y.exec(["-i", "input.mp4", "-vf", "fps=8,scale=-1:720,crop=720:720", "-loop", "0", "-y", "output.gif"]), console.log("[GIF Conversion] FFmpeg exec completed") } finally { S && clearInterval(S), y.off("log", E) } console.log("[GIF Conversion] Reading output..."); const I = await y.readFile("output.gif"), A = I instanceof Uint8Array ? I.length : I.byteLength || 0; if (console.log("[GIF Conversion] GIF data read, size:", A), A === 0) throw new Error("Generated GIF file is empty"); let L; if (I instanceof Uint8Array) L = I; else { const F = I.buffer || I; L = F instanceof ArrayBuffer ? new Uint8Array(F) : new Uint8Array(F) } const x = L.buffer.slice(L.byteOffset, L.byteOffset + L.byteLength), _ = new Blob([x], { type: "image/gif" }), M = URL.createObjectURL(_); return m && (clearTimeout(m), m = null), console.log("[GIF Conversion] Complete!", M), G({ type: "success", title: "GIF Created!", body: "Your animated GIF is ready." }), M } catch (y) { throw console.error("[GIF Conversion] Failed:", y), console.error("[GIF Conversion] Error details:", { name: y == null ? void 0 : y.name, message: y == null ? void 0 : y.message, stack: y == null ? void 0 : y.stack }), m && (clearTimeout(m), m = null), G({ type: "error", title: "Conversion Failed", body: (y == null ? void 0 : y.message) || "Could not convert video to GIF. Please try again." }), y } finally { Re(Wn, !1), Ue && (Ue.textContent = "Generating your icon...") } }, Mu = async (d, m) => { let y = null; try { console.log("[WebM Conversion] Starting...", d), y = window.setTimeout(() => { throw console.error("[WebM Conversion] Timeout after 3 minutes"), G({ type: "error", title: "Conversion Timeout", body: "WebM conversion is taking too long. Please try again or use a shorter video." }), new Error("Conversion timeout") }, 180 * 1e3), console.log("[WebM Conversion] Loading FFmpeg..."); const h = await vs(); let C = [], E = Date.now(); const b = ({ message: U }) => { if (console.log("[FFmpeg Progress]", U), C.push(U), E = Date.now(), m && C.length > 0) { const Z = C[C.length - 1]; Z.includes("frame=") || Z.includes("size=") ? m(`Converting to WebM... ${Z}`) : m("Converting to WebM... This may take a minute.") } }; h.on("log", b), console.log("[WebM Conversion] Fetching video file..."); const w = await wr(d), S = w instanceof Uint8Array ? w.length : w.byteLength || 0; if (console.log("[WebM Conversion] Video data fetched, size:", S), S === 0) throw new Error("Video file is empty"); console.log("[WebM Conversion] Writing input file..."), await h.writeFile("input.mp4", w), console.log("[WebM Conversion] Converting to WebM..."), m && m("Converting to WebM... This may take a minute."); let I = null; I = window.setInterval(() => { Date.now() - E > 3e4 && (console.warn("[WebM Conversion] No progress for 30 seconds, conversion may be stuck"), m && m("Conversion is taking longer than expected...")) }, 1e4); try { try { await h.exec(["-i", "input.mp4", "-c:v", "libvpx-vp9", "-crf", "30", "-b:v", "0", "-c:a", "libopus", "-b:a", "128k", "-f", "webm", "-y", "output.webm"]), console.log("[WebM Conversion] FFmpeg exec completed with libvpx-vp9") } catch (U) { console.warn("[WebM Conversion] libvpx-vp9 failed, trying libvpx:", U), await h.exec(["-i", "input.mp4", "-c:v", "libvpx", "-crf", "30", "-b:v", "0", "-c:a", "libvorbis", "-b:a", "128k", "-f", "webm", "-y", "output.webm"]), console.log("[WebM Conversion] FFmpeg exec completed with libvpx (VP8)") } } catch (U) { throw console.error("[WebM Conversion] FFmpeg exec failed:", U), console.error("[WebM Conversion] Error details:", { name: U == null ? void 0 : U.name, message: U == null ? void 0 : U.message, stack: U == null ? void 0 : U.stack }), U } finally { I && clearInterval(I), h.off("log", b) } console.log("[WebM Conversion] Reading output..."); const A = await h.readFile("output.webm"), L = A instanceof Uint8Array ? A.length : A.byteLength || 0; if (console.log("[WebM Conversion] WebM data read, size:", L), L === 0) throw new Error("Generated WebM file is empty"); let x; if (A instanceof Uint8Array) x = A; else { const U = A.buffer || A; x = U instanceof ArrayBuffer ? new Uint8Array(U) : new Uint8Array(U) } const _ = x.buffer.slice(x.byteOffset, x.byteOffset + x.byteLength), M = new Blob([_], { type: "video/webm" }), F = URL.createObjectURL(M); return y && (clearTimeout(y), y = null), console.log("[WebM Conversion] Complete!", F), G({ type: "success", title: "WebM Created!", body: "Your WebM video is ready." }), F } catch (h) { throw console.error("[WebM Conversion] Failed:", h), console.error("[WebM Conversion] Error details:", { name: h == null ? void 0 : h.name, message: h == null ? void 0 : h.message, stack: h == null ? void 0 : h.stack }), y && clearTimeout(y), G({ type: "error", title: "WebM Conversion Failed", body: (h == null ? void 0 : h.message) || "Failed to convert video to WebM. Please try again." }), h } }, Fu = async (d, m) => { let y = null; try { console.log("[WebP Conversion] Starting...", d), console.log("[WebP Conversion] Video URL type:", typeof d), console.log("[WebP Conversion] Video URL:", d), y = window.setTimeout(() => { throw console.error("[WebP Conversion] Timeout after 3 minutes"), G({ type: "error", title: "Conversion Timeout", body: "WebP conversion is taking too long. Please try again or use a shorter video." }), new Error("Conversion timeout") }, 180 * 1e3), console.log("[WebP Conversion] Loading FFmpeg..."); const h = await vs(); let C = [], E = Date.now(); const b = ({ message: U }) => { if (console.log("[FFmpeg Progress]", U), C.push(U), E = Date.now(), m && C.length > 0) { const Z = C[C.length - 1]; Z.includes("frame=") || Z.includes("size=") ? m(`Converting to WebP... ${Z}`) : m("Converting to WebP... This may take a minute.") } }; h.on("log", b), console.log("[WebP Conversion] Fetching video file..."); const w = await wr(d), S = w instanceof Uint8Array ? w.length : w.byteLength || 0; if (console.log("[WebP Conversion] Video data fetched, size:", S), S === 0) throw new Error("Video file is empty"); console.log("[WebP Conversion] Writing input file..."), await h.writeFile("input.mp4", w), console.log("[WebP Conversion] Converting to WebP..."), m && m("Converting to WebP... This may take a minute."); let I = null; I = window.setInterval(() => { Date.now() - E > 3e4 && (console.warn("[WebP Conversion] No progress for 30 seconds, conversion may be stuck"), m && m("Conversion is taking longer than expected...")) }, 1e4); try { try { await h.exec(["-i", "input.mp4", "-vf", "fps=10,scale=-1:720", "-c:v", "libwebp", "-quality", "80", "-loop", "0", "-preset", "default", "-an", "-y", "output.webp"]), console.log("[WebP Conversion] FFmpeg exec completed with libwebp") } catch (U) { console.warn("[WebP Conversion] libwebp failed, trying alternative method:", U), await h.exec(["-i", "input.mp4", "-vf", "fps=10,scale=-1:720", "-c:v", "libwebp", "-lossless", "0", "-quality", "80", "-loop", "0", "-an", "-y", "output.webp"]), console.log("[WebP Conversion] FFmpeg exec completed with alternative libwebp settings") } } catch (U) { throw console.error("[WebP Conversion] FFmpeg exec failed:", U), console.error("[WebP Conversion] Error details:", { name: U == null ? void 0 : U.name, message: U == null ? void 0 : U.message, stack: U == null ? void 0 : U.stack }), console.error("[WebP Conversion] Note: libwebp codec might not be available in browser FFmpeg build"), U } finally { I && clearInterval(I), h.off("log", b) } console.log("[WebP Conversion] Reading output..."); const A = await h.readFile("output.webp"), L = A instanceof Uint8Array ? A.length : A.byteLength || 0; if (console.log("[WebP Conversion] WebP data read, size:", L), L === 0) throw new Error("Generated WebP file is empty"); let x; if (A instanceof Uint8Array) x = A; else { const U = A.buffer || A; x = U instanceof ArrayBuffer ? new Uint8Array(U) : new Uint8Array(U) } const _ = x.buffer.slice(x.byteOffset, x.byteOffset + x.byteLength), M = new Blob([_], { type: "image/webp" }), F = URL.createObjectURL(M); return y && (clearTimeout(y), y = null), console.log("[WebP Conversion] Complete!", F), G({ type: "success", title: "WebP Created!", body: "Your animated WebP is ready." }), F } catch (h) { throw console.error("[WebP Conversion] Failed:", h), console.error("[WebP Conversion] Error details:", { name: h == null ? void 0 : h.name, message: h == null ? void 0 : h.message, stack: h == null ? void 0 : h.stack }), y && clearTimeout(y), G({ type: "error", title: "WebP Conversion Failed", body: (h == null ? void 0 : h.message) || "Failed to convert video to WebP. Please try again." }), h } }, Uu = async () => { if (!a || !a.videoDataUrl) { G({ type: "error", title: "No Video", body: "Generate a video first." }); return } console.log("[2D GIF] Starting conversion...", a.videoDataUrl), we && Ue && (Ue.textContent = "Converting to GIF...", we.classList.remove("hidden")); try { const d = await Pu(a.videoDataUrl); console.log("[2D GIF] Conversion successful, updating state..."), a.gifDataUrl = d; const m = c.find(y => y.id === a.id); m && (m.gifDataUrl = d), Ve == null || Ve.classList.add("hidden"), Kn(), console.log("[2D GIF] State updated successfully") } catch (d) { console.error("[2D GIF] Conversion failed:", d), console.error("[2D GIF] Error details:", { name: d == null ? void 0 : d.name, message: d == null ? void 0 : d.message, stack: d == null ? void 0 : d.stack }) } finally { we && we.classList.add("hidden") } }, $u = async () => { if (!a || !a.videoDataUrl) { G({ type: "error", title: "No Video", body: "Generate a video first." }); return } console.log("[2D WebM] Starting conversion...", a.videoDataUrl), we && Ue && (Ue.textContent = "Converting to WebM...", we.classList.remove("hidden")); try { const d = await Mu(a.videoDataUrl, y => { Ue && (Ue.textContent = y) }); console.log("[2D WebM] Conversion successful, updating state..."), a.webmDataUrl = d; const m = c.find(y => y.id === a.id); m && (m.webmDataUrl = d), Ve == null || Ve.classList.add("hidden"), Kn(), console.log("[2D WebM] State updated successfully") } catch (d) { console.error("[2D WebM] Conversion failed:", d) } finally { we && we.classList.add("hidden") } }, qu = async () => { if (!a || !a.videoDataUrl) { G({ type: "error", title: "No Video", body: "Generate a video first." }); return } console.log("[2D WebP] Starting conversion...", a.videoDataUrl), we && Ue && (Ue.textContent = "Converting to WebP...", we.classList.remove("hidden")); try { const d = await Fu(a.videoDataUrl, y => { Ue && (Ue.textContent = y) }); console.log("[2D WebP] Conversion successful, updating state..."), a.webpDataUrl = d; const m = c.find(y => y.id === a.id); m && (m.webpDataUrl = d), Ve == null || Ve.classList.add("hidden"), Kn(), console.log("[2D WebP] State updated successfully") } catch (d) { console.error("[2D WebP] Conversion failed:", d) } finally { we && we.classList.add("hidden") } }, vl = async () => {
    var d; if (console.log("[2D Video] Starting video generation..."), console.log("[2D Video] currentGeneratedImage2d:", a), console.log("[2D Video] motionPrompt:", a == null ? void 0 : a.motionPrompt), console.log("[2D Video] motionFirstFrameImage2d:", le), !a || !a.motionPrompt || !le) { console.error("[2D Video] Missing required data"), G({ type: "error", title: "Missing Data", body: "Generate a motion prompt first." }); return } Re(En, !0), Re(Ut, !0), Et && jo && (Et.classList.remove("hidden"), jo.textContent = "Generating Video..."); try {
      console.log("[2D Video] Preparing video generation payload..."); const m = (ft == null ? void 0 : ft.value) || ""; console.log("[2D Video] User prompt:", m); let y = m.trim(); y = y.replace(/breathing|breath|breathing-like/gi, "uniform scale").replace(/pulsing|pulse/gi, "uniform scale").replace(/expands?|contracts?|grows?|shrinks?/gi, "uniform scale").replace(/rotates?|spins?|turns?/gi, "rotate").replace(/floats?|rises?|falls?|bounces?|vertical|up|down|upward|downward/gi, "").replace(/sways?|moves? horizontally|shifts? left|shifts? right|horizontal displacement/gi, "horizontal translate").replace(/gentle|smooth|subtle|minimal/gi, "precise").replace(/seamless/gi, "continuous").replace(/effect/gi, "transform").replace(/centered in place|in place/gi, "centered transform").replace(/maintain.*proportions|original proportions/gi, "maintain exact pixel positions"); const h = y.match(/scale\s*([\d.]+)\s*to\s*([\d.]+)|scale\s*([\d.]+)|(\d+)%/i); let C = ""; if (h) if (h[4]) C = ` (scale range: 1.0 to ${(1 + parseFloat(h[4]) / 100).toFixed(3)})`; else { const F = h[1] || h[3] || "1.0", U = h[2] || "1.03"; C = ` (scale range: ${F} to ${U})` } y = `${y}${C}. 

 ABSOLUTE CRITICAL REQUIREMENT 
Apply this motion as a PURE MATHEMATICAL TRANSFORM to the COMPLETE icon as a SINGLE RIGID BODY. The icon is a FROZEN STATIC IMAGE - think of it as a PNG file in a video editor where ONLY the transform matrix (scale/rotate/translate) changes. The icon image itself is PERMANENTLY LOCKED and CANNOT be modified in ANY way.

MANDATORY CONSTRAINTS:
- The icon shape, lines, edges, curves, and ALL visual elements must remain 100% PIXEL-PERFECT IDENTICAL
- Every pixel must stay in the EXACT same position relative to the icon's coordinate system
- Only the ENTIRE icon's transform matrix can change (scale/rotate/translate applied to the whole icon as one unit)
- NO shape deformation, NO line changes, NO pixel movement, NO structural modifications
- The icon must look like a static image being zoomed/rotated/moved, NOT an animated drawing`; const E = ` CRITICAL: NO LIQUID, NO FLOW, NO DEFORMATION 

 ULTIMATE RULE - READ THIS FIRST 
 This is NOT a morph - ABSOLUTELY NO MORPHING ALLOWED
 This is NOT a shape change - THE SHAPE CAN NEVER CHANGE
 It is a simple position shift - ONLY MOVE THE ENTIRE ICON AS ONE UNIT
 Use camera translation, not deformation - CAMERA MOVES, ICON STAYS IDENTICAL
  NO VERTICAL MOVEMENT - ONLY horizontal movement allowed (NO up/down/floating/rising/falling/bouncing)
 The icon is a FROZEN STATIC IMAGE - like a photograph or printed sticker
 Only the camera/viewport moves horizontally - the icon itself NEVER changes
  NO FLOWING EFFECTS: The icon must NEVER appear to flow, drip, melt, or deform like liquid
  LINES ARE FROZEN: Every line, curve, and edge is PERMANENTLY LOCKED - they cannot bend, warp, or change shape
  SHAPE IS ABSOLUTE: The icon's silhouette, outline, and internal structure are 100% FIXED - like a laser-cut stencil

 ABSOLUTE PROHIBITION 
DO NOT create liquid, flowing, melting, or fluid-like motion. DO NOT deform, warp, or morph the icon shape. DO NOT change ANY lines, curves, edges, or shapes. The icon is a RIGID, SOLID object that can ONLY move as a whole unit.

THIS IS A STATIC RASTER IMAGE FILE (PNG format). THE ICON IMAGE ITSELF IS PERMANENTLY FROZEN AND ABSOLUTELY CANNOT BE MODIFIED IN ANY WAY.

 CRITICAL CLARIFICATION - REPEATED FOR EMPHASIS 
 This is NOT a morph - NO MORPHING WHATSOEVER
 This is NOT a shape change - SHAPE IS PERMANENTLY LOCKED
 It is a simple position shift - ONLY TRANSLATION ALLOWED
 Use camera translation, not deformation - CAMERA MOVES, ICON DOES NOT CHANGE

 LINE ART / VECTOR ICON PRESERVATION 
This is a LINE ART or VECTOR-STYLE icon. Every single line, curve, edge, corner, and detail is PERMANENTLY FIXED.
- Lines must remain EXACTLY the same thickness, length, and curvature - they are FROZEN
- Curves must remain EXACTLY the same shape and position - they cannot bend or warp
- Edges must remain EXACTLY the same angle and sharpness - they are LOCKED
- NO line deformation, NO curve modification, NO edge smoothing, NO corner rounding
- NO flowing lines, NO wavy lines, NO liquid-like line movement
- The icon's line structure is ABSOLUTELY IMMUTABLE - like a printed sticker or a laser-cut shape
- Think of the icon as a RIGID STENCIL - the lines are carved in stone and CANNOT change

 MANDATORY REQUIREMENT 
This is NOT an animated drawing or illustration. This is a STATIC IMAGE FILE being animated with geometric transform properties ONLY (like CSS transform: scale/rotate/translate or After Effects transform controls).

The source image is a FROZEN RASTER. Every single pixel must remain in the EXACT same position relative to the icon's coordinate system. The icon image file itself NEVER changes - it is a FIXED, UNCHANGEABLE static image.

 LIQUID/FLUID MOTION IS COMPLETELY FORBIDDEN 
- NO liquid-like flow, NO dripping, NO melting, NO water-like movement
- NO organic, fluid, or elastic motion that suggests the icon is made of liquid or flexible material
- NO flowing shapes, NO morphing lines, NO deforming edges
- The icon is SOLID and RIGID - like a metal coin, printed sticker, or laser-cut acrylic
- Motion must be MECHANICAL and RIGID, not organic or fluid
- The icon must look like a SOLID OBJECT being moved, NOT a liquid being poured
- Every pixel of the icon is FROZEN - like a photograph that can only be moved, rotated, or scaled

 SHAPE PRESERVATION IS ABSOLUTE AND NON-NEGOTIABLE 
- The icon's shape, form, silhouette, and ALL geometric properties are PERMANENTLY LOCKED
- Every line, curve, edge, corner, and detail must remain 100% IDENTICAL in every frame
- The icon must appear as if it's a photograph being zoomed/rotated/moved, NOT a drawing being animated
- Think: Take a screenshot of frame 1, apply ONLY transform matrix changes (scale/rotate/translate), that's the ONLY difference between frames
- If you compare frame 1 and frame N side-by-side, they should be IDENTICAL except for position/rotation/scale
- The icon's visual appearance (lines, shapes, details) must be PIXEL-PERFECT IDENTICAL across ALL frames

 ANIMATION INSTRUCTION:
${y}

 REMEMBER: This is NOT a morph, NOT a shape change. It is ONLY a simple position shift using camera translation, NOT deformation. 

 ALLOWED TRANSFORMS ONLY (applied to the COMPLETE icon as ONE RIGID UNIT):
- Uniform scale: Scale the ENTIRE icon uniformly (like zooming a photo) - maximum 1.0 to 1.03
- Rotation: Rotate the ENTIRE icon as one piece (like spinning a coin on a table)
- Horizontal translation ONLY: Move the ENTIRE icon horizontally (left/right) - like moving a sticker on paper
-  VERTICAL MOVEMENT IS FORBIDDEN: NO up/down movement, NO floating, NO rising, NO falling, NO bouncing
- These transforms apply to the COMPLETE icon simultaneously as a SINGLE RIGID OBJECT
- NO independent part movement, NO separate element animation, NO component-level changes

 ABSOLUTELY FORBIDDEN - THE ICON FILE CANNOT CHANGE IN ANY WAY 
-  VERTICAL MOVEMENT IS FORBIDDEN: NO up/down movement, NO floating, NO rising, NO falling, NO bouncing, NO vertical translation
-  FLOWING/DEFORMING IS FORBIDDEN: NO flowing shapes, NO deforming lines, NO morphing edges, NO liquid-like appearance
- ANY shape deformation, morphing, warping, bending, stretching, or distortion (COMPLETELY FORBIDDEN)
- ANY line thickness changes, wavy lines, curved lines becoming straight, or straight lines becoming curved (COMPLETELY FORBIDDEN)
- ANY flowing, dripping, melting, liquid-like, water-like, or fluid-like effects (THIS IS THE #1 PRIORITY - COMPLETELY FORBIDDEN)
- ANY appearance that the icon is "flowing", "melting", "deforming", or "changing shape" (COMPLETELY FORBIDDEN)
- The icon must look EXACTLY like the source image in every frame - like a static PNG being moved
- ANY elastic, rubber-like, organic, flexible, or soft material behavior (COMPLETELY FORBIDDEN)
- ANY motion that suggests the icon is made of liquid, water, gel, or any fluid substance (COMPLETELY FORBIDDEN)
- ANY wave-like, ripple-like, or undulating motion that deforms the shape (COMPLETELY FORBIDDEN)
- ANY line movement, curve modification, edge deformation, or corner changes (COMPLETELY FORBIDDEN)
- ANY part of the icon changing shape, size, or position relative to other parts (COMPLETELY FORBIDDEN)
- ANY part of the icon moving independently from other parts
- ANY color changes, fading, blending, or opacity changes
- ANY new elements appearing or existing elements disappearing
- ANY camera movement, zoom, perspective changes, or lens effects
- ANY particle effects, trails, glows, shadows, or visual artifacts
- DO NOT interpret motion words (swimming, flying, running, etc.) as shape changes - these are just transform descriptions
- NO pixel-level changes, NO rasterization effects, NO anti-aliasing changes
- NO edge smoothing, NO outline changes, NO fill pattern changes
- NO vector path changes, NO bezier curve modifications, NO anchor point movement
- NO texture changes, NO material changes, NO surface property changes
- The icon must remain PIXEL-PERFECT IDENTICAL in every single frame

 TECHNICAL REQUIREMENT 
The icon must appear IDENTICAL in every single frame - as if you took a screenshot of the first frame and applied ONLY CSS transform properties (scale/rotate/translate) to it. The icon image file itself is a FIXED, UNCHANGEABLE static image.

Think: PNG image file + CSS transform = The PNG file NEVER changes, only its transform matrix changes. Motion words in the instruction describe HOW to transform the icon, NOT how to change the icon's shape.

IMAGINE: You have a PNG file on your computer. You open it in a video editor and apply ONLY transform controls (scale, rotation, position). The PNG file itself remains 100% unchanged - only its position, rotation, and scale in the video change. That is EXACTLY what you must do here.

 NEGATIVE PROMPT (MUST AVOID AT ALL COSTS):
shape deformation, morphing, warping, distortion, line changes, thickness changes, pixel changes, rasterization, anti-aliasing changes, edge smoothing, outline changes, fill changes, color changes, opacity changes, independent part movement, camera movement, zoom, perspective, particle effects, trails, glows, shadows, visual artifacts, organic movement, fluid movement, elastic movement, rubber movement, material changes, texture changes, icon shape changes, vector changes, path changes, bezier curve changes, anchor point movement, component animation, separate element movement, part-by-part animation`; console.log("[2D Video] Final prompt:", E); const b = { numberOfVideos: 1, resolution: "1080p", aspectRatio: "16:9" }, w = ((d = document.querySelector('input[name="p2d-motion-model"]:checked')) == null ? void 0 : d.value) || "veo-3.1-fast-generate-preview"; ft && (ft.value = E); const S = { model: w, prompt: E, negativePrompt: "vertical movement, up, down, upward, downward, floating, rising, falling, bouncing, vertical translation, vertical displacement, flowing, flowing shape, flowing lines, deforming, morphing, morph, shape change, shape deformation, liquid, fluid, dripping, melting, water-like, gel-like, liquid motion, fluid motion, wave motion, ripple effect, undulating, organic flow, liquid deformation, fluid deformation, shape deformation, morphing, warping, distortion, line changes, thickness changes, pixel changes, rasterization, anti-aliasing changes, edge smoothing, outline changes, fill changes, color changes, opacity changes, independent part movement, camera movement, zoom, perspective, particle effects, trails, glows, shadows, visual artifacts, organic movement, fluid movement, elastic movement, rubber movement, material changes, texture changes, icon shape changes, vector changes, path changes, bezier curve changes, anchor point movement, component animation, separate element movement, part-by-part animation, shape modification, geometry changes, structural changes, form changes, silhouette changes, edge deformation, curve modification, corner rounding, detail loss, pixel displacement, raster distortion, image warping, perspective distortion, lens distortion, barrel distortion, pincushion distortion, breathing effect distortion, pulsing shape change, organic scaling, non-uniform scaling, anisotropic scaling, shearing, skewing, stretching, compression, elongation, contraction, expansion, growth, shrinking, size variation, dimension changes, aspect ratio changes, proportional changes, liquid flow, fluid flow, water flow, gel flow, liquid animation, fluid animation, wave-like motion, ripple-like motion, undulating motion, organic deformation, fluid deformation, liquid-like behavior, fluid-like behavior, deformation, flowing appearance, melting appearance, deforming appearance, camera translation only, position shift only", config: b }; le && (S.image = { imageBytes: await Dt(le.file), mimeType: le.file.type }), de && (S.config.lastFrame = { imageBytes: await Dt(de.file), mimeType: de.file.type }), console.log("[2D Video] Calling generateVideos API with payload:", S); let I = await Xe.models.generateVideos(S); for (console.log("[2D Video] Initial operation response:", I), ye = I; !I.done;)console.log("[2D Video] Waiting for operation to complete..."), await new Promise(F => setTimeout(F, 1e4)), I = await Xe.operations.getVideosOperation({ operation: I }), console.log("[2D Video] Operation status:", I), ye = I; console.log("[2D Video] Operation completed!"); const A = _a(I); if (!A) throw console.error("[2D Video] Missing download link. Operation response:", JSON.stringify(I, null, 2)), console.error("[2D Video] Operation keys:", Object.keys(I)), I.response && console.error("[2D Video] Response keys:", Object.keys(I.response)), G({ type: "error", title: "Video Generation Issue", body: "Video was generated but download link could not be found. Please check the console for details." }), new Error("Video generation succeeded but no download link was found."); console.log("[2D Video] Download link found:", A); const L = await fetch(`${A}&key=${ji()}`); if (!L.ok) throw new Error(`Failed to download video: ${L.statusText}`); const x = await L.blob(), _ = URL.createObjectURL(x); a.videoDataUrl = _; const M = c.find(F => F.id === a.id); M && (M.videoDataUrl = _), Pe && (Pe.src = _, Pe.classList.remove("hidden"), Ce == null || Ce.classList.add("hidden"), Se == null || Se.classList.add("hidden")), We == null || We.classList.add("active"), lt == null || lt.classList.remove("active"), Kn(), G({ type: "success", title: "Motion Ready!", body: "Your animated icon is ready." })
    } catch (m) { console.error("[2D Video] Video generation failed:", m), console.error("[2D Video] Error details:", JSON.stringify(m, null, 2)), G({ type: "error", title: "Video Failed", body: "Something went wrong during video generation." }), lo == null || lo.classList.remove("loading") } finally { Re(En, !1), Re(Ut, !1), ye = null, Et == null || Et.classList.add("hidden") }
  }, Ts = () => { if (!V) return; const d = g("#motion-prompt-output-image"), m = g("#motion-prompt-final-english-image"), y = g("#motion-prompt-korean-image"), h = !!V.motionPrompt, C = !!V.videoDataUrl; if (h && m && y) { const w = m.value.trim(), S = V.motionPrompt.english.trim(); (w === S || w === "") && (m.value = V.motionPrompt.english), y.textContent = V.motionPrompt.korean, d && d.classList.remove("hidden") } else d && d.classList.add("hidden"); const E = g("#motion-video-player-image"), b = g("#motion-video-container-image"); if (E && (C ? (E.src = V.videoDataUrl, b && b.classList.remove("loading"), b && b.classList.remove("hidden")) : (E.src = "", b && b.classList.add("hidden"))), po && (C ? (po.href = V.videoDataUrl, po.download = `${V.subject.replace(/\s+/g, "_")}_motion.mp4`) : (po.removeAttribute("href"), po.removeAttribute("download")), po.classList.toggle("hidden", !C)), Ra == null || Ra.classList.toggle("hidden", !C), Mi && Mi.classList.toggle("hidden", !C), Tt == null || Tt.classList.add("hidden"), fo && rn && In && Gt && po && (C ? (fo.classList.add("hidden"), In.classList.add("hidden"), rn.classList.add("hidden"), Gt.classList.add("hidden")) : h ? (fo.classList.add("hidden"), In.classList.remove("hidden"), rn.classList.remove("hidden"), Gt.classList.add("hidden")) : (fo.classList.remove("hidden"), In.classList.add("hidden"), rn.classList.add("hidden"), Gt.classList.add("hidden")), C || Tt == null || Tt.classList.add("hidden")), el && tl) { const w = `data:${V.mimeType};base64,${V.data}`; el.src = w, tl.textContent = V.subject } }, Es = () => { if (!n || !wa || !uo || !an || !bn || !qt || !ls || !Xo) return; const d = g("#motion-prompt-final-english"), m = g("#motion-prompt-korean"), y = !!n.motionPrompt, h = !!n.videoDataUrl; if (y && d && m) { const C = d.value.trim(), E = n.motionPrompt.english.trim(); (C === E || C === "") && (d.value = n.motionPrompt.english), m.textContent = n.motionPrompt.korean, wa.classList.remove("hidden") } else wa.classList.add("hidden"); Ta && (h ? (Ta.src = n.videoDataUrl, Xo.classList.remove("loading"), Xo.classList.remove("hidden")) : (Ta.src = "", Xo.classList.add("hidden"))), ls && h && (ls.href = n.videoDataUrl, ls.download = `${n.subject.replace(/\s+/g, "_")}_motion.mp4`), h ? (uo.classList.add("hidden"), bn.classList.add("hidden"), an.classList.add("hidden"), qt.classList.add("hidden"), Zo && Zo.classList.remove("hidden")) : y ? (uo.classList.add("hidden"), bn.classList.remove("hidden"), an.classList.remove("hidden"), qt.classList.add("hidden"), Zo && Zo.classList.add("hidden")) : (uo.classList.remove("hidden"), bn.classList.add("hidden"), an.classList.add("hidden"), qt.classList.add("hidden"), Zo && Zo.classList.add("hidden")) }, Tl = d => {
    if (nt) {
      if (nt.innerHTML = "", !d || d.length === 0) { nt.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: var(--spacing-5);">Could not generate motion ideas. Please try again.</p>'; return } d.forEach((m, y) => {
        const h = document.createElement("button"); h.className = "category-item", h.innerHTML = `
            <div class="category-item-header">
                <h3 class="category-item-title">${m.name}</h3>
            </div>
            <p class="category-item-description">${m.description}</p>
        `, h.addEventListener("click", () => { if (!n) return; ke == null || ke.classList.add("hidden"); const C = vo(m.english || ""), b = { json: { ...m, english: C }, english: C, korean: m.korean }; n.motionPrompt = b; const w = i.find(I => I.id === n.id); w && (w.motionPrompt = b); const S = g("#motion-prompt-final-english"); S && (S.value = C), Es(), xe == null || xe.focus() }), nt.appendChild(h)
      })
    }
  }, Vu = async () => {
    if (!(!V || !nt)) try {
      const d = V.subject, m = `data:${V.mimeType};base64,${V.data}`, y = `Analyze the provided image of a '${d}'. Based on its appearance, create 5 unique and creative motion style suggestions for a short, looping video.
Hard rules for every suggestion:
- Absolutely preserve the subject's existing proportions, facial features, accessories, outfit, colors, lighting, background, and camera framing.
- Do NOT introduce, add, or remove any props, characters, wardrobe pieces, particles, or environmental elements.
- Describe only motions using the existing subject or existing environmental elements (e.g., gentle limb movement, breathing, water ripples, sunlight shifts) or subtle camera motion that keeps the subject fully visible.
- Avoid any wording about transforming, morphing, changing shapes, swapping outfits, or replacing parts of the subject.
- Motions must be seamless, looping, and subtle so that the source frame can be used as both the start and end without visible jumps.
For each suggestion, provide:
1. 'name': A short, catchy category name in Korean (e.g., ' ').
2. 'description': A brief, engaging description in Korean of the motion style. You can use <b> tags for emphasis (e.g., '<b>  .</b>    .').
3. 'english': A concise, direct text-to-video prompt in English that embodies the motion style. The prompt must explicitly state that no new props or subjects appear, that the original design stays intact, and that the subject remains fully visible within the frame.
4. 'korean': A lively, descriptive version of the prompt in Korean for the user to read, mentioning that it's a looping animation while also stating that     .
Return the 5 suggestions as a JSON array.`, E = { parts: [{ inlineData: { data: V.data, mimeType: V.mimeType } }, { text: y }] }, b = { type: Je.ARRAY, items: { type: Je.OBJECT, properties: { name: { type: Je.STRING, description: "A short, catchy category name in Korean." }, description: { type: Je.STRING, description: "An engaging description in Korean of the motion style, allowing <b> tags." }, english: { type: Je.STRING, description: "A concise text-to-video prompt in English." }, korean: { type: Je.STRING, description: "A lively, descriptive version of the prompt in Korean for the user." } }, required: ["name", "description", "english", "korean"] } }, w = await Xe.models.generateContent({ model: "gemini-2.5-pro", contents: E, config: { responseMimeType: "application/json", responseSchema: b } }), S = JSON.parse(w.text.trim()); X ? (_n(X), X.classList.add("hidden"), ke == null || ke.classList.remove("hidden"), El(S)) : (ke == null || ke.classList.remove("hidden"), El(S))
    } catch (d) { console.error("Failed to generate motion categories:", d), G({ type: "error", title: "Error", body: "Could not generate motion ideas." }), X && X.classList.add("hidden"), nt && (nt.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: var(--spacing-5);">An error occurred. Please close this and try again.</p>') }
  }, El = d => {
    if (nt) {
      if (nt.innerHTML = "", !d || d.length === 0) { nt.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: var(--spacing-5);">Could not generate motion ideas. Please try again.</p>'; return } d.forEach((m, y) => {
        const h = document.createElement("button"); h.className = "category-item", h.innerHTML = `
            <div class="category-item-header">
                <h3 class="category-item-title">${m.name}</h3>
            </div>
            <p class="category-item-description">${m.description}</p>
        `, h.addEventListener("click", () => { if (!V) return; ke == null || ke.classList.add("hidden"); const C = vo(m.english || ""), b = { json: { ...m, english: C }, english: C, korean: m.korean }; V.motionPrompt = b; const w = _e.find(I => I.id === V.id); w && (w.motionPrompt = b); const S = g("#motion-prompt-final-english-image"); S && (S.value = C), xe == null || xe.focus(), setTimeout(() => { Ts() }, 100) }), nt.appendChild(h)
      })
    }
  }, Gu = async () => {
    if (!(!a || !nt)) try {
      const m = `Analyze the provided vector-style icon of '${a.subject}'. Create 3 MINIMAL micro-interaction motion ideas - these must be EXTREMELY SUBTLE movements.

CRITICAL CONSTRAINTS - 2D Icon Micro-Interactions:
1. MINIMAL MOVEMENT ONLY:
   - Maximum 5% scale change (e.g., 1.0 to 1.05)
   - Maximum 10 degree rotation (for full icon rotation only)
   -  NO VERTICAL MOVEMENT (NO up/down, NO floating, NO bobbing, NO bouncing)
   - Horizontal movement ONLY (left/right, maximum 3-5 pixels)
   - NO large movements, NO position changes that alter composition
   
2. PRESERVE EVERYTHING:
   - Original icon shape, design, and layout MUST stay 100% identical
   - NO camera movement, NO zoom, NO perspective change
   - Icon must stay in the EXACT same position vertically (NO up/down movement)
   - Background color and transparency unchanged
   
3. ALLOWED MICRO-INTERACTIONS ONLY:
   - Gentle breathing/pulsing (scale 1.0  1.03) - expand and contract in place
   - Subtle rotation in place (5-10 degrees, full icon rotates around its center)
   - Horizontal sway (3-5 pixels left/right ONLY, NO vertical movement)
   - Gentle idle animation (horizontal oscillation or subtle scale, NO vertical bobbing)
   
4. STRICTLY FORBIDDEN:
   -  NO VERTICAL MOVEMENT: NO up/down, NO floating, NO rising, NO falling, NO bouncing, NO vertical bobbing
   - NO vertical shift, NO vertical translation, NO vertical displacement
   - NO swaying, swinging, or pendulum motions (unless horizontal only)
   - NO new elements, particles, effects, glows
   - NO composition changes
   - NO dramatic movements
   - NO flying, jumping, or large animations
   - NO camera work or scene changes

For each micro-interaction:
1. 'name': Korean title (: ' ', ' ', ' ')
2. 'description': Korean explanation with <b> tags
3. 'english': English prompt emphasizing "subtle", "gentle", "minimal", "in place", "seamless loop", "horizontal only" or "rotation only", "NO vertical movement"
4. 'korean': Korean description stating this is    

IMPORTANT: Focus on horizontal movements (left/right), scale changes (breathing), or gentle rotation. Absolutely NO vertical (up/down) movements. NO floating, NO bobbing, NO bouncing.

Return as JSON array with exactly 3 minimal suggestions.`, h = { parts: [{ inlineData: { data: a.data, mimeType: a.mimeType } }, { text: m }] }, C = { type: Je.ARRAY, items: { type: Je.OBJECT, properties: { name: { type: Je.STRING }, description: { type: Je.STRING }, english: { type: Je.STRING }, korean: { type: Je.STRING } }, required: ["name", "description", "english", "korean"] } }, E = await Xe.models.generateContent({ model: "gemini-2.5-pro", contents: h, config: { responseMimeType: "application/json", responseSchema: C } }), b = JSON.parse(E.text.trim()); if (X) if (_n(X), X.classList.add("hidden"), b && b.length >= 2) { const w = b[1]; if (!a) return; const S = vo(w.english || ""), A = { json: { ...w, english: S }, english: S, korean: w.korean }; a.motionPrompt = A; const L = c.find(x => x.id === a.id); L && (L.motionPrompt = A), ft && (ft.value = S), Se == null || Se.classList.add("hidden"), setTimeout(() => { Kn() }, 100) } else ke == null || ke.classList.remove("hidden"), bl(b); else if (b && b.length >= 2) { const w = b[1]; if (!a) return; const S = vo(w.english || ""), A = { json: { ...w, english: S }, english: S, korean: w.korean }; a.motionPrompt = A; const L = c.find(x => x.id === a.id); L && (L.motionPrompt = A), ft && (ft.value = S), Se == null || Se.classList.add("hidden"), setTimeout(() => { Kn() }, 100) } else ke == null || ke.classList.remove("hidden"), bl(b)
    } catch (d) { console.error("Failed to generate 2D motion categories:", d), G({ type: "error", title: "Error", body: "Could not generate motion ideas." }), X && X.classList.add("hidden"), nt && (nt.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: var(--spacing-5);">An error occurred. Please close this and try again.</p>') }
  }, bl = d => {
    if (nt) {
      if (nt.innerHTML = "", !d || d.length === 0) { nt.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: var(--spacing-5);">Could not generate motion ideas. Please try again.</p>'; return } d.forEach(m => {
        const y = document.createElement("button"); y.className = "category-item", y.innerHTML = `
            <div class="category-item-header">
                <h3 class="category-item-title">${m.name}</h3>
            </div>
            <p class="category-item-description">${m.description}</p>
        `, y.addEventListener("click", () => { if (!a) return; ke == null || ke.classList.add("hidden"); const h = vo(m.english || ""), E = { json: { ...m, english: h }, english: h, korean: m.korean }; a.motionPrompt = E; const b = c.find(w => w.id === a.id); b && (b.motionPrompt = E), ft && (ft.value = h), Se == null || Se.classList.add("hidden"), setTimeout(() => { Kn() }, 100), xe == null || xe.focus() }), nt.appendChild(y)
      })
    }
  }, Ou = async () => {
    if (!(!n || !nt)) try {
      const m = `Analyze the provided image of a '${n.subject}'. Based on its appearance, create 5 unique and creative motion style suggestions for a short, looping video.
Hard rules for every suggestion:
- Absolutely preserve the subject's existing proportions, facial features, accessories, outfit, colors, lighting, background, and camera framing.
- Do NOT introduce, add, or remove any props, characters, wardrobe pieces, particles, or environmental elements.
- Describe only motions using the existing subject or existing environmental elements (e.g., gentle limb movement, breathing, water ripples, sunlight shifts) or subtle camera motion that keeps the subject fully visible.
- Avoid any wording about transforming, morphing, changing shapes, swapping outfits, or replacing parts of the subject.
- Motions must be seamless, looping, and subtle so that the source frame can be used as both the start and end without visible jumps.
For each suggestion, provide:
1. 'name': A short, catchy category name in Korean (e.g., ' ').
2. 'description': A brief, engaging description in Korean of the motion style. You can use <b> tags for emphasis (e.g., '<b>  .</b>    .').
3. 'english': A concise, direct text-to-video prompt in English that embodies the motion style. The prompt must explicitly state that no new props or subjects appear, that the original design stays intact, and that the subject remains fully visible within the frame.
4. 'korean': A lively, descriptive version of the prompt in Korean for the user to read, mentioning that it's a looping animation while also stating that     .
Return the 5 suggestions as a JSON array.`, C = { parts: [{ inlineData: { data: n.data, mimeType: n.mimeType } }, { text: m }] }, E = { type: Je.ARRAY, items: { type: Je.OBJECT, properties: { name: { type: Je.STRING, description: "A short, catchy category name in Korean." }, description: { type: Je.STRING, description: "An engaging description in Korean of the motion style, allowing <b> tags." }, english: { type: Je.STRING, description: "A concise text-to-video prompt in English." }, korean: { type: Je.STRING, description: "A lively, descriptive version of the prompt in Korean for the user." } }, required: ["name", "description", "english", "korean"] } }, b = await Xe.models.generateContent({ model: "gemini-2.5-pro", contents: C, config: { responseMimeType: "application/json", responseSchema: E } }), w = JSON.parse(b.text.trim()); X ? (_n(X), X.classList.add("hidden"), ke == null || ke.classList.remove("hidden"), Tl(w)) : (ke == null || ke.classList.remove("hidden"), Tl(w))
    } catch (d) { console.error("Failed to generate motion categories:", d), G({ type: "error", title: "Error", body: "Could not generate motion ideas." }), X && X.classList.add("hidden"), nt && (nt.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: var(--spacing-5);">An error occurred. Please close this and try again.</p>') }
  }, ja = () => { if (!n) return; const d = g("#history-original-image"), m = g("#history-fixed-image"); if (d && n.originalData) { const y = `data:${n.originalMimeType};base64,${n.originalData}`; d.src = y } if (m) { const y = `data:${n.mimeType};base64,${n.data}`; m.src = y } }, xn = () => { var b, w; if (!n || !tt || !hn || !Ys || !Ks || !Vn) return; const d = `data:${n.mimeType};base64,${n.data}`; tt.src = d, tt.classList.remove("hidden"), ro.classList.add("hidden"), Fo == null || Fo.classList.add("hidden"), yn == null || yn.classList.add("active"), Ft == null || Ft.classList.remove("active"), setTimeout(() => tt.classList.add("visible"), 50), hn.classList.add("hidden"), Ys.classList.add("hidden"), Ks.classList.add("hidden"), Vn.classList.remove("hidden"); const m = g("#result-media-container-3d"); m && (m.style.backgroundImage = "", m.style.backgroundColor = "#ffffff"), is && No && (is.src = d, No.href = d, No.download = `${n.subject.replace(/\s+/g, "_")}.png`); const y = n.modificationType === "BG Removed" || n.modificationType === "SVG", h = g("#details-preview-container-3d"), C = g("#details-preview-checkerboard-checkbox-3d"), E = g("#details-preview-checkerboard-toggle-3d"); if (y) { E && (E.style.display = "flex"); const S = (I, A) => { I && (A ? (I.style.backgroundColor = "", I.style.backgroundImage = "repeating-linear-gradient(45deg, #f0f0f0 25%, transparent 25%, transparent 75%, #f0f0f0 75%, #f0f0f0), repeating-linear-gradient(45deg, #f0f0f0 25%, #ffffff 25%, #ffffff 75%, #f0f0f0 75%, #f0f0f0)", I.style.backgroundPosition = "0 0, 8px 8px", I.style.backgroundSize = "16px 16px") : (I.style.backgroundImage = "", I.style.backgroundColor = "#ffffff")) }; C ? S(h, C.checked) : S(h, !0) } else E && (E.style.display = "none"), h && (h.style.backgroundImage = "", h.style.backgroundColor = "#ffffff"); if (Qr && jr && (Qr.src = d, jr.textContent = n.subject), n.styleConstraints) try { const S = JSON.parse(n.styleConstraints); On && ((b = S.background) != null && b.color) && (On.value = S.background.color, Qt(On)), Hn && ((w = S.colors) != null && w.dominant_blue) && (Hn.value = S.colors.dominant_blue, Qt(Hn)) } catch (S) { console.error("Failed to parse style constraints:", S) } Es(), ja() }, li = () => {
    if (!(!Zs || !Qs || !zr || !ki || !Ri)) {
      if (i.length === 0) { Zs.classList.add("hidden"); return } Zs.classList.remove("hidden"), Qs.innerHTML = "", i.forEach((d, m) => {
        const y = document.createElement("li"); y.className = "history-item", m === r && y.classList.add("selected"), y.dataset.index = String(m); const C = new Date(d.timestamp).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }); y.innerHTML = `
        <div class="history-item-main">
            <img src="data:${d.mimeType};base64,${d.data}" class="history-thumbnail" alt="History item thumbnail">
            <div class="history-item-info">
            <span class="history-item-label">${d.subject}</span>
            <span class="history-item-timestamp">${C}</span>
            </div>
            <button class="history-item-delete-btn" aria-label="Delete history item">
                <span class="material-symbols-outlined">delete</span>
            </button>
        </div>
        `; const E = y.querySelector(".history-item-delete-btn"); E == null || E.addEventListener("click", b => { if (b.stopPropagation(), i.length === 1) { G({ type: "error", title: "Cannot Delete", body: "Cannot delete the last item in history." }); return } i.splice(m, 1), r >= m && r > 0 ? r-- : r >= i.length && (r = i.length - 1), i.length > 0 ? (n = i[r], Zn(n), ai(n), xn()) : (n = null, tt.src = "", tt.classList.add("hidden"), hn == null || hn.classList.remove("hidden"), Vn == null || Vn.classList.add("hidden")), li(), G({ type: "success", title: "Deleted", body: "Item removed from history." }) }), y.addEventListener("click", async () => { r = m, n = i[r], Zn(n), await ai(n), xn(), li() }), Qs.prepend(y)
      }), zr.textContent = `${r + 1} / ${i.length}`, ki.disabled = r <= 0, Ri.disabled = r >= i.length - 1
    }
  }, Qn = () => {
    const d = g("#image-studio-history-panel"), m = g("#history-list-image"), y = g("#history-counter-image"), h = g("#history-back-btn-image"), C = g("#history-forward-btn-image"); if (!(!d || !m || !y || !h || !C)) {
      if (_e.length === 0) { d.classList.add("hidden"); return } d.classList.remove("hidden"), m.innerHTML = "", _e.forEach((E, b) => {
        const w = document.createElement("li"); w.className = "history-item", b === Ie && w.classList.add("selected"), w.dataset.index = String(b); const I = new Date(E.timestamp).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }); w.innerHTML = `
        <div class="history-item-main">
            <img src="data:${E.mimeType};base64,${E.data}" class="history-thumbnail" alt="History item thumbnail">
            <div class="history-item-info">
            <span class="history-item-label">${E.subject}</span>
            <span class="history-item-timestamp">${I}</span>
            </div>
        </div>
        `, w.addEventListener("click", () => { Ie = b, V = _e[Ie]; const A = `data:${E.mimeType};base64,${E.data}`, L = g("#result-image-image"); L && (L.src = A, L.classList.remove("hidden")); const x = g("#image-details-panel-image"), _ = g("#details-preview-image-image"), M = g("#details-download-btn-image"); _ && (_.src = A), M && (M.href = A), x == null || x.classList.remove("hidden"), x == null || x.classList.add("is-open"), Qn() }), m.prepend(w)
      }), y.textContent = `${Ie + 1} / ${_e.length}`, h.disabled = Ie <= 0, C.disabled = Ie >= _e.length - 1
    }
  }; let dt = [], To = [], bs = 0; const er = 100; let tr = !1; const Hu = async () => {
    if (dt.length > 0) return dt; try { const d = await fetch("/material-icons-list.json"); if (d.ok) { if (dt = (await d.json()).icons || [], dt.length > 0) { const y = ["action", "alert", "av", "communication", "content", "device", "editor", "file", "hardware", "image", "maps", "navigation", "notification", "places", "social", "toggle", "transport"]; return dt.sort((h, C) => { const E = h.category || "uncategorized", b = C.category || "uncategorized", w = y.indexOf(E), S = y.indexOf(b); if (w !== -1 && S !== -1) { if (w !== S) return w - S } else { if (w !== -1) return -1; if (S !== -1) return 1; if (E !== b) return E.localeCompare(b) } const I = h.popularity || 0, A = C.popularity || 0; return I !== A ? A - I : h.name.localeCompare(C.name) }), console.log(` Loaded ${dt.length} icons from JSON file`), console.log(" First 10 icons:", dt.slice(0, 10).map(h => `${h.name} (${h.category || "no-cat"}, pop: ${h.popularity || 0})`)), dt } } else console.warn(` JSON file not found (status: ${d.status}), trying GitHub API`) } catch (d) { console.warn(" Material icons JSON file not found, trying GitHub API:", d) } try {
      const d = await fetch("https://raw.githubusercontent.com/google/material-design-icons/master/font/MaterialIcons-Regular.codepoints"); if (d.ok) return dt = (await d.text()).split(`
`).filter(h => h.trim()).map(h => { const [C] = h.split(" "), b = [...C.split("_").filter(w => w.length > 0), C]; return { name: C, tags: b } }), console.log(`Loaded ${dt.length} icons from Material Icons GitHub`), dt
    } catch { console.log("Failed to load from GitHub, using fallback") } return dt = [...cu], console.log(`Using ${dt.length} icons from ICON_DATA (fallback)`), dt
  }, nr = async (d = "", m = 0) => { var L; if (!es) return; dt.length === 0 && !tr && (tr = !0, console.log(" Loading Material Icons..."), await Hu(), console.log(` Total icons loaded: ${dt.length}`), tr = !1); const y = d.toLowerCase().trim(); y ? To = dt.filter(x => x.name.toLowerCase().includes(y) || x.tags && x.tags.some(_ => _.toLowerCase().includes(y))) : To = [...dt], console.log(` Filtered icons: ${To.length} (query: "${y}")`); const h = m * er, C = Math.min(h + er, To.length), E = To.slice(h, C); m === 0 && (es.innerHTML = ""); const b = [], w = []; E.forEach(x => { const _ = document.createElement("div"); _.className = "icon-item", _.dataset.iconName = x.name; const M = document.createElement("span"); M.className = "material-symbols-outlined", M.textContent = x.name, M.style.fontVariationSettings = "'FILL' 0, 'wght' 400, 'opsz' 24"; const F = document.createElement("span"); F.textContent = x.name.replace(/_/g, " "), _.appendChild(M), _.appendChild(F), _.addEventListener("click", () => Zu(x)), b.push(_) }), b.forEach(x => es.appendChild(x)), Wa(), setTimeout(() => { b.forEach(x => { const _ = x.querySelector("span:first-child"); if (_) { const F = window.getComputedStyle(_).fontFamily, U = F.includes("Material Symbols"), Z = _.offsetWidth, J = _.offsetHeight, z = Z / J; (!U || z > 2 && Z > 50) && (x.classList.add("icon-invalid", "hidden"), w.push(x), console.log(` Invalid icon detected and hidden: ${x.dataset.iconName} (font: ${F}, size: ${Z}x${J})`)) } }), w.length > 0 && (w.forEach(x => { x.remove() }), console.log(` Removed ${w.length} invalid icons from display`)) }, 100); const S = To.length, I = Math.min(C, S); let A = document.getElementById("icon-count-display"); A || (A = document.createElement("div"), A.id = "icon-count-display", A.style.cssText = "padding: var(--spacing-2) var(--spacing-4); color: var(--text-secondary); font-size: 14px; text-align: center;", (L = es.parentElement) == null || L.appendChild(A)), A.textContent = `Showing ${I} of ${S} icons${y ? " (filtered)" : ""}`, Bu() }, Bu = () => { if (!$n) return; const d = $n.__scrollHandler; d && $n.removeEventListener("scroll", d); const m = () => { const y = $n.scrollTop, h = $n.scrollHeight, C = $n.clientHeight; if (h - y - C < 200) { const E = Math.ceil(To.length / er); bs + 1 < E && (bs++, nr((so == null ? void 0 : so.value) || "", bs)) } }; $n.__scrollHandler = m, $n.addEventListener("scroll", m) }, or = () => { var b, w, S, I, A; if (!t) return null; const d = ((b = document.querySelector('input[name="icon-family"]:checked')) == null ? void 0 : b.value) || "Outlined", m = (w = g("#fill-toggle")) != null && w.checked ? 1 : 0, y = ((S = g("#weight-slider")) == null ? void 0 : S.value) || "400", h = ((I = g("#optical-size-slider")) == null ? void 0 : I.value) || "24", C = ((A = g("#export-size-input")) == null ? void 0 : A.value) || "48", E = (Yn == null ? void 0 : Yn.value) || "#0F172A"; return { name: t.name, style: d, fill: m, weight: y, opsz: h, size: parseInt(C, 10), color: E, fontVariationSettings: `'FILL' ${m}, 'wght' ${y}, 'opsz' ${h}` } }, Ju = d => {
    const m = or(); if (!m) return ""; const { name: y, style: h, size: C, color: E, fontVariationSettings: b } = m, w = `material-symbols-${h.toLowerCase()}`; switch (d) {
      case "react": return `<span
  className="${w}"
  style={{
    fontVariationSettings: "${b}",
    fontSize: "${C}px",
    color: "${E}"
  }}
>
  ${y}
</span>`; case "vue": return `<span
  class="${w}"
  :style="{
    fontVariationSettings: '${b}',
    fontSize: '${C}px',
    color: '${E}'
  }"
>
  ${y}
</span>`; case "svelte": case "html": default: return `<span
  class="${w}"
  style="
    font-variation-settings: ${b};
    font-size: ${C}px;
    color: ${E};
  "
>
  ${y}
</span>`}
  }, di = () => { if (!si) return; if (!t) { si.textContent = "Select an icon to generate code."; return } const d = ii == null ? void 0 : ii.querySelector(".snippet-tab-item.active"), m = (d == null ? void 0 : d.dataset.lang) || "html"; si.textContent = Ju(m) }, Cl = d => d.replace(/[^a-zA-Z0-9_-]/g, "_").replace(/_+/g, "_").replace(/^_|_$/g, "") || "icon", Wu = (d, m) => { const y = document.createElement("a"); y.download = Cl(m), y.href = d.toDataURL("image/png"), y.click() }, zu = (d, m, y) => { const h = new Blob([d], { type: y }), C = URL.createObjectURL(h), E = document.createElement("a"); E.download = Cl(m), E.href = C, E.click(), URL.revokeObjectURL(C) }, Yu = async () => {
    const d = or(); if (!d) return; const { name: m, style: y, size: h, color: C, fontVariationSettings: E } = d; X == null || X.classList.remove("hidden"); try {
      const b = document.createElement("div"); b.style.position = "absolute", b.style.left = "-9999px", b.style.top = "0", b.style.visibility = "hidden", b.style.width = `${h}px`, b.style.height = `${h}px`, b.style.display = "flex", b.style.alignItems = "center", b.style.justifyContent = "center", b.style.backgroundColor = "#FFFFFF"; const w = document.createElement("span"); w.textContent = m, w.className = `material-symbols-${y.toLowerCase()}`, w.style.fontVariationSettings = E, w.style.fontSize = `${h}px`, w.style.color = C, w.style.lineHeight = "1", w.style.fontFamily = `'Material Symbols ${y}'`, b.appendChild(w), document.body.appendChild(b), await document.fonts.ready, await new Promise(M => setTimeout(M, 200)); const S = Math.max(h * .1, 4), I = document.createElement("canvas"); I.width = h + S * 2, I.height = h + S * 2; const A = I.getContext("2d"); if (!A) throw new Error("Failed to get canvas context"); A.fillStyle = "#FFFFFF", A.fillRect(0, 0, I.width, I.height); const L = window.getComputedStyle(w); A.font = `${L.fontSize} ${L.fontFamily}`, A.fillStyle = C, A.textAlign = "center", A.textBaseline = "middle", A.fillText(m, I.width / 2, I.height / 2); const x = I.toDataURL("image/png"), _ = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${h}" height="${h}" viewBox="0 0 ${I.width} ${I.height}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <image width="${I.width}" height="${I.height}" xlink:href="${x}"/>
</svg>`.trim(); document.body.removeChild(b), zu(_, `${m}.svg`, "image/svg+xml")
    } catch (b) { console.error("Error generating SVG:", b), G({ type: "error", title: "Download Failed", body: "Failed to generate SVG. Please try again." }) } finally { X == null || X.classList.add("hidden") }
  }, Ku = async () => { const d = or(); if (!d) return; const { name: m, style: y, size: h, color: C, fontVariationSettings: E } = d; X == null || X.classList.remove("hidden"); try { const b = document.createElement("div"); b.style.position = "absolute", b.style.left = "-9999px", b.style.top = "0", b.style.visibility = "hidden", b.style.width = `${h}px`, b.style.height = `${h}px`, b.style.display = "flex", b.style.alignItems = "center", b.style.justifyContent = "center", b.style.backgroundColor = "#FFFFFF"; const w = document.createElement("span"); w.textContent = m, w.className = `material-symbols-${y.toLowerCase()}`, w.style.fontVariationSettings = E, w.style.fontSize = `${h}px`, w.style.color = C, w.style.lineHeight = "1", w.style.fontFamily = `'Material Symbols ${y}'`, b.appendChild(w), document.body.appendChild(b), await document.fonts.ready, await new Promise(L => setTimeout(L, 200)); const S = Math.max(h * .1, 4), I = document.createElement("canvas"); I.width = h + S * 2, I.height = h + S * 2; const A = I.getContext("2d", { willReadFrequently: !1 }); if (A) { A.fillStyle = "#FFFFFF", A.fillRect(0, 0, I.width, I.height); const L = window.getComputedStyle(w), x = L.fontFamily, _ = L.fontSize; A.font = `${_} ${x}`, A.fillStyle = C, A.textAlign = "center", A.textBaseline = "middle", A.fillText(m, I.width / 2, I.height / 2), Wu(I, `${m}.png`) } document.body.removeChild(b) } catch (b) { console.error("Error generating PNG:", b), G({ type: "error", title: "Download Failed", body: "Failed to generate PNG. Please try again." }) } finally { X == null || X.classList.add("hidden") } }, wl = async (d, m) => { if (d) try { await navigator.clipboard.writeText(d), G({ type: "success", title: "Copied to Clipboard", body: `${m} code has been copied.` }) } catch (y) { console.error("Failed to copy text: ", y), G({ type: "error", title: "Copy Failed", body: "Could not copy code to clipboard." }) } }, Xu = async () => { var m, y, h, C; if (!n) return; const d = g("#details-upscale-btn"); Re(d, !0), X == null || X.classList.remove("hidden"); try { const E = [{ text: "Create a high-resolution version of this image. Generate it at maximum resolution (at least 2048x2048 pixels or larger, preferably 4096x4096), with extremely sharp details, enhanced clarity, perfect edge definition, no blur or artifacts. Maintain all colors, composition, and visual elements exactly as shown but at significantly higher resolution and quality." }]; E.push({ inlineData: { data: n.data, mimeType: n.mimeType } }); const w = (C = (h = (y = (m = (await Xe.models.generateContent({ model: "gemini-2.5-flash-image", contents: { parts: E }, config: { responseModalities: [St.IMAGE], temperature: .1, topP: .95, topK: 40 } })).candidates) == null ? void 0 : m[0]) == null ? void 0 : y.content) == null ? void 0 : h.parts) == null ? void 0 : C[0]; if (w && w.inlineData) { const { data: S, mimeType: I } = w.inlineData; n.data = S, n.mimeType = I; const A = i.find(L => L.id === n.id); A && (A.data = S, A.mimeType = I), xn(), G({ type: "success", title: "Upscaled!", body: "Image has been upscaled to 4K resolution." }) } else throw new Error("No image data in response") } catch (E) { console.error("Upscale failed:", E), G({ type: "error", title: "Upscale Failed", body: "Failed to upscale image." }) } finally { Re(d, !1), X == null || X.classList.add("hidden") } }, ir = () => { if (!(!t || !ts || !Di)) try { const d = JSON.parse(du), m = qn && qn.value ? qn.value : t.name.replace(/_/g, " "); d.subject = m, Di.checked ? (typeof d.negative_prompt == "string" && (d.negative_prompt = d.negative_prompt.replace(", ground/drop shadows", "")), d.lighting && (d.lighting.shadows = "soft ground shadow beneath the object")) : (typeof d.negative_prompt == "string" && !d.negative_prompt.includes("ground/drop shadows") && (d.negative_prompt += ", ground/drop shadows"), d.lighting && (d.lighting.shadows = "internal occlusion only, no ground shadow")), ts.value = JSON.stringify(d, null, 2) } catch (d) { console.error("Failed to update icon studio 3D prompt", d), ts.value = `A high-quality, professional 3D icon of a ${t.name.replace(/_/g, " ")}.` } }, Zu = d => { t = d, io("#icon-grid .icon-item").forEach(m => { m.classList.toggle("selected", m.dataset.iconName === d.name) }), vt == null || vt.classList.remove("hidden"), window.innerWidth <= 768 ? uf() : vt == null || vt.classList.add("is-open"), Hr && (Hr.textContent = d.name.replace(/_/g, " ")), Br && (Br.textContent = d.name), Yt && (Yt.textContent = d.name), qn && (qn.value = d.name.replace(/_/g, " ")), ir(), fs.disabled = !1, ps.disabled = !1, ms.disabled = !1, Qt(Yn), di(), Wa(), za() }, Il = async () => { var d, m, y, h; if (t) { Re(Ai, !0), Ao == null || Ao.classList.remove("hidden"), xi == null || xi.classList.add("hidden"), Js == null || Js.classList.add("hidden"), xo == null || xo.classList.add("hidden"), X == null || X.classList.remove("hidden"); try { const C = ts.value, E = [{ text: C }], b = await Promise.all(W.filter(I => I).map(async I => ({ inlineData: { data: await Dt(I.file), mimeType: I.file.type } }))); E.push(...b); const S = (h = (y = (m = (d = (await Xe.models.generateContent({ model: "gemini-2.5-flash-image", contents: { parts: E }, config: { responseModalities: [St.IMAGE] } })).candidates) == null ? void 0 : d[0]) == null ? void 0 : m.content) == null ? void 0 : y.parts) == null ? void 0 : h[0]; if (S && S.inlineData) { const { data: I, mimeType: A } = S.inlineData, L = `data:${A};base64,${I}`; xi.src = L, xi.classList.remove("hidden"), Jr.href = L, Jr.classList.remove("hidden"), ns.classList.remove("hidden"), uu.classList.remove("hidden"), o = { data: I, prompt: C } } else throw new Error("No image data returned.") } catch (C) { console.error("3D conversion failed", C), xo == null || xo.classList.remove("hidden") } finally { Re(Ai, !1), Ao == null || Ao.classList.add("hidden"), X == null || X.classList.add("hidden") } } }, Qu = d => {
    if (!(!d || !Ot)) {
      if (nl && (nl.textContent = d.name), qa) { qa.innerHTML = ""; let m; d.type.startsWith("image/") ? (m = document.createElement("img"), m.src = d.dataUrl, m.alt = d.name) : d.type.startsWith("video/") && (m = document.createElement("video"), m.src = d.dataUrl, m.controls = !0, m.autoplay = !0, m.loop = !0), m && qa.appendChild(m) } if (ol) {
        const m = new Date(d.timestamp).toLocaleString(); ol.innerHTML = `
            <dt>Name</dt><dd>${d.name}</dd>
            <dt>Type</dt><dd>${d.type}</dd>
            <dt>Added</dt><dd>${m}</dd>
        `} d.styleConstraints ? (ti == null || ti.classList.remove("hidden"), ni == null || ni.classList.add("hidden"), il && (il.textContent = d.styleConstraints)) : (ti == null || ti.classList.add("hidden"), ni == null || ni.classList.remove("hidden")), Va && (Va.href = d.dataUrl, Va.download = d.name), Ot == null || Ot.classList.remove("hidden")
    }
  }, ju = d => { if (d.length) { for (const m of Array.from(d)) { const y = new FileReader; y.onload = h => { var b; const C = (b = h.target) == null ? void 0 : b.result, E = { id: `local_${Date.now()}_${Math.random()}`, name: m.name, type: m.type, dataUrl: C, timestamp: Date.now() }; Rt = Pt([E, ...Rt]), sr() }, y.readAsDataURL(m) } G({ type: "success", title: "Upload Complete", body: `${d.length} file(s) added.` }) } }, ef = () => { Un && Un.disconnect(); const d = { root: us, rootMargin: "0px", threshold: .5 }, m = h => { h.forEach(C => { const E = C.target; if (C.isIntersecting) { const b = E.play(); b !== void 0 && b.catch(w => { console.log("Autoplay prevented for video:", E.src, w) }) } else E.pause() }) }; Un = new IntersectionObserver(m, d); const y = ln == null ? void 0 : ln.querySelectorAll("video"); y == null || y.forEach(h => { Un.observe(h), Lo(h) }) }, sr = () => {
    if (!ln) { console.warn("[Home] exploreFeed element not found"); return } const d = Rt.length > 0; if (console.log(`[Home] renderExploreFeed: hasContent=${d}, exploreMedia.length=${Rt.length}`), us == null || us.classList.toggle("has-content", d), !d) {
      console.log("[Home] No content, showing empty state"), ln.innerHTML = `
            <div class="explore-feed-empty">
                <span class="material-symbols-outlined">add_photo_alternate</span>
                <p>Your library is empty</p>
                <span>Upload images and videos to get started.</span>
            </div>
        `; return
    } console.log(`[Home] Rendering ${Rt.length} items`); const m = [...Rt].sort((y, h) => { const C = I => I.includes("/veo3/") ? 1 : I.includes("/veo2/") ? 2 : I.includes("/image/") ? 3 : 4, E = C(y.dataUrl), b = C(h.dataUrl); if (E !== b) return E - b; const w = y.type.startsWith("video/"), S = h.type.startsWith("video/"); return w && !S ? -1 : !w && S ? 1 : 0 }); ln.innerHTML = "", m.forEach(y => {
      const h = document.createElement("div"); h.className = "feed-card", h.dataset.id = y.id, h.setAttribute("tabindex", "0"), h.setAttribute("aria-label", `View details for ${y.name}`); let C = "veo2"; y.dataUrl.includes("/veo3/") ? C = "veo3" : y.dataUrl.includes("/image/") ? C = "image" : y.dataUrl.includes("/veo2/") && (C = "veo2"); let E = ""; y.type.startsWith("image/") ? E = `<img src="${y.dataUrl}" class="feed-card-media" data-folder="${C}" alt="${y.name}" loading="lazy">` : y.type.startsWith("video/") && (E = `<video src="${y.dataUrl}" class="feed-card-media" data-folder="${C}" autoplay muted loop playsinline></video>`), h.innerHTML = `
            ${E}
            <div class="feed-card-info">
                <div class="feed-card-text-content">
                    <span class="feed-card-title">${y.name}</span>
                </div>
            </div>
        `, ln.appendChild(h); const b = h.querySelector("video"); b && Lo(b)
    }), ef()
  }, ar = (d, m, y) => { if (!d || !d.type.startsWith("image/")) return; const h = parseInt(m.dataset.index), C = m.querySelector(".style-image-preview"), E = m.querySelector(".drop-zone-prompt"), b = m.querySelector(".remove-style-image-btn"), w = new FileReader; w.onload = S => { var A; const I = (A = S.target) == null ? void 0 : A.result; y[h] = { file: d, dataUrl: I }, C.src = I, C.classList.remove("hidden"), E == null || E.classList.add("hidden"), b.classList.remove("hidden") }, w.readAsDataURL(d) }, rr = (d, m, y) => { const h = g(d), C = g(m); if (!h || !C) return; h.querySelectorAll(".image-drop-zone").forEach((b, w) => { const S = b.querySelector(".remove-style-image-btn"), I = () => { var L; const A = (L = C.files) == null ? void 0 : L[0]; A && ar(A, b, y), C.value = "" }; b.addEventListener("click", () => { y[w] || (C.addEventListener("change", I, { once: !0 }), C.click()) }), b.addEventListener("dragover", A => { A.preventDefault(), b.classList.add("dragover") }), b.addEventListener("dragleave", A => { A.preventDefault(), b.classList.remove("dragleave") }), b.addEventListener("drop", A => { var x; A.preventDefault(), b.classList.remove("dragover"); const L = (x = A.dataTransfer) == null ? void 0 : x.files[0]; ar(L, b, y) }), S.addEventListener("click", A => { A.stopPropagation(), y[w] = null; const L = b.querySelector(".style-image-preview"), x = b.querySelector(".drop-zone-prompt"); L.src = "", L.classList.add("hidden"), x == null || x.classList.remove("hidden"), S.classList.add("hidden") }) }) }, tf = () => { const d = g("#motion-reference-image-container"), m = g("#motion-reference-image-input"); if (!d || !m) return; d.querySelectorAll(".image-drop-zone").forEach(h => { const C = parseInt(h.dataset.index), E = h.querySelector(".remove-style-image-btn"), b = S => { if (!S || !S.type.startsWith("image/")) return; const I = new FileReader; I.onload = A => { var _; const L = (_ = A.target) == null ? void 0 : _.result, x = { file: S, dataUrl: L }; C === 0 ? K = x : j = x, cn(h, L) }, I.readAsDataURL(S) }, w = () => { var I; const S = (I = m.files) == null ? void 0 : I[0]; S && b(S), m.value = "" }; h.addEventListener("click", () => { (C === 0 ? K : j) || (m.addEventListener("change", w, { once: !0 }), m.click()) }), h.addEventListener("dragover", S => { S.preventDefault(), h.classList.add("dragover") }), h.addEventListener("dragleave", S => { S.preventDefault(), h.classList.remove("dragleave") }), h.addEventListener("drop", S => { var A; S.preventDefault(), h.classList.remove("dragover"); const I = (A = S.dataTransfer) == null ? void 0 : A.files[0]; b(I) }), E.addEventListener("click", S => { S.stopPropagation(), C === 0 ? K = null : j = null, Ka(h) }) }) }, nf = () => { const d = g("#motion-reference-image-container-image"), m = g("#motion-reference-image-input-image"); if (!d || !m) return; d.querySelectorAll(".image-drop-zone").forEach(h => { const C = parseInt(h.dataset.index), E = h.querySelector(".remove-style-image-btn"), b = S => { if (!S || !S.type.startsWith("image/")) return; const I = new FileReader; I.onload = A => { var _; const L = (_ = A.target) == null ? void 0 : _.result, x = { file: S, dataUrl: L }; C === 0 ? ue = x : Fe = x, cn(h, L) }, I.readAsDataURL(S) }, w = () => { var I; const S = (I = m.files) == null ? void 0 : I[0]; S && b(S), m.value = "" }; h.addEventListener("click", () => { (C === 0 ? ue : Fe) || (m.addEventListener("change", w, { once: !0 }), m.click()) }), h.addEventListener("dragover", S => { S.preventDefault(), h.classList.add("dragover") }), h.addEventListener("dragleave", S => { S.preventDefault(), h.classList.remove("dragleave") }), h.addEventListener("drop", S => { var A; S.preventDefault(), h.classList.remove("dragover"); const I = (A = S.dataTransfer) == null ? void 0 : A.files[0]; b(I) }), E.addEventListener("click", S => { S.stopPropagation(), C === 0 ? ue = null : Fe = null, Ka(h) }) }) }, of = () => { const d = g("#p2d-motion-reference-image-container"), m = g("#p2d-motion-reference-image-input"); if (!d || !m) return; d.querySelectorAll(".image-drop-zone").forEach(h => { const C = parseInt(h.dataset.index), E = h.querySelector(".remove-style-image-btn"), b = S => { if (!S || !S.type.startsWith("image/")) return; const I = new FileReader; I.onload = A => { var _; const L = (_ = A.target) == null ? void 0 : _.result, x = { file: S, dataUrl: L }; C === 0 ? le = x : de = x, cn(h, L) }, I.readAsDataURL(S) }, w = () => { var I; const S = (I = m.files) == null ? void 0 : I[0]; S && b(S), m.value = "" }; h.addEventListener("click", () => { (C === 0 ? le : de) || (m.addEventListener("change", w, { once: !0 }), m.click()) }), h.addEventListener("dragover", S => { S.preventDefault(), h.classList.add("dragover") }), h.addEventListener("dragleave", S => { S.preventDefault(), h.classList.remove("dragover") }), h.addEventListener("drop", S => { var A; S.preventDefault(), h.classList.remove("dragover"); const I = (A = S.dataTransfer) == null ? void 0 : A.files[0]; b(I) }), E.addEventListener("click", S => { S.stopPropagation(), C === 0 ? le = null : de = null, Ka(h) }) }) }, Sl = (d, m) => {
    const y = `image-studio-zone-${d}`, h = `
      <div class="control-card">
        <div class="prompt-card-header">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <h3>Reference Image ${d + 1}</h3>
            <button class="remove-reference-zone-btn icon-button" data-index="${d}" ${d === 0 ? 'style="visibility: hidden;"' : ""}>
              <span class="material-symbols-outlined">delete</span>
            </button>
          </div>
        </div>
        <div class="image-studio-drop-zone" data-index="${d}" id="${y}">
          <div class="drop-zone-content">
            <div class="drop-zone-prompt-large">
              <span class="material-symbols-outlined">add_photo_alternate</span>
              <p>Drop or click</p>
            </div>
            <img class="drop-zone-preview hidden" alt="Reference image ${d + 1}">
            <button class="remove-style-image-btn hidden" aria-label="Remove image ${d + 1}">
              <span class="material-symbols-outlined">close</span>
            </button>
          </div>
          <div class="drop-zone-overlay">
            <button class="generate-text-btn">
              <span class="material-symbols-outlined">text_fields</span>
              <span class="overlay-text-label">Generate with Text</span>
            </button>
            <div class="overlay-divider"></div>
            <button class="attach-image-btn">
              <span class="material-symbols-outlined">attach_file</span>
              <span class="overlay-text-label">Attach Image</span>
            </button>
          </div>
        </div>
        <input type="file" class="image-studio-reference-input hidden" data-index="${d}" accept="image/*">
      </div>
    `, C = document.createElement("div"); C.innerHTML = h.trim(); const E = C.firstChild; return m.appendChild(E), E
  }, sf = () => { const d = g("#image-studio-reference-container"), m = g("#add-reference-image-btn"), y = g("#add-reference-image-card"); if (!d) return; d.innerHTML = "", qe.length === 0 && (qe = [null, null, null]), Sl(0, d), Ll(0), y == null || y.classList.add("hidden"), m == null || m.replaceWith(m.cloneNode(!0)); const h = g("#add-reference-image-btn"); h == null || h.addEventListener("click", () => { const C = document.querySelectorAll(".image-studio-drop-zone").length; C >= 3 || (qe.length < C + 1 && qe.push(null), Sl(C, d), Ll(C), C + 1 >= 3 && (y == null || y.classList.add("hidden")), lr()) }), lr() }, lr = () => { document.querySelectorAll(".remove-reference-zone-btn").forEach(m => { parseInt(m.getAttribute("data-index") || "0") === 0 ? m.style.visibility = "hidden" : m.style.visibility = "visible" }) }, Ll = d => { const m = document.querySelector(`.image-studio-drop-zone[data-index="${d}"]`), y = document.querySelector(`.image-studio-reference-input[data-index="${d}"]`), h = document.querySelector(`.remove-reference-zone-btn[data-index="${d}"]`); if (!m || !y) return; const C = m.querySelector(".drop-zone-content"), E = m.querySelector(".drop-zone-preview"), b = m.querySelector(".remove-style-image-btn"), w = m.querySelector(".attach-image-btn"), S = m.querySelector(".generate-text-btn"), I = L => { if (L && E && C) { E.src = L, E.classList.remove("hidden"), b == null || b.classList.remove("hidden"), C.classList.add("has-image"); const x = g("#add-reference-image-card"); document.querySelectorAll(".image-studio-drop-zone").length < 3 && qe.some(M => M !== null) && (x == null || x.classList.remove("hidden")) } else if (C && (E.src = "", E.classList.add("hidden"), b == null || b.classList.add("hidden"), C.classList.remove("has-image"), !qe.some(_ => _ !== null))) { const _ = g("#add-reference-image-card"); _ == null || _.classList.add("hidden") } }, A = L => { if (!L || !L.type.startsWith("image/")) return; const x = new FileReader; x.onload = _ => { var F; const M = (F = _.target) == null ? void 0 : F.result; qe[d] = { file: L, dataUrl: M }, I(M) }, x.readAsDataURL(L) }; y.addEventListener("change", () => { var x; const L = (x = y.files) == null ? void 0 : x[0]; L && A(L), y.value = "" }), m.addEventListener("dragover", L => { L.preventDefault() }), m.addEventListener("drop", L => { var _; L.preventDefault(); const x = (_ = L.dataTransfer) == null ? void 0 : _.files[0]; A(x) }), b && b.addEventListener("click", L => { L.stopPropagation(), qe[d] = null, I(null) }), w && w.addEventListener("click", L => { L.stopPropagation(), y.click() }), S && S.addEventListener("click", L => { var U; L.stopPropagation(); let x = d; const _ = g("#image-studio-text-input"); (U = g("#image-studio-text-modal")) == null || U.classList.remove("hidden"), _.value = "", _.focus(); const M = g("#image-studio-text-generate-btn"); M == null || M.replaceWith(M.cloneNode(!0)); const F = g("#image-studio-text-generate-btn"); F == null || F.addEventListener("click", async () => { var J, z, B, O, q, te; const Z = ((J = _ == null ? void 0 : _.value) == null ? void 0 : J.trim()) || ""; if (!Z) { G({ type: "error", title: "Input Required", body: "Please enter a prompt." }); return } try { (z = g("#image-studio-text-modal")) == null || z.classList.add("hidden"); const Y = g("#image-generation-loader-modal"); Y == null || Y.classList.remove("hidden"), console.log("[Image Studio] Generating image from text with model: gemini-2.5-flash-image"), console.log("[Image Studio] Prompt:", Z); const Q = await Xe.models.generateContent({ model: "gemini-2.5-flash-image", contents: [{ parts: [{ text: Z }] }], config: { responseModalities: [St.IMAGE] } }); console.log("[Image Studio] Full response:", Q); const H = (te = (q = (O = (B = Q.candidates) == null ? void 0 : B[0]) == null ? void 0 : O.content) == null ? void 0 : q.parts) == null ? void 0 : te[0]; if (console.log("[Image Studio] Response part:", H), H && H.inlineData) { const { data: ee, mimeType: pe } = H.inlineData, se = `data:${pe};base64,${ee}`; console.log("[Image Studio] Image data received, creating file..."); const me = await (await fetch(se)).blob(), Le = new File([me], `generated_image_${x}.png`, { type: pe }); qe[x] = { file: Le, dataUrl: se }; const ge = document.querySelector(`.image-studio-drop-zone[data-index="${x}"]`); if (console.log("[Image Studio] Drop zone:", ge), ge) { const he = ge.querySelector(".drop-zone-preview"), oe = ge.querySelector(".drop-zone-content"), De = ge.querySelector(".remove-style-image-btn"), ze = oe == null ? void 0 : oe.querySelector(".drop-zone-prompt-large"); he && oe && (he.src = se, he.classList.remove("hidden"), ze && ze.classList.add("hidden"), De && De.classList.remove("hidden"), oe.classList.add("has-image"), console.log("[Image Studio] UI updated successfully")) } G({ type: "success", title: "Generated!", body: "Image generated from text." }) } else throw console.error("[Image Studio] No image data in response:", H), new Error("No image data in response"); Y == null || Y.classList.add("hidden") } catch (Y) { console.error("[Image Studio] Text generation failed:", Y), G({ type: "error", title: "Generation Failed", body: "Could not generate image from text." }) } }) }), h && d > 0 && h.addEventListener("click", L => { var M; L.stopPropagation(), qe[d] = null; const x = (M = document.querySelector(".control-card")) == null ? void 0 : M.querySelector(`.image-studio-drop-zone[data-index="${d}"]`); if (x) { const F = x.closest(".control-card"); F == null || F.remove() } const _ = g("#add-reference-image-card"); _ == null || _.classList.remove("hidden"), lr() }) }, af = () => { sf() }, dr = g("#history-back-btn-image"), cr = g("#history-forward-btn-image"), ur = g("#details-close-btn-image"), kn = g("#result-image-image"); dr == null || dr.addEventListener("click", () => { if (Ie > 0) { Ie--; const d = _e[Ie], m = `data:${d.mimeType};base64,${d.data}`; kn && (kn.src = m, kn.classList.remove("hidden")), Qn() } }), cr == null || cr.addEventListener("click", () => { if (Ie < _e.length - 1) { Ie++; const d = _e[Ie], m = `data:${d.mimeType};base64,${d.data}`; kn && (kn.src = m, kn.classList.remove("hidden")), Qn() } }), ur == null || ur.addEventListener("click", () => { const d = g("#image-details-panel-image"); d == null || d.classList.add("hidden"), d == null || d.classList.remove("is-open") }), kn == null || kn.addEventListener("click", () => { if (V) { const d = g("#image-details-panel-image"); d == null || d.classList.remove("hidden"), d == null || d.classList.add("is-open") } }); const fr = g("#toggle-details-panel-btn-image"); fr == null || fr.addEventListener("click", () => { const d = g("#image-details-panel-image"); d != null && d.classList.contains("hidden") ? (d.classList.remove("hidden"), d.classList.add("is-open")) : (d.classList.add("hidden"), d.classList.remove("is-open")) }); const ci = g("#details-more-menu-btn-image"), Ht = g("#details-more-menu-image"); ci == null || ci.addEventListener("click", d => { d.stopPropagation(), Ht == null || Ht.classList.toggle("hidden") }), document.addEventListener("click", d => { Ht && !Ht.contains(d.target) && !(ci != null && ci.contains(d.target)) && Ht.classList.add("hidden") }); const pr = g("#details-more-upscale-image"); pr == null || pr.addEventListener("click", async () => { var m, y, h, C; if (!V) return; Ht == null || Ht.classList.add("hidden"); const d = g("#image-generation-loader-modal"); d == null || d.classList.remove("hidden"); try { const E = `data:${V.mimeType};base64,${V.data}`, w = await (await fetch(E)).blob(), S = new File([w], "image.png", { type: V.mimeType }), A = [{ inlineData: { data: await Dt(S), mimeType: V.mimeType } }, { text: "Upscale this image to 4K resolution while maintaining quality and details" }], x = (C = (h = (y = (m = (await Xe.models.generateContent({ model: "gemini-2.5-flash-image", contents: { parts: A }, config: { responseModalities: [St.IMAGE] } })).candidates) == null ? void 0 : m[0]) == null ? void 0 : y.content) == null ? void 0 : h.parts) == null ? void 0 : C[0]; if (x && x.inlineData) { const { data: _, mimeType: M } = x.inlineData, F = `data:${M};base64,${_}`; V.data = _, V.mimeType = M; const U = g("#result-image-image"); U && (U.src = F); const Z = g("#details-preview-image-image"); Z && (Z.src = F); const J = g("#details-download-btn-image"); J && (J.href = F), G({ type: "success", title: "Upscaled!", body: "Image has been upscaled to higher resolution." }) } } catch (E) { console.error("Error upscaling image:", E), G({ type: "error", title: "Upscale Failed", body: "Failed to upscale image." }) } finally { d == null || d.classList.add("hidden") } }); const mr = g("#details-more-delete-image"); mr == null || mr.addEventListener("click", () => { if (V && (Ht == null || Ht.classList.add("hidden"), confirm("Are you sure you want to delete this image?"))) { const d = _e.findIndex(y => y.id === (V == null ? void 0 : V.id)); if (d !== -1 && _e.splice(d, 1), _e.length === 0) { V = null, Ie = -1; const y = g("#result-image-image"), h = g("#result-idle-placeholder-image"); y && y.classList.add("hidden"), h && h.classList.remove("hidden") } else if (Ie >= _e.length && (Ie = _e.length - 1), V = _e[Ie] || null, V) { const y = `data:${V.mimeType};base64,${V.data}`, h = g("#result-image-image"), C = g("#details-preview-image-image"), E = g("#details-download-btn-image"); h && (h.src = y, h.classList.remove("hidden")), C && (C.src = y), E && (E.href = y) } Qn(); const m = g("#image-details-panel-image"); m == null || m.classList.add("hidden"), G({ type: "success", title: "Deleted", body: "Image removed from history." }) } }), document.addEventListener("click", d => { const y = d.target.closest("#image-details-panel-image .details-fix-section-toggle"); if (y) { const h = y.closest(".details-fix-section"); if (h) { const E = !(y.getAttribute("aria-expanded") === "true"); y.setAttribute("aria-expanded", String(E)), h.setAttribute("data-collapsed", String(!E)); const b = y.querySelector(".material-symbols-outlined"); b && (b.textContent = E ? "expand_less" : "expand_more") } } }); const Cs = g("#details-zoom-out-1-5x-btn-image"), ui = g("#details-preview-image-image"), rf = async d => { var h, C, E, b; if (!V) return; const m = Cs, y = g("#image-generation-loader-modal"); y == null || y.classList.remove("hidden"), Re(m, !0); try { const w = `data:${V.mimeType};base64,${V.data}`, I = await (await fetch(w)).blob(), A = new File([I], "image.png", { type: V.mimeType }), L = await Dt(A); let x = null, _ = null, M = null; try { const Y = await gu(w); x = Y.width, _ = Y.height, M = hu(Y.width, Y.height) } catch (Y) { console.warn("Unable to determine image dimensions for zoom-out operation:", Y) } const F = Number.isInteger(d) ? String(d) : d.toFixed(2).replace(/\.?0+$/, ""), U = Math.round((1 - 1 / d) * 100), Z = Number.isFinite(U) ? ` (approximately ${Math.max(U, 0)}% smaller)` : ""; let J = `IMPORTANT: You are editing the provided image. Produce a zoomed-out version where the main subject appears ${F}x smaller${Z} so significantly more of the surrounding background is visible. Expand the canvas view/field of view while keeping the subject perfectly centered and fully visible. Preserve the exact lighting, color palette, materials, camera angle, and rendering style from the original image.`; M && x && _ ? J += ` Maintain the exact original aspect ratio (${M}) and output resolution (${x}x${_} pixels).` : J += " Maintain the original aspect ratio and resolution.", J += " Reveal substantially more background context than the original: increase the visible environment by at least fifty percent on every side in this single result, keep the subject smaller in frame, and make the extra negative space obvious. Fill any newly revealed area with background elements that match the existing environment. Do not add new unrelated objects, text, borders, or black bars. Do not crop the subject or change its design. Ensure the result looks like the same scene viewed from farther away."; const B = [{ inlineData: { data: L, mimeType: V.mimeType } }, { text: J }, { text: "Avoid: keeping the original framing, keeping the subject the same size, zooming in, requiring multiple iterations, partial zoom-outs, cropping, square proportions, warped geometry, empty borders, letterboxing, new objects, text overlays, or lighting/style changes." }], O = { responseModalities: [St.IMAGE], temperature: .1 }; M && (O.aspectRatio = M); const te = (b = (E = (C = (h = (await Xe.models.generateContent({ model: "gemini-2.5-flash-image", contents: { parts: B }, config: O })).candidates) == null ? void 0 : h[0]) == null ? void 0 : C.content) == null ? void 0 : E.parts) == null ? void 0 : b[0]; if (te && te.inlineData) { const { data: Y, mimeType: Q } = te.inlineData, H = `data:${Q};base64,${Y}`, ee = Date.now(), pe = { id: `img_${ee}`, data: Y, mimeType: Q, subject: V.subject, styleConstraints: V.styleConstraints, timestamp: ee, modificationType: `Zoom Out ${F}x` }; al(pe), rl(); const se = g("#result-image-image"); se && (se.src = H), ui && (ui.src = H, ui.style.transform = "scale(1)"); const me = g("#details-download-btn-image"); me && (me.href = H), Qn(), gr(), G({ type: "success", title: `Zoomed Out ${F}x!`, body: `Frame has been expanded by ${F}x.` }) } } catch (w) { console.error("Error zooming out image:", w), G({ type: "error", title: "Zoom Out Failed", body: "Failed to expand frame." }) } finally { y == null || y.classList.add("hidden"), Re(m, !1) } }; Cs == null || Cs.addEventListener("click", () => rf(2)); const Gi = g("#details-background-color-picker-image"), Oi = g("#details-object-color-picker-image"), un = g("#details-fix-btn-image"); Gi && Gi.addEventListener("input", () => { un && un.removeAttribute("disabled") }), Oi && Oi.addEventListener("input", () => { un && un.removeAttribute("disabled") }), un == null || un.addEventListener("click", async () => { var m, y, h, C; if (!V) return; const d = g("#image-generation-loader-modal"); d == null || d.classList.remove("hidden"), Re(un, !0); try { const E = (Gi == null ? void 0 : Gi.value) || "#FFFFFF", b = (Oi == null ? void 0 : Oi.value) || "#2962FF", w = `data:${V.mimeType};base64,${V.data}`, I = await (await fetch(w)).blob(), A = new File([I], "image.png", { type: V.mimeType }), x = [{ inlineData: { data: await Dt(A), mimeType: V.mimeType } }, { text: `Regenerate this image with background color ${E} and object color ${b}. Maintain the same composition and style. Keep the exact same resolution (width x height) as the original image; do not resize or change the canvas dimensions.` }], M = (C = (h = (y = (m = (await Xe.models.generateContent({ model: "gemini-2.5-flash-image", contents: { parts: x }, config: { responseModalities: [St.IMAGE], temperature: .1 } })).candidates) == null ? void 0 : m[0]) == null ? void 0 : y.content) == null ? void 0 : h.parts) == null ? void 0 : C[0]; if (M && M.inlineData) { const { data: F, mimeType: U } = M.inlineData, Z = `data:${U};base64,${F}`, J = Date.now(), z = { id: `img_${J}`, data: F, mimeType: U, subject: V.subject, styleConstraints: V.styleConstraints, timestamp: J, modificationType: "Modified" }; al(z), rl(), Qn(); const B = g("#result-image-image"); B && (B.src = Z), ui && (ui.src = Z, ui.style.transform = "scale(1)"); const O = g("#details-download-btn-image"); O && (O.href = Z), gr(), un.setAttribute("disabled", ""), G({ type: "success", title: "Regenerated!", body: "Image has been regenerated with new colors." }) } } catch (E) { console.error("Error regenerating image:", E), G({ type: "error", title: "Regeneration Failed", body: "Failed to regenerate image." }) } finally { d == null || d.classList.add("hidden"), Re(un, !1) } }); const gr = () => { const d = g("#image-details-history-list"); if (!d || !V) return; d.innerHTML = ""; let m = []; V.rightPanelHistory ? m = V.rightPanelHistory : (m = [{ ...V, modificationType: "Original" }], V.rightPanelHistory = m); const y = V.data, h = b => { const w = m[b]; if (!w) return; const S = `data:${w.mimeType};base64,${w.data}`, I = g("#result-image-image"); I && (I.src = S, I.classList.remove("hidden")); const A = g("#details-preview-image-image"); A && (A.src = S, A.style.transform = "scale(1)"); const L = g("#details-download-btn-image"); L && (L.href = S), V.data = w.data, V.mimeType = w.mimeType, V.timestamp = w.timestamp, V.modificationType = w.modificationType, V.rightPanelHistory = m, Ie !== -1 && _e[Ie] && (_e[Ie] = V), Array.from(d.children).forEach((_, M) => { _.style.border = M === b ? "2px solid var(--accent-color)" : "2px solid transparent" }) }; m.forEach((b, w) => { const S = document.createElement("div"); S.style.cssText = "position: relative; aspect-ratio: 1; border-radius: var(--border-radius-md); overflow: hidden; cursor: pointer; border: 2px solid transparent; background: var(--surface-color);", S.dataset.index = String(w); const I = document.createElement("div"); if (I.style.cssText = "width: 100%; height: 100%; position: relative; display: flex; align-items: center; justify-content: center;", b.data && b.mimeType) { const x = `data:${b.mimeType};base64,${b.data}`, _ = document.createElement("img"); _.src = x, _.style.cssText = "width: 100%; height: 100%; object-fit: contain; pointer-events: none;", I.appendChild(_) } const A = document.createElement("div"), L = b.modificationType || "Original"; A.textContent = L, A.style.cssText = "position: absolute; left: 4px; bottom: 4px; padding: 2px 6px; border-radius: 999px; background: rgba(15,23,42,0.75); color: #FFFFFF; font-size: 10px; font-weight: 600; letter-spacing: 0.02em; text-transform: uppercase; pointer-events: none;", S.appendChild(I), S.appendChild(A), S.addEventListener("click", () => { h(w) }), d.appendChild(S) }); const C = m.findIndex(b => b.data === y), E = C !== -1 ? C : m.length - 1; E >= 0 && h(E) }, hr = (Zl = g("#image-details-panel-image")) == null ? void 0 : Zl.querySelectorAll(".tab-item"); hr == null || hr.forEach(d => { d.addEventListener("click", () => { d.getAttribute("data-tab") === "history" && setTimeout(() => { gr() }, 50) }) }), bu(), Vr.forEach(d => { d.addEventListener("click", ll) }); const _l = document.querySelectorAll(".bottom-nav-item"); _l.forEach(d => { d.addEventListener("click", ll) }), (() => { _l.forEach(d => { const m = d.dataset.page; d.classList.toggle("active", m === re) }) })(), (Ql = g("#banner-toast-close-btn")) == null || Ql.addEventListener("click", () => { var d; (d = g("#banner-toast")) == null || d.classList.add("hidden"), Li && clearTimeout(Li) }), io('input[name="icon-family"], #fill-toggle, #weight-slider, #optical-size-slider').forEach(d => { d.addEventListener("input", () => { Wa(), di() }) }), (jl = g("#weight-slider")) == null || jl.addEventListener("input", dl), (ed = g("#optical-size-slider")) == null || ed.addEventListener("input", Ja), (td = g("#optical-size-slider")) == null || td.addEventListener("change", Ja), Ja(), (nd = g("#export-size-input")) == null || nd.addEventListener("input", () => { za(), di() }), Yn == null || Yn.addEventListener("input", () => { za(), di() }), Ia == null || Ia.addEventListener("click", Cu); const lf = () => { if (!Yt || !Yo || !Ko) { G({ type: "error", title: "Error", body: "Please select an icon and animation first." }); return } const d = Yt.textContent || "icon", m = Yo.value, y = Hs[m]; if (!y) { G({ type: "error", title: "Error", body: "Invalid animation selected." }); return } const h = Ko.value === "infinite" ? -1 : 1, C = parseFloat(y.duration), E = 60, b = Math.ceil(C * E), w = h === -1 ? b : b * h, S = g("#color-picker"), I = (S == null ? void 0 : S.value) || "#0F172A", L = (B => { const O = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(B); return O ? { r: parseInt(O[1], 16) / 255, g: parseInt(O[2], 16) / 255, b: parseInt(O[3], 16) / 255 } : { r: .06, g: .09, b: .16 } })(I), x = g("#export-size-input"), _ = parseInt((x == null ? void 0 : x.value) || "48", 10), M = { v: "5.7.4", fr: E, ip: 0, op: w, w: _, h: _, nm: `${d}_${m}`, ddd: 0, assets: [], layers: [{ ddd: 0, ind: 1, ty: 4, nm: d, sr: 1, ks: { o: { a: 0, k: 100 }, r: { a: 0, k: 0 }, p: { a: 0, k: [_ / 2, _ / 2, 0] }, a: { a: 0, k: [0, 0, 0] }, s: { a: 0, k: [100, 100, 100] } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 0, k: [_ * .8, _ * .8] }, p: { a: 0, k: [0, 0] }, nm: "Icon Shape", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "fl", c: { a: 0, k: [L.r, L.g, L.b, 1] }, o: { a: 0, k: 100 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }], nm: "Icon Group", np: 2, cix: 2, bm: 0 }], ip: 0, op: w, st: 0, bm: 0 }] }, F = M.layers[0]; if (m === "fade-in") F.ks.o = { a: 1, k: [{ i: { x: [.833], y: [.833] }, o: { x: [.167], y: [.167] }, t: 0, s: [0] }, { t: b, s: [100] }] }; else if (m === "fade-out") F.ks.o = { a: 1, k: [{ i: { x: [.833], y: [.833] }, o: { x: [.167], y: [.167] }, t: 0, s: [100] }, { t: b, s: [0] }] }; else if (m === "bounce") F.ks.p = { a: 1, k: [{ i: { x: .833, y: .833 }, o: { x: .167, y: .167 }, t: 0, s: [_ / 2, _ / 2, 0] }, { i: { x: .833, y: .833 }, o: { x: .167, y: .167 }, t: b * .4, s: [_ / 2, _ / 2 - 30, 0] }, { i: { x: .833, y: .833 }, o: { x: .167, y: .167 }, t: b * .6, s: [_ / 2, _ / 2 - 15, 0] }, { i: { x: .833, y: .833 }, o: { x: .167, y: .167 }, t: b, s: [_ / 2, _ / 2, 0] }] }; else if (m === "scale") F.ks.s = { a: 1, k: [{ i: { x: [.833], y: [.833] }, o: { x: [.167], y: [.167] }, t: 0, s: [100, 100, 100] }, { i: { x: [.833], y: [.833] }, o: { x: [.167], y: [.167] }, t: b * .5, s: [120, 120, 100] }, { i: { x: [.833], y: [.833] }, o: { x: [.167], y: [.167] }, t: b, s: [100, 100, 100] }] }; else if (m === "rotate") F.ks.r = { a: 1, k: [{ i: { x: [.833], y: [.833] }, o: { x: [.167], y: [.167] }, t: 0, s: [0] }, { i: { x: [.833], y: [.833] }, o: { x: [.167], y: [.167] }, t: b, s: [360] }] }; else if (m === "shake") { const B = [{ t: 0, s: [0] }, { t: b * .1, s: [-1] }, { t: b * .2, s: [-3] }, { t: b * .3, s: [3] }, { t: b * .4, s: [1] }, { t: b * .5, s: [-1] }, { t: b * .6, s: [-3] }, { t: b * .7, s: [3] }, { t: b * .8, s: [-1] }, { t: b * .9, s: [1] }, { t: b, s: [0] }]; F.ks.r = { a: 1, k: B.map((O, q) => ({ i: { x: [.833], y: [.833] }, o: { x: [.167], y: [.167] }, t: O.t, s: [O.s] })) } } else if (m === "pulse") F.ks.s = { a: 1, k: [{ i: { x: [.833], y: [.833] }, o: { x: [.167], y: [.167] }, t: 0, s: [100, 100, 100] }, { i: { x: [.833], y: [.833] }, o: { x: [.167], y: [.167] }, t: b * .5, s: [110, 110, 100] }, { i: { x: [.833], y: [.833] }, o: { x: [.167], y: [.167] }, t: b, s: [100, 100, 100] }] }; else if (m === "breathe") { const B = [{ t: 0, s: [90, 90, 100] }, { t: b * .25, s: [100, 100, 100] }, { t: b * .5, s: [90, 90, 100] }, { t: b * .75, s: [100, 100, 100] }, { t: b, s: [90, 90, 100] }]; F.ks.s = { a: 1, k: B.map(O => ({ i: { x: [.833], y: [.833] }, o: { x: [.167], y: [.167] }, t: O.t, s: O.s })) } } if (h === -1) { const B = F.ks; Object.keys(B).forEach(O => { B[O].a === 1 && B[O].k }) } const U = JSON.stringify(M, null, 2), Z = new Blob([U], { type: "application/json" }), J = URL.createObjectURL(Z), z = document.createElement("a"); z.href = J, z.download = `${d}_${m}.json`, document.body.appendChild(z), z.click(), document.body.removeChild(z), URL.revokeObjectURL(J), G({ type: "success", title: "Downloaded", body: "Lottie JSON file downloaded successfully." }) }; La == null || La.addEventListener("click", lf); const ws = g("#convert-to-mp4-btn"), df = async () => { if (!Yt || !Yo || !Ko) { G({ type: "error", title: "Error", body: "Please select an icon and animation first." }); return } const d = Yt.textContent || "icon", m = Yo.value, y = Hs[m]; if (!y) { G({ type: "error", title: "Error", body: "Invalid animation selected." }); return } qi(X), _t && (_t.textContent = "Generating MP4..."), X == null || X.classList.remove("hidden"); const h = ws; h && (h.classList.add("loading"), h.disabled = !0); try { const C = g("#export-size-input"), E = parseInt((C == null ? void 0 : C.value) || "48", 10), b = Ko.value === "infinite" ? -1 : 1, w = parseFloat(y.duration), S = 30, I = Math.ceil(w * S), A = b === -1 ? I * 3 : I * b, L = document.createElement("canvas"); L.width = E, L.height = E; const x = L.getContext("2d"); if (!x) throw new Error("Failed to get canvas context"); const _ = g("#color-picker"), M = (_ == null ? void 0 : _.value) || "#0F172A"; let F = d; t && t.name && (F = t.name); const U = [], Z = E / 2, J = E / 2; for (let H = 0; H < A; H++) { const ee = b === -1 ? H % I / I : H / (A - 1); x.clearRect(0, 0, E, E), x.fillStyle = "#FFFFFF", x.fillRect(0, 0, E, E); let pe = 1, se = 1, me = 0, Le = 0, ge = 0; m === "fade-in" ? pe = ee : m === "fade-out" ? pe = 1 - ee : m === "bounce" ? ee < .4 ? Le = -30 * (ee / .4) : ee < .6 ? Le = -30 + 15 * ((ee - .4) / .2) : Le = -15 * ((1 - ee) / .4) : m === "scale" ? se = ee < .5 ? 1 + .2 * (ee / .5) : 1.2 - .2 * ((ee - .5) / .5) : m === "rotate" ? me = ee * 360 : m === "shake" ? me = Math.sin(ee * Math.PI * 10) * 3 : m === "pulse" ? se = ee < .5 ? 1 + .1 * (ee / .5) : 1.1 - .1 * ((ee - .5) / .5) : m === "breathe" && (se = .9 + .1 * Math.sin(ee * Math.PI * 2)), x.save(), x.globalAlpha = pe, x.translate(Z + ge, J + Le), x.rotate(me * Math.PI / 180), x.scale(se, se), x.translate(-Z, -J), x.fillStyle = M, x.font = `${E * .8}px 'Material Symbols Outlined'`, x.textAlign = "center", x.textBaseline = "middle", x.fillText(F, Z, J), x.restore(); const he = L.toDataURL("image/png"); U.push(he) } const z = await vs(); if (!z) throw new Error("Failed to load FFmpeg"); for (let H = 0; H < U.length; H++) { const pe = U[H].split(",")[1], se = Uint8Array.from(atob(pe), me => me.charCodeAt(0)); await z.writeFile(`frame_${String(H).padStart(6, "0")}.png`, se) } _t && (_t.textContent = "Encoding MP4..."), await z.exec(["-framerate", String(S), "-i", "frame_%06d.png", "-c:v", "libx264", "-pix_fmt", "yuv420p", "-crf", "23", "-preset", "medium", "-y", "output.mp4"]); const B = await z.readFile("output.mp4"); let O; if (B instanceof Uint8Array) O = B; else if (typeof B == "string") O = new Uint8Array(atob(B).split("").map(H => H.charCodeAt(0))); else { const H = B.buffer || B; O = H instanceof ArrayBuffer ? new Uint8Array(H) : new Uint8Array(H) } const q = O.buffer.slice(O.byteOffset, O.byteOffset + O.byteLength), te = new Blob([q], { type: "video/mp4" }), Y = URL.createObjectURL(te), Q = document.createElement("a"); Q.href = Y, Q.download = `${d}_${m}.mp4`, document.body.appendChild(Q), Q.click(), document.body.removeChild(Q), URL.revokeObjectURL(Y); for (let H = 0; H < U.length; H++)try { await z.deleteFile(`frame_${String(H).padStart(6, "0")}.png`) } catch { } try { await z.deleteFile("output.mp4") } catch { } X && (_n(X), X.classList.add("hidden")), G({ type: "success", title: "Downloaded", body: "MP4 file downloaded successfully." }) } catch (C) { console.error("MP4 conversion failed:", C), X && X.classList.add("hidden"), G({ type: "error", title: "Error", body: "Failed to convert to MP4. Please try again." }) } finally { h && (h.classList.remove("loading"), h.disabled = !1) } }; ws == null || ws.addEventListener("click", df), so == null || so.addEventListener("input", () => { bs = 0, nr(so.value, 0) }); const xt = g("#studio-selector"), Ze = g("#custom-studio-selector"), Eo = Ze == null ? void 0 : Ze.querySelector(".custom-dropdown-trigger"), Rn = Ze == null ? void 0 : Ze.querySelector(".custom-dropdown-menu"), fi = Ze == null ? void 0 : Ze.querySelector(".custom-dropdown-value"), bo = Ze == null ? void 0 : Ze.querySelectorAll(".custom-dropdown-option"), pi = g(".generate-box"); if (fi && xt) { const d = xt.options[xt.selectedIndex]; fi.textContent = d.textContent || "3D" } Eo == null || Eo.addEventListener("click", d => { d.stopPropagation(); const m = Eo.getAttribute("aria-expanded") === "true"; Eo.setAttribute("aria-expanded", String(!m)), Rn == null || Rn.classList.toggle("hidden", m), Ze == null || Ze.setAttribute("aria-expanded", String(!m)) }), bo == null || bo.forEach(d => { d.addEventListener("click", m => { var C; m.stopPropagation(); const y = d.getAttribute("data-value"), h = ((C = d.querySelector(".custom-dropdown-option-text")) == null ? void 0 : C.textContent) || ""; xt && y && (xt.value = y, xt.dispatchEvent(new Event("change", { bubbles: !0 }))), fi && (fi.textContent = h), bo.forEach(E => { const w = E.getAttribute("data-value") === y; E.setAttribute("aria-selected", String(w)); const S = E.querySelector(".custom-dropdown-check"); S && S.classList.toggle("hidden", !w) }), Eo.setAttribute("aria-expanded", "false"), Rn == null || Rn.classList.add("hidden"), Ze == null || Ze.setAttribute("aria-expanded", "false"), pi && pi.classList.add("has-studio-selected") }) }), document.addEventListener("click", d => { Ze && !Ze.contains(d.target) && (Eo.setAttribute("aria-expanded", "false"), Rn == null || Rn.classList.add("hidden"), Ze == null || Ze.setAttribute("aria-expanded", "false")) }), xt == null || xt.addEventListener("change", () => { const d = xt.value; console.log("[Home] Studio selected:", d); const m = xt.options[xt.selectedIndex]; fi && m && (fi.textContent = m.textContent || "3D"), bo == null || bo.forEach(y => { const C = y.getAttribute("data-value") === d; y.setAttribute("aria-selected", String(C)); const E = y.querySelector(".custom-dropdown-check"); E && E.classList.toggle("hidden", !C) }), pi && pi.classList.add("has-studio-selected") }), xt && pi && xt.value && pi.classList.add("has-studio-selected"), Ai == null || Ai.addEventListener("click", Il), ns == null || ns.addEventListener("click", () => { o && Il() }); const Bt = g("#filters-panel-backdrop"), Jt = g("#settings-panel-backdrop"), cf = () => { Mt == null || Mt.classList.add("is-open"), Bt == null || Bt.classList.add("active"), document.body.classList.add("no-scroll") }, yr = () => { Mt == null || Mt.classList.remove("is-open"), Bt == null || Bt.classList.remove("active"), document.body.classList.remove("no-scroll"), ko == null || ko.classList.add("filters-collapsed") }, uf = () => { vt == null || vt.classList.add("is-open"), Jt == null || Jt.classList.add("active"), document.body.classList.add("no-scroll") }, Al = () => { vt == null || vt.classList.remove("is-open"), Jt == null || Jt.classList.remove("active"), document.body.classList.remove("no-scroll") }; Bs == null || Bs.addEventListener("click", () => Al()), Ws == null || Ws.addEventListener("click", () => { Mt != null && Mt.classList.contains("is-open") ? yr() : cf(), ko == null || ko.classList.toggle("filters-collapsed") }), zs == null || zs.addEventListener("click", () => yr()), Bt == null || Bt.addEventListener("click", () => yr()), Jt == null || Jt.addEventListener("click", () => Al()); const xl = () => { window.innerWidth <= 768 && (Mt == null || Mt.classList.remove("is-open"), Bt == null || Bt.classList.remove("active"), vt == null || vt.classList.remove("is-open"), Jt == null || Jt.classList.remove("active")) }; xl(), window.addEventListener("resize", xl), ss == null || ss.addEventListener("click", wu), on == null || on.addEventListener("input", Vi), io('#page-id-2d input[type="radio"], #page-id-2d input[type="checkbox"], #page-id-2d input[type="range"], #page-id-2d input[type="color"]').forEach(d => { d.addEventListener("input", () => { Vi(), d.id === "p2d-weight-slider" && cl() }) }), os == null || os.addEventListener("click", Iu); const mi = () => { ys() }; ao == null || ao.addEventListener("input", mi), Mo == null || Mo.addEventListener("change", mi); const jn = g("#background-color-picker-3d"), eo = g("#object-color-picker-3d"); jn == null || jn.addEventListener("input", () => { Qt(jn), mi() }), jn == null || jn.addEventListener("change", () => { Qt(jn), mi() }), eo == null || eo.addEventListener("input", () => { Qt(eo), mi() }), eo == null || eo.addEventListener("change", () => { Qt(eo), mi() }), (() => { const d = ["ex.   ", "ex.   ", "ex.   ", "ex.   ", "ex.    ", "ex.   "], m = ["ex.    ", "ex.   ", "ex.   ", "ex.    ", "ex.   ", "ex.   "], y = ["ex.    ", "ex.   ", "ex.   ", "ex.   ", "ex.  ", "ex.   "], h = (I, A) => { const L = g(I); if (!L) return; const x = "ex. ", _ = A.map(B => B.replace(/^ex\.\s*/, "")); let M = 0, F = "", U = 0, Z = null; const J = () => { L.value !== "" || document.activeElement === L || (U < _[M].length ? (F += _[M].charAt(U), L.placeholder = x + F, U++, Z = setTimeout(J, 50)) : Z = setTimeout(z, 2e3)) }, z = () => { L.value !== "" || document.activeElement === L || (F.length > 0 ? (F = F.slice(0, -1), L.placeholder = x + F, Z = setTimeout(z, 30)) : (M = (M + 1) % _.length, U = 0, Z = setTimeout(J, 500))) }; J(), L.addEventListener("focus", () => { Z && (clearTimeout(Z), Z = null), L.value === "" && (L.placeholder = x + _[0], M = 0, F = "", U = 0) }), L.addEventListener("blur", () => { L.value === "" && (M = 0, F = "", U = 0, J()) }), L.addEventListener("input", () => { L.value !== "" && Z && (clearTimeout(Z), Z = null) }), L.addEventListener("click", () => { if (L.value === "") { let B = ""; F && F.length > 0 ? B = F : _[M] ? B = _[M] : L.placeholder && (B = L.placeholder.replace(/^ex\.\s*/, "")), B && (L.value = B, L.placeholder = "", Z && (clearTimeout(Z), Z = null), L.dispatchEvent(new Event("input", { bubbles: !0 }))) } }) }, C = I => { const A = g(I); if (!A) return; let L = null; if (I === "#prompt-input-3d" ? L = g("#convert-to-3d-btn") : I === "#p2d-image-prompt-subject-input" ? L = g("#p2d-image-generate-btn") : I === "#image-prompt-subject-input" ? L = g("#image-generate-btn") : I === "#image-prompt-subject-input-image" && (L = g("#image-generate-btn-image")), L) { const x = A.value.trim().length > 0; L.disabled = !x, x ? (L.style.opacity = "1", L.style.cursor = "pointer") : (L.style.opacity = "0.5", L.style.cursor = "not-allowed") } }, E = g("#prompt-input-3d"), b = g("#p2d-image-prompt-subject-input"), w = g("#image-prompt-subject-input"); E && (E.addEventListener("input", () => { C("#prompt-input-3d") }), C("#prompt-input-3d")), b && (b.addEventListener("input", () => { C("#p2d-image-prompt-subject-input") }), C("#p2d-image-prompt-subject-input")), w && (w.addEventListener("input", () => { C("#image-prompt-subject-input") }), C("#image-prompt-subject-input")); const S = g("#image-prompt-subject-input-image"); S && (S.addEventListener("input", () => { C("#image-prompt-subject-input-image") }), C("#image-prompt-subject-input-image")), h("#p2d-image-prompt-subject-input", d), h("#image-prompt-subject-input", m), h("#prompt-input-3d", m), h("#image-prompt-subject-input-image", y) })(), (od = g("#image-generate-btn-image")) == null || od.addEventListener("click", Ru), (id = g("#image-studio-text-modal-close-btn")) == null || id.addEventListener("click", () => { var d; (d = g("#image-studio-text-modal")) == null || d.classList.add("hidden") }), (sd = g("#image-studio-text-cancel-btn")) == null || sd.addEventListener("click", () => { var d; (d = g("#image-studio-text-modal")) == null || d.classList.add("hidden") }), Ga == null || Ga.addEventListener("click", () => Ln == null ? void 0 : Ln.classList.remove("hidden")), Oa == null || Oa.addEventListener("click", () => Ln == null ? void 0 : Ln.classList.add("hidden")), Ha == null || Ha.addEventListener("click", () => { oi == null || oi.click(), Ln == null || Ln.classList.add("hidden") }), oi == null || oi.addEventListener("change", d => { const m = d.target; m.files && ju(m.files) }), ln == null || ln.addEventListener("click", d => { const m = d.target.closest(".feed-card"); if (m && m.dataset.id) { const y = Rt.find(h => h.id === m.dataset.id); y && Qu(y) } }), $a == null || $a.addEventListener("click", () => { Ot == null || Ot.classList.add("hidden") }), Ot == null || Ot.addEventListener("click", d => { d.target === Ot && Ot.classList.add("hidden") }); const ff = async () => { try { console.log("[Home] Loading home_images.json..."); const d = await fetch("home_images.json"); if (!d.ok) throw new Error(`HTTP error! status: ${d.status}`); const m = await d.json(); console.log(`[Home] Loaded ${m.length} items from home_images.json`), Rt = Pt(m), console.log(`[Home] After reordering: ${Rt.length} items in exploreMedia`), sr(), console.log("[Home] renderExploreFeed() called") } catch (d) { console.error("[Home] Failed to load home images:", d), Rt = [], sr() } }, pf = async () => { const d = ["images/references/reference_1.png", "images/references/reference_2.png", "images/references/reference_3.png"], m = async (h, C, E, b) => { try { const S = await (await fetch(h)).blob(), I = new FileReader, A = await new Promise((_, M) => { I.onloadend = () => { typeof I.result == "string" ? _(I.result) : M(new Error("Failed to convert blob to data URL")) }, I.onerror = M, I.readAsDataURL(S) }), L = new File([S], `default_ref_${C}.png`, { type: "image/png" }); E[C] = { file: L, dataUrl: A }; const x = document.querySelector(`${b} .image-drop-zone[data-index="${C}"]`); x && cn(x, A) } catch (w) { console.error(`Failed to load default reference ${C}:`, w) } }; await Promise.all(d.map((h, C) => m(h, C, P, "#edit-reference-image-container-3d"))), await Promise.all(d.map((h, C) => m(h, C, W, "#reference-image-container-3d"))); const y = ["images/references/fill_on.png","images/references/fill_off.png","images/references/weight_light.png","images/references/weight_bold.png"]; await Promise.all(y.map((h, C) => m(h, C, R, "#p2d-edit-reference-image-container-3d"))) }, mf = async () => {
    var cd, ud, fd; const d = localStorage.getItem("theme"); Eu(d || "light"); const m = document.querySelector(".nav-item.active"); if (re = (m == null ? void 0 : m.dataset.page) || "page-usages", Ro(), await ff(), await pf(), mu(), nr("", 0), pu(), di(), dl(), cl(), Ui(), Vi(), ys(), rr("#edit-reference-image-container-3d", "#edit-reference-image-input-3d", P), rr("#reference-image-container-3d", "#reference-image-input-3d", W), rr("#p2d-edit-reference-image-container-3d", "#p2d-edit-reference-image-input-3d", R), tf(), of(), nf(), af(), $i(g("#settings-panel")), gs) { const D = document.querySelector("#settings-panel .tab-item.active"), ne = ((D == null ? void 0 : D.dataset.tab) || "details") === "details"; gs.classList.toggle("hidden", !ne) } $i(g("#image-details-panel")), $i(g("#image-details-panel-image")), $i(g("#p2d-image-details-panel")), $i(g("#p2d-svg-preview-modal")); const y = (cd = g("#p2d-image-details-panel")) == null ? void 0 : cd.querySelectorAll(".tab-item"); y == null || y.forEach(D => { D.addEventListener("click", () => { D.getAttribute("data-tab") === "history" && setTimeout(() => { At() }, 50) }) }), document.addEventListener("click", D => { const ae = D.target.closest(".details-fix-section-toggle"); if (ae) { const ce = ae.closest(".details-fix-section"); if (ce) { const Ee = !(ae.getAttribute("aria-expanded") === "true"); ae.setAttribute("aria-expanded", String(Ee)), ce.setAttribute("data-collapsed", String(!Ee)), console.log("[3D Studio] Fix section toggled:", Ee) } } }), fs == null || fs.addEventListener("click", Yu), ps == null || ps.addEventListener("click", Ku), Di == null || Di.addEventListener("change", ir), qn == null || qn.addEventListener("input", ir), ms == null || ms.addEventListener("click", () => { const D = ii == null ? void 0 : ii.querySelector(".snippet-tab-item.active"), ne = (D == null ? void 0 : D.dataset.lang) || "html", ae = (si == null ? void 0 : si.textContent) || ""; wl(ae, ne.charAt(0).toUpperCase() + ne.slice(1)) }), sl.forEach(D => { D.addEventListener("click", () => { sl.forEach(ne => ne.classList.remove("active")), D.classList.add("active"), di() }) }), Uo == null || Uo.addEventListener("click", () => { const D = c.filter(ae => !ae.modificationType || ae.modificationType === "Original"), ne = D.findIndex(ae => { var ce; return ((ce = c[f]) == null ? void 0 : ce.id) === ae.id }); ne > 0 && (f = c.findIndex(ae => ae.id === D[ne - 1].id), a = c[f], Xn(a), Xa(a), dn(), yo()) }), $o == null || $o.addEventListener("click", () => { const D = c.filter(ae => !ae.modificationType || ae.modificationType === "Original"), ne = D.findIndex(ae => { var ce; return ((ce = c[f]) == null ? void 0 : ce.id) === ae.id }); ne < D.length - 1 && (f = c.findIndex(ae => ae.id === D[ne + 1].id), a = c[f], Xn(a), Xa(a), dn(), yo()) }), pa == null || pa.addEventListener("click", () => { ve == null || ve.classList.toggle("hidden"), ve == null || ve.classList.toggle("is-open") }), fa == null || fa.addEventListener("click", () => { ve == null || ve.classList.add("hidden"), ve == null || ve.classList.remove("is-open") }), Ce == null || Ce.addEventListener("click", () => { a && (ve == null || ve.classList.remove("hidden"), ve == null || ve.classList.add("is-open")) }), qo == null || qo.addEventListener("click", () => { a && wl(a.styleConstraints, "2D Prompt") }); const h = g("#p2d-object-color-picker"), C = g("#p2d-regenerate-btn"); h && h.addEventListener("input", () => { C && (C.removeAttribute("disabled"), C.classList.remove("secondary-btn"), C.classList.add("primary-btn")) }), C == null || C.addEventListener("click", async () => {
      var ne; if (!a) { G({ type: "error", title: "No Image", body: "Please generate an image first." }); return } const D = (h == null ? void 0 : h.value) || "#000000"; try {
        const ae = JSON.parse(a.styleConstraints); ae.controls.color.primary = D, ae.output.background = "#FFFFFF"; const ce = JSON.stringify(ae, null, 2), Ge = u.find(pt => pt.modificationType === "Original"); if (!Ge) { G({ type: "error", title: "Error", body: "Original image not found." }); return } const Ee = `data:${Ge.mimeType};base64,${Ge.data}`, it = await (await fetch(Ee)).blob(), ct = new File([it], "original-icon.png", { type: Ge.mimeType }); C && (C.setAttribute("disabled", "true"), C.classList.add("loading")), we && Ue && (Ue.textContent = "Regenerating icon with new color...", we.classList.remove("hidden")); const Ne = (pt => { const vi = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(pt); return vi ? { r: parseInt(vi[1], 16), g: parseInt(vi[2], 16), b: parseInt(vi[3], 16) } : null })(D), gt = Ne ? `RGB(${Ne.r}, ${Ne.g}, ${Ne.b})` : D, bt = [{
          text: ` CRITICAL COLOR CHANGE INSTRUCTION 

Keep this icon image EXACTLY the same in:
- Shape and form (100% identical)
- Composition and layout (100% identical)
- All details and structure (100% identical)
- Resolution and canvas dimensions (100% identical - do NOT resize)

COLOR CHANGE REQUIREMENT (MANDATORY):
- Change EVERY stroke, line, outline, and path to EXACTLY ${D} (${gt})
- Use the PURE, VIBRANT color ${D} with MAXIMUM brightness and saturation
- Do NOT darken, desaturate, or reduce the color intensity
- The color must be BRIGHT, CLEAR, and VIBRANT - not dull or muted
- Replace ALL colors in the icon with ${D} at FULL intensity
- The ENTIRE icon must be 100% ${D} - no other colors allowed
- Every pixel of the icon shape must be ${D} with maximum brightness
- Background must remain pure white (#FFFFFF)

COLOR QUALITY REQUIREMENTS:
- Use the EXACT color ${D} without any darkening
- Maintain FULL saturation (100% color intensity)
- Maintain FULL brightness (no dimming or shadow effects)
- The color must appear PURE and CLEAR, not washed out or faded
- Do NOT apply any opacity, transparency, or color mixing

FORBIDDEN:
- Do NOT keep any original colors
- Do NOT use gradients or color variations
- Do NOT darken or desaturate the color
- Do NOT reduce brightness or intensity
- Do NOT use any color other than ${D} for the icon
- Do NOT modify shape, size, or structure
- Do NOT change the background color
- Do NOT apply shadows, glows, or effects that alter color brightness

The result must be: IDENTICAL shape + PURE VIBRANT ${D} color at MAXIMUM brightness and saturation + white background.`
        }, { inlineData: { data: Ge.data, mimeType: Ge.mimeType } }], Ct = (ne = (await Xe.models.generateContent({ model: "gemini-2.5-flash-image", contents: { parts: bt }, config: { responseModalities: [St.IMAGE], temperature: .1, topP: .95, topK: 40 } })).candidates) == null ? void 0 : ne[0], tn = Ct == null ? void 0 : Ct.content, kt = tn == null ? void 0 : tn.parts, Be = kt == null ? void 0 : kt[0], st = Be == null ? void 0 : Be.inlineData; if (!st || !st.data || !st.mimeType) throw new Error("No image data received from API."); const ut = { data: st.data, mimeType: st.mimeType }; if (Ce) { const pt = `data:${ut.mimeType};base64,${ut.data}`; Ce.src = pt, Ce.classList.remove("hidden") } if (ut && a && k) { a.data = ut.data, a.mimeType = ut.mimeType, a.styleConstraints = ce; const pt = { ...a, modificationType: "Regenerated" }; u.push(pt), p = u.length - 1, a && (a.rightPanelHistory = [...u]), dn(), At(), G({ type: "success", title: "Icon regenerated ", body: "New version added to history." }) }
      } catch (ae) { console.error("Failed to parse template:", ae), G({ type: "error", title: "Regeneration Failed", body: "Failed to parse icon template." }) } finally { C == null || C.removeAttribute("disabled"), C == null || C.classList.remove("loading"), we && we.classList.add("hidden") }
    }); const E = g("#p2d-remove-background-btn"); E == null || E.addEventListener("click", async () => { if (!a) { G({ type: "error", title: "No Image", body: "Please generate an image first." }); return } we && Ue && (Ue.textContent = "Removing background...", we.classList.remove("hidden")); try { E.setAttribute("disabled", "true"), E.classList.add("loading"); const D = `data:${a.mimeType};base64,${a.data}`, ae = await (await fetch(D)).blob(), { removeBackground: ce } = await yd(async () => { const { removeBackground: Ye } = await import("./index-Zc_5qeUr.js"); return { removeBackground: Ye } }, [], import.meta.url), Ge = await ce(ae), Ee = new FileReader; Ee.onload = Ye => { var st; const ct = ((st = Ye.target) == null ? void 0 : st.result).split(",")[1]; a.data = ct, a.mimeType = "image/png"; const He = `data:image/png;base64,${ct}`; Jn && (Jn.src = He), Ce && (Ce.src = He); const Ne = g("#p2d-details-preview-container"), gt = g("#p2d-result-media-container"), rt = g("#p2d-preview-checkerboard-checkbox"), bt = g("#p2d-preview-checkerboard-toggle"), gn = g("#p2d-result-checkerboard-toggle"); bt && (bt.style.display = "flex"), gn && (gn.style.display = "none"), gt && (gt.style.backgroundImage = "", gt.style.backgroundColor = "#ffffff"); const Ct = (ut, pt) => { ut && (pt ? (ut.style.backgroundColor = "", ut.style.backgroundImage = "repeating-linear-gradient(45deg, #f0f0f0 25%, transparent 25%, transparent 75%, #f0f0f0 75%, #f0f0f0), repeating-linear-gradient(45deg, #f0f0f0 25%, #ffffff 25%, #ffffff 75%, #f0f0f0 75%, #f0f0f0)", ut.style.backgroundPosition = "0 0, 8px 8px", ut.style.backgroundSize = "16px 16px") : (ut.style.backgroundImage = "", ut.style.backgroundColor = "#ffffff")) }; rt ? Ct(Ne, rt.checked) : Ct(Ne, !0), rt && rt.addEventListener("change", () => { Ct(Ne, rt.checked) }), ot && (ot.href = He, ot.download = `${a.subject.replace(/\s+/g, "_")}-bg-removed.png`, ot.classList.remove("hidden")), I && I.classList.add("hidden"), N = !0; const tn = g("#p2d-remove-background-btn"), kt = g("#p2d-convert-to-svg-btn"), Be = g("#p2d-action-buttons-container"); tn && tn.classList.add("hidden"), kt && (kt.style.display = "flex", kt.classList.remove("hidden")), Be && (Be.style.gridTemplateColumns = "1fr"), a && k && (u.push({ ...a, modificationType: "BG Removed" }), p = u.length - 1, a.rightPanelHistory = [...u], At()), G({ type: "success", title: "Background removed ", body: "Background has been successfully removed." }) }, Ee.readAsDataURL(Ge) } catch (D) { console.error("Background removal failed:", D), G({ type: "error", title: "Removal Failed", body: "Failed to remove background. Please try again." }) } finally { E == null || E.removeAttribute("disabled"), E == null || E.classList.remove("loading"), we && we.classList.add("hidden") } }), Fi == null || Fi.addEventListener("click", () => { if (!$ || !a) { G({ type: "error", title: "Error", body: "Original image not found." }); return } a.data = $.split(",")[1], a.mimeType = "image/png", Jn && (Jn.src = $), Ce && (Ce.src = $), ot && (ot.href = $, ot.download = `${a.subject.replace(/\s+/g, "_")}.png`, ot.classList.remove("hidden")), I && I.classList.add("hidden"), N = !1; const D = g("#p2d-remove-background-btn"); D && D.classList.remove("hidden"), Fi && Fi.classList.add("hidden"), G({ type: "success", title: "Reverted to original ", body: "Background restoration completed." }) }); const b = g("#p2d-convert-to-svg-btn"); b == null || b.addEventListener("click", async () => { if (!a) { G({ type: "error", title: "No Image", body: "Please generate an image first." }); return } we && Ue && (Ue.textContent = "Converting to SVG...", we.classList.remove("hidden")); try { b.setAttribute("disabled", "true"), b.classList.add("loading"); const D = `data:${a.mimeType};base64,${a.data}`, ne = new Image; ne.crossOrigin = "anonymous", await new Promise((rt, bt) => { ne.onload = () => rt(), ne.onerror = () => bt(new Error("Failed to load image")), ne.src = D }); const ae = document.createElement("canvas"), ce = ae.getContext("2d"); if (!ce) throw new Error("Could not get canvas context"); ae.width = ne.width, ae.height = ne.height, ce.drawImage(ne, 0, 0); const Ge = ce.getImageData(0, 0, ae.width, ae.height); Ue && (Ue.textContent = "Vectorizing image..."); const Ee = { ltres: 1, qtres: 1, pathomit: 8, colorsampling: 2, numberofcolors: 256, mincolorratio: .02, colorquantcycles: 5, scale: 1, roundcoords: 1, blurradius: 0, blurdelta: 20, strokewidth: 1, linefilter: !0, layercontainer: "g", layerbgcolor: "", viewbox: !1, desc: !1, lcpr: 0, qcpr: 0, minroundedstops: 0, minrectroundedstops: 0, blursvg: !1, despeckle: !1, despecklelevel: 0, simplifytolerance: 0, corsenabled: !1 }, Ye = pv.imagedataToSVG(Ge, Ee), it = g("#p2d-svg-code-view"), ct = g("#p2d-svg-preview-content"), He = g("#p2d-svg-bg-toggle"), Ne = g("#p2d-svg-preview-container"); it && (it.value = Ye), ct && (ct.innerHTML = Ye); const gt = () => { Ne && (He != null && He.checked ? (Ne.style.backgroundColor = "", Ne.style.backgroundImage = "repeating-linear-gradient(45deg, #f0f0f0 25%, transparent 25%, transparent 75%, #f0f0f0 75%, #f0f0f0), repeating-linear-gradient(45deg, #f0f0f0 25%, #ffffff 25%, #ffffff 75%, #f0f0f0 75%, #f0f0f0)") : (Ne.style.backgroundColor = "white", Ne.style.backgroundImage = "none")) }; if (He == null || He.addEventListener("change", gt), gt(), a.svgString = Ye, a && k) { const rt = { ...a, modificationType: "SVG", data: a.data, mimeType: a.mimeType }; rt.svgString = Ye, u.push(rt), p = u.length - 1, a && (a.rightPanelHistory = [...u]), At() } if (we && we.classList.add("hidden"), cs && cs.classList.remove("hidden"), b && (b.style.display = "none", b.classList.add("hidden")), ot && (ot.href = D, ot.download = `${a.subject.replace(/\s+/g, "_")}.png`, ot.classList.remove("hidden")), I) { const rt = new Blob([Ye], { type: "image/svg+xml;charset=utf-8" }), bt = URL.createObjectURL(rt); I.href = bt, I.download = `${a.subject.replace(/\s+/g, "_")}.svg`, I.classList.remove("hidden") } } catch (D) { console.error("SVG conversion failed:", D), G({ type: "error", title: "Conversion Failed", body: "Failed to convert image to SVG. Please try again." }), we && we.classList.add("hidden") } finally { b == null || b.removeAttribute("disabled"), b == null || b.classList.remove("loading") } }), Vo == null || Vo.addEventListener("click", () => { if (!a) return; const D = c.findIndex(ne => ne.id === a.id); D !== -1 && (c.splice(D, 1), c.length === 0 ? (a = null, Ce && (Ce.src = ""), Ce == null || Ce.classList.add("hidden"), Tn == null || Tn.classList.remove("hidden"), Bn == null || Bn.classList.add("hidden"), ve == null || ve.classList.add("hidden"), ve == null || ve.classList.remove("is-open"), f = -1) : (f = Math.max(0, D - 1), a = c[f], dn()), yo(), G({ type: "success", title: "Deleted", body: "Image removed from history." })) }); const w = g("#p2d-svg-preview-close-btn"), S = g("#p2d-copy-svg-code-btn"), I = g("#p2d-download-svg-btn"), A = g("#p2d-download-svg-btn-preview"); w == null || w.addEventListener("click", () => { cs && cs.classList.add("hidden"), G({ type: "success", title: "SVG conversion completed ", body: "SVG ready for use." }) }), S == null || S.addEventListener("click", () => { const D = g("#p2d-svg-code-view"); D && D.value && (navigator.clipboard.writeText(D.value), G({ type: "success", title: "Copied", body: "SVG code copied to clipboard." })) }); const L = () => { if (!a || !a.svgString) { G({ type: "error", title: "Error", body: "SVG not found." }); return } const D = a.svgString, ne = new Blob([D], { type: "image/svg+xml" }), ae = URL.createObjectURL(ne), ce = document.createElement("a"); ce.href = ae, ce.download = `${a.subject.replace(/\s+/g, "_")}-converted.svg`, document.body.appendChild(ce), ce.click(), document.body.removeChild(ce), URL.revokeObjectURL(ae), G({ type: "success", title: "Downloaded", body: "SVG file downloaded." }) }; I == null || I.addEventListener("click", L), A == null || A.addEventListener("click", L), Pa == null || Pa.addEventListener("click", () => { if (!a) { G({ type: "error", title: "No Image", body: "Please generate an image first." }); return } const D = `data:${a.mimeType};base64,${a.data}`; window.open(D, "_blank") }), Ma == null || Ma.addEventListener("click", () => { if (!a || !$) { G({ type: "error", title: "Error", body: "Cannot compare images." }); return } const D = `data:${a.mimeType};base64,${a.data}`, ne = g("#p2d-compare-original"), ae = g("#p2d-compare-current"), ce = g("#p2d-compare-slider"), Ge = g("#p2d-compare-divider"); ne && (ne.src = $), ae && (ae.src = D); const Ee = () => { const Ye = ce.valueAsNumber; if (Ge && (Ge.style.left = `${Ye}%`), ae) { const it = 100 - Ye; ae.style.clipPath = `inset(0 ${it}% 0 0)` } }; ce == null || ce.removeEventListener("input", Ee), ce == null || ce.addEventListener("input", Ee), Ee(), zn && zn.classList.remove("hidden") }); const x = g("#p2d-compare-close-btn"), _ = g("#p2d-compare-modal-close-btn"); x == null || x.addEventListener("click", () => { zn && zn.classList.add("hidden") }), _ == null || _.addEventListener("click", () => { zn && zn.classList.add("hidden") }); const M = g("#compare-close-btn-3d"), F = g("#compare-modal-close-btn-3d"), U = g("#compare-modal-3d"); M == null || M.addEventListener("click", () => { U && U.classList.add("hidden") }), F == null || F.addEventListener("click", () => { U && U.classList.add("hidden") }); const Z = g("#p2d-more-menu-btn"), J = g("#p2d-more-menu"), z = g("#p2d-more-copy"), B = g("#p2d-more-delete"), O = () => J == null ? void 0 : J.classList.add("hidden"); Z == null || Z.addEventListener("click", D => { D.stopPropagation(), J == null || J.classList.toggle("hidden") }), document.addEventListener("click", () => O()), J == null || J.addEventListener("click", D => D.stopPropagation()), z == null || z.addEventListener("click", () => { O(), qo == null || qo.dispatchEvent(new Event("click")) }), B == null || B.addEventListener("click", () => { O(), Vo == null || Vo.dispatchEvent(new Event("click")) }), ki == null || ki.addEventListener("click", async () => { r > 0 && (r--, n = i[r], Zn(n), await ai(n), xn(), li()) }), Ri == null || Ri.addEventListener("click", async () => { r < i.length - 1 && (r++, n = i[r], Zn(n), await ai(n), xn(), li()) }), ea == null || ea.addEventListener("click", () => { fe == null || fe.classList.toggle("hidden"), fe == null || fe.classList.toggle("is-open") }); const q = () => vn == null ? void 0 : vn.classList.add("hidden"); ta == null || ta.addEventListener("click", D => { D.stopPropagation(), vn == null || vn.classList.toggle("hidden") }), document.addEventListener("click", () => q()), vn == null || vn.addEventListener("click", D => D.stopPropagation()), na == null || na.addEventListener("click", () => { q(), Po == null || Po.dispatchEvent(new Event("click")) }); const te = () => Cn == null ? void 0 : Cn.classList.add("hidden"); Ea == null || Ea.addEventListener("click", D => { D.stopPropagation(), Cn == null || Cn.classList.toggle("hidden") }), document.addEventListener("click", () => te()), Cn == null || Cn.addEventListener("click", D => D.stopPropagation()), ba == null || ba.addEventListener("click", () => { te(), an == null || an.dispatchEvent(new Event("click")) }), Ca == null || Ca.addEventListener("click", () => { te(), qt == null || qt.dispatchEvent(new Event("click")) }); const Y = () => Tt == null ? void 0 : Tt.classList.add("hidden"); Mi == null || Mi.addEventListener("click", D => { D.stopPropagation(), Tt == null || Tt.classList.toggle("hidden") }), document.addEventListener("click", () => Y()), Tt == null || Tt.addEventListener("click", D => D.stopPropagation()), xa == null || xa.addEventListener("click", () => { Y(), rn == null || rn.dispatchEvent(new Event("click")) }), ka == null || ka.addEventListener("click", () => { Y(), Gt == null || Gt.dispatchEvent(new Event("click")) }), oa == null || oa.addEventListener("click", async () => { q(); const ne = (n == null ? void 0 : n.styleConstraints) || JSON.stringify(ys(), null, 2); try { await navigator.clipboard.writeText(ne), G({ type: "success", title: "Copied", body: "Prompt copied to clipboard." }) } catch { G({ type: "error", title: "Copy Failed", body: "Could not copy prompt." }) } }), ia == null || ia.addEventListener("click", () => { if (q(), i.length === 1) { G({ type: "error", title: "Cannot Delete", body: "Cannot delete the last item in history." }); return } r < 0 || r >= i.length || (i.splice(r, 1), r >= i.length && (r = i.length - 1), i.length > 0 ? (n = i[r], xn()) : (n = null, tt.src = "", tt.classList.add("hidden"), hn == null || hn.classList.remove("hidden"), Vn == null || Vn.classList.add("hidden")), li(), G({ type: "success", title: "Deleted", body: "Item removed from history." })) }), js == null || js.addEventListener("click", () => { fe == null || fe.classList.add("hidden"), fe == null || fe.classList.remove("is-open") }), Po == null || Po.addEventListener("click", () => { Xu() }), On && On.addEventListener("input", () => { Gn && Gn.removeAttribute("disabled") }), Hn && Hn.addEventListener("input", () => { Gn && Gn.removeAttribute("disabled") }); const Q = g("#details-remove-bg-btn"); Q == null || Q.addEventListener("click", async () => { if (!n) { G({ type: "error", title: "No Image", body: "Please generate an image first." }); return } if (X) { const D = X.querySelector("p"); D && (D.textContent = "Removing background..."), X.classList.remove("hidden") } try { Q.setAttribute("disabled", "true"), Q.classList.add("loading"); const D = `data:${n.mimeType};base64,${n.data}`, ae = await (await fetch(D)).blob(), { removeBackground: ce } = await yd(async () => { const { removeBackground: Ye } = await import("./index-Zc_5qeUr.js"); return { removeBackground: Ye } }, [], import.meta.url), Ge = await ce(ae), Ee = new FileReader; Ee.onload = Ye => { var kt; const ct = ((kt = Ye.target) == null ? void 0 : kt.result).split(",")[1]; n.data = ct, n.mimeType = "image/png"; const He = `data:image/png;base64,${ct}`; is && (is.src = He); const Ne = document.querySelector("#page-id-3d .result-image"); Ne && (Ne.src = He, Ne.classList.remove("hidden"), Ne.classList.add("visible")); const gt = g("#result-media-container-3d"); gt && (gt.style.backgroundImage = "", gt.style.backgroundColor = "#ffffff"); const rt = g("#details-preview-container-3d"), bt = g("#details-preview-checkerboard-checkbox-3d"), gn = g("#details-preview-checkerboard-toggle-3d"); gn && (gn.style.display = "flex"); const Ct = (Be, st) => { Be && (st ? (Be.style.backgroundColor = "", Be.style.backgroundImage = "repeating-linear-gradient(45deg, #f0f0f0 25%, transparent 25%, transparent 75%, #f0f0f0 75%, #f0f0f0), repeating-linear-gradient(45deg, #f0f0f0 25%, #ffffff 25%, #ffffff 75%, #f0f0f0 75%, #f0f0f0)", Be.style.backgroundPosition = "0 0, 8px 8px", Be.style.backgroundSize = "16px 16px") : (Be.style.backgroundImage = "", Be.style.backgroundColor = "#ffffff")) }; if (bt ? Ct(rt, bt.checked) : Ct(rt, !0), bt && bt.addEventListener("change", () => { Ct(rt, bt.checked) }), No && (No.href = He, No.download = `${n.subject.replace(/\s+/g, "_")}-bg-removed.png`), !v.find(Be => Be.modificationType === "Original")) { const Be = n.originalData ? n.originalData.includes(",") ? n.originalData.split(",")[1] : n.originalData : n.data, st = n.originalMimeType || n.mimeType, ut = { id: n.id, subject: n.subject, styleConstraints: n.styleConstraints, timestamp: n.timestamp, modificationType: "Original", data: Be, mimeType: st }; v.unshift(ut) } if (n) { const Be = { ...n, data: ct, mimeType: "image/png", modificationType: "BG Removed", id: `${n.id}_bg_removed_${Date.now()}` }; v.push(Be), T = v.length - 1, n && (n.rightPanelHistory = [...v]), jt() } Q && Q.classList.add("hidden"), G({ type: "success", title: "Background removed ", body: "Background has been successfully removed." }) }, Ee.readAsDataURL(Ge) } catch (D) { console.error("Background removal failed:", D), G({ type: "error", title: "Removal Failed", body: "Failed to remove background. Please try again." }) } finally { Q == null || Q.removeAttribute("disabled"), Q == null || Q.classList.remove("loading"), X && X.classList.add("hidden") } }), Gn == null || Gn.addEventListener("click", async () => {
      var ne, ae; if (!n) return; const D = Gn; Re(D, !0), X == null || X.classList.remove("hidden"); try {
        const ce = (On == null ? void 0 : On.value) || "#FFFFFF", Ge = (Hn == null ? void 0 : Hn.value) || "#2962FF"; n.originalData || (n.originalData = n.data, n.originalMimeType = n.mimeType); let Ee; try { Ee = JSON.parse(n.styleConstraints), Ee.background && (Ee.background.color = ce), Ee.colors && (Ee.colors.dominant_blue = Ge) } catch (ut) { console.error("Failed to parse styleConstraints:", ut), Ee = n.styleConstraints } const Ye = `data:${n.mimeType};base64,${n.data}`, ct = await (await fetch(Ye)).blob(), Ne = { file: new File([ct], "current-image.png", { type: n.mimeType }), dataUrl: Ye }, rt = [{
          text: `Keep this 3D rendered image exactly the same in shape, composition, lighting, and all visual details. Keep the exact same resolution (width x height) as the original image; do not resize or change the canvas dimensions. Only adjust the color scheme as follows:
- Background color: ${ce}
- Main accent color (use ${Ge} as the PRIMARY/DOMINANT color for the main subject, but maintain natural color variations for other elements like shadows, highlights, and secondary objects)

IMPORTANT: Preserve all other aspects including:
- Original shapes, forms, and proportions
- Lighting and shadows
- Material properties and textures  
- Depth and 3D perspective
- Natural color variations (don't make everything a single flat color)
- Secondary objects should keep their original colors or complementary shades

Apply the main color (${Ge}) thoughtfully as the primary/accent color of the main subject while keeping the overall image natural and well-balanced.`
        }, { inlineData: { data: n.data, mimeType: n.mimeType } }], gn = (ne = (await Xe.models.generateContent({ model: "gemini-2.5-flash-image", contents: { parts: rt }, config: { responseModalities: [St.IMAGE], temperature: .1, topP: .95, topK: 40 } })).candidates) == null ? void 0 : ne[0], Ct = gn == null ? void 0 : gn.content, tn = Ct == null ? void 0 : Ct.parts, kt = tn == null ? void 0 : tn[0], Be = kt == null ? void 0 : kt.inlineData; if (!Be || !Be.data || !Be.mimeType) throw new Error("No image data received from API."); const st = { data: Be.data, mimeType: Be.mimeType }; if (st) { if (!v.find(zi => zi.modificationType === "Original")) { const zi = n.originalData ? n.originalData.includes(",") ? n.originalData.split(",")[1] : n.originalData : n.data, Tf = n.originalMimeType || n.mimeType, Ef = { id: n.id, subject: n.subject, styleConstraints: n.styleConstraints, timestamp: n.timestamp, modificationType: "Original", data: zi, mimeType: Tf }; v.unshift(Ef) } n.data = st.data, n.mimeType = st.mimeType, n.styleConstraints = typeof Ee == "string" ? Ee : JSON.stringify(Ee, null, 2); const pt = i.find(zi => zi.id === n.id); pt && (pt.data = st.data, pt.mimeType = st.mimeType, pt.styleConstraints = typeof Ee == "string" ? Ee : JSON.stringify(Ee, null, 2), pt.originalData || (pt.originalData = n.originalData, pt.originalMimeType = n.originalMimeType)); const vi = { ...n, data: st.data, mimeType: st.mimeType, modificationType: "Regenerated", id: `${n.id}_regenerated_${Date.now()}` }; v.push(vi), T = v.length - 1, n && (n.rightPanelHistory = [...v]), xn(), ja(); const pd = (ae = document.getElementById("3d-details-history-list")) == null ? void 0 : ae.closest(".details-tab-content"); pd && !pd.classList.contains("hidden") && jt(), G({ type: "success", title: "Fixed!", body: "Image updated with new colors." }) }
      } catch (ce) { console.error("Fix failed:", ce), G({ type: "error", title: "Fix Failed", body: "Failed to update image." }) } finally { Re(D, !1), X == null || X.classList.add("hidden") }
    }), tt == null || tt.addEventListener("click", () => { if (!n) return; fe == null || fe.classList.remove("hidden"), fe == null || fe.classList.add("is-open"); const D = fe == null ? void 0 : fe.querySelector('.tab-item[data-tab="details"]'); D == null || D.click() }); const H = D => { if (!n) return; const ne = document.querySelector("#result-item-main"); if (!ne) return; const ae = ne.querySelector('.preview-tab-item[data-tab="image"]'), ce = ne.querySelector('.preview-tab-item[data-tab="video"]'), Ge = g("#result-image"), Ee = g("#result-video"), Ye = g("#result-idle-placeholder"), it = g("#motion-prompt-placeholder"); if (D === "image") { if (ae && ae.classList.add("active"), ce && ce.classList.remove("active"), Ge && (Ge.classList.remove("hidden"), setTimeout(() => Ge.classList.add("visible"), 50)), Ee && Ee.classList.add("hidden"), Ye && Ye.classList.add("hidden"), it && it.classList.add("hidden"), fe) { fe.classList.remove("hidden"), fe.classList.add("is-open"); const ct = fe.querySelector('.tab-item[data-tab="detail"]'); ct && (fe.querySelectorAll(".tab-item").forEach(He => He.classList.remove("active")), ct.classList.add("active"), fe.querySelectorAll(".details-tab-content").forEach(He => { const Ne = He.dataset.tabContent || He.dataset.tab; He.classList.toggle("hidden", Ne !== "detail"), He.classList.toggle("active", Ne === "detail") })) } } else if (D === "video") { ae && ae.classList.remove("active"), ce && ce.classList.add("active"); const ct = ne == null ? void 0 : ne.querySelector(".result-content-header"); if (ct && ct.classList.remove("hidden"), Ge && (Ge.classList.add("hidden"), Ge.classList.remove("visible")), n.videoDataUrl ? (Ee && (Ee.src = n.videoDataUrl, Ee.classList.remove("hidden")), it && it.classList.add("hidden")) : (Ee && Ee.classList.add("hidden"), it && (it.classList.remove("hidden"), it.style.display = "flex", it.style.position = "absolute", it.style.inset = "0", it.style.zIndex = "2")), Ye && Ye.classList.add("hidden"), fe) { fe.classList.remove("hidden"), fe.classList.add("is-open"); const He = fe.querySelector('.tab-item[data-tab="motion"]'); He && (fe.querySelectorAll(".tab-item").forEach(Ne => Ne.classList.remove("active")), He.classList.add("active"), fe.querySelectorAll(".details-tab-content").forEach(Ne => { const gt = Ne.dataset.tabContent || Ne.dataset.tab; Ne.classList.toggle("hidden", gt !== "motion"), Ne.classList.toggle("active", gt === "motion") })) } } }; document.addEventListener("click", D => { const ae = D.target.closest("#result-item-main .preview-tab-item"); if (!ae || !n) return; const ce = ae.dataset.tab; (ce === "image" || ce === "video") && H(ce) }); const ee = () => { qi(X), _t && (_t.textContent = "Generating prompt"), X == null || X.classList.remove("hidden"), Ou(), xe = document.activeElement }; uo == null || uo.addEventListener("click", ee), an == null || an.addEventListener("click", ee), bn == null || bn.addEventListener("click", hl), qt == null || qt.addEventListener("click", hl); const pe = () => { qi(X), _t && (_t.textContent = "Generating motion ideas..."), X == null || X.classList.remove("hidden"), Vu(), xe = document.activeElement }; fo == null || fo.addEventListener("click", pe), rn == null || rn.addEventListener("click", pe), Na == null || Na.addEventListener("click", () => { if (!V) { G({ type: "error", title: "No Image", body: "Please generate an image first." }); return } Sn != null && Sn.classList.contains("hidden") && (Sn.classList.remove("hidden"), Sn.classList.add("is-open")), Qo == null || Qo.click(), pe() }), In == null || In.addEventListener("click", yl), Gt == null || Gt.addEventListener("click", yl); const se = () => { X && X.classList.remove("hidden"), _t && (_t.textContent = "Generating prompt"), Gu(), xe = document.activeElement }; co == null || co.addEventListener("click", se), sn == null || sn.addEventListener("click", se), ra == null || ra.addEventListener("click", () => { if (!a) { G({ type: "error", title: "No Icon", body: "Generate an icon first." }); return } ve != null && ve.classList.contains("hidden") && (ve.classList.remove("hidden"), ve.classList.add("is-open")), ma == null || ma.click(), se() }), En == null || En.addEventListener("click", vl), Ut == null || Ut.addEventListener("click", vl), Wn == null || Wn.addEventListener("click", Uu), Bo == null || Bo.addEventListener("click", $u), Jo == null || Jo.addEventListener("click", qu); const me = () => Ve == null ? void 0 : Ve.classList.add("hidden"); $t == null || $t.addEventListener("click", D => { D.stopPropagation(), Ve == null || Ve.classList.toggle("hidden") }), Ve == null || Ve.addEventListener("click", D => D.stopPropagation()), document.addEventListener("click", me), ya == null || ya.addEventListener("click", () => { me(), sn == null || sn.dispatchEvent(new Event("click")) }), va == null || va.addEventListener("click", () => { me(), Ut == null || Ut.dispatchEvent(new Event("click")) }), lt == null || lt.addEventListener("click", () => { if (!a) return; lt.classList.add("active"), We == null || We.classList.remove("active"), Ce == null || Ce.classList.remove("hidden"), Pe == null || Pe.classList.add("hidden"), Se == null || Se.classList.add("hidden"); const D = g("#p2d-image-details-panel"); if (D && !D.classList.contains("hidden")) { const ne = D.querySelector('.tab-item[data-tab="detail"]'); ne == null || ne.click() } }), We == null || We.addEventListener("click", () => { if (!a) return; We.classList.add("active"), lt == null || lt.classList.remove("active"), a.videoDataUrl ? (Pe && (Pe.src !== a.videoDataUrl && (Pe.src = a.videoDataUrl), Pe.classList.remove("hidden")), Se == null || Se.classList.add("hidden")) : (Pe == null || Pe.classList.add("hidden"), Se == null || Se.classList.remove("hidden")), Ce == null || Ce.classList.add("hidden"); const D = g("#p2d-image-details-panel"); if (D && !D.classList.contains("hidden")) { const ne = D.querySelector('.tab-item[data-tab="motion"]'); ne == null || ne.click() } }), Aa == null || Aa.addEventListener("click", () => { ke == null || ke.classList.add("hidden"), xe == null || xe.focus() }), Sa == null || Sa.addEventListener("click", () => { if (!n) return; fe == null || fe.classList.remove("hidden"), fe == null || fe.classList.add("is-open"); const D = fe == null ? void 0 : fe.querySelector('.tab-item[data-tab="motion"]'); D == null || D.click(), ee() }), (ud = g("#history-original-image")) == null || ud.addEventListener("click", () => { if (!n || !n.originalData) return; const D = `data:${n.originalMimeType};base64,${n.originalData}`; tt.src = D, tt.classList.remove("hidden"), tt.classList.add("visible"), yn == null || yn.classList.add("active"), Ft == null || Ft.classList.remove("active") }), (fd = g("#history-fixed-image")) == null || fd.addEventListener("click", () => { if (!n) return; const D = `data:${n.mimeType};base64,${n.data}`; tt.src = D, tt.classList.remove("hidden"), tt.classList.add("visible"), yn == null || yn.classList.add("active"), Ft == null || Ft.classList.remove("active") }), Kt && Xt && (Kt.addEventListener("click", () => { V && (wn == null || wn.classList.remove("hidden"), Zt == null || Zt.classList.add("hidden"), Vt == null || Vt.classList.add("hidden"), Kt.classList.add("active"), Xt.classList.remove("active"), Sn && !Sn.classList.contains("hidden") && (Da == null || Da.click())) }), Xt.addEventListener("click", () => { V && (Xt.classList.add("active"), Kt.classList.remove("active"), V.videoDataUrl ? (Zt.src = V.videoDataUrl, Zt.classList.remove("hidden"), Vt == null || Vt.classList.add("hidden")) : (Zt == null || Zt.classList.add("hidden"), Vt == null || Vt.classList.remove("hidden")), wn == null || wn.classList.add("hidden"), Sn && !Sn.classList.contains("hidden") && (Qo == null || Qo.click())) })); const Le = document.querySelector(".app-header"), ge = () => { window.scrollY > 50 ? Le == null || Le.classList.add("scrolled") : Le == null || Le.classList.remove("scrolled") }; window.addEventListener("scroll", ge, { passive: !0 }); const he = document.getElementById("generate-btn"), oe = document.getElementById("generate-input"); he == null || he.addEventListener("click", Za), oe == null || oe.addEventListener("keypress", D => { D.key === "Enter" && (he == null || he.click()) }), Oe && (Oe.addEventListener("dragover", D => { D.preventDefault(), Oe.classList.add("dragover") }), Oe.addEventListener("dragleave", D => { D.preventDefault(), Oe.classList.remove("dragover") }), Oe.addEventListener("drop", D => { var ae; D.preventDefault(), Oe.classList.remove("dragover"); const ne = (ae = D.dataTransfer) == null ? void 0 : ae.files[0]; ne && ne.type.startsWith("image/") && pl(ne) }), Oe.addEventListener("click", () => { const D = document.createElement("input"); D.type = "file", D.accept = "image/*", D.addEventListener("change", ne => { var ce; const ae = (ce = ne.target.files) == null ? void 0 : ce[0]; ae && pl(ae) }), D.click() })), Fa == null || Fa.addEventListener("click", () => { _o && Za() }), Ua == null || Ua.addEventListener("click", () => { _o && Za() }), mo == null || mo.addEventListener("click", () => { ku() }); const De = g("#logo-image"), ze = g(".logo-text"); De && (De.complete && De.naturalHeight !== 0 ? De.style.display = "block" : (De.addEventListener("load", () => { De.style.display = "block" }), De.addEventListener("error", () => { De.style.display = "none" }))), ze && (ze.style.display = "block"); const je = g(".logo"); je == null || je.addEventListener("click", () => { document.querySelectorAll(".nav-item").forEach(ne => { ne.classList.remove("active") }), re = "page-usages", Ro(), Gr.forEach(ne => { ne.classList.add("hidden") }); const D = g("#page-usages"); D && D.classList.remove("hidden") }); const be = document.getElementById("dynamic-placeholder"), et = () => { const D = ["  ", "  ", "  ", "  ", "   ", "  "], ne = ["   ", "  ", "  ", "   ", "  ", "  "]; return re === "page-id-3d" ? ne : D }; let Qe = et(), mn = 0, Wt = "", yi = 0, mt = null; const Ji = () => { (oe == null ? void 0 : oe.value) !== "" || document.activeElement === oe || (yi < Qe[mn].length ? (Wt += Qe[mn].charAt(yi), be && (be.textContent = Wt), yi++, mt = setTimeout(Ji, 50)) : mt = setTimeout(ad, 2e3)) }, ad = () => { (oe == null ? void 0 : oe.value) !== "" || document.activeElement === oe || (Wt.length > 0 ? (Wt = Wt.slice(0, -1), be && (be.textContent = Wt), mt = setTimeout(ad, 30)) : (mn = (mn + 1) % Qe.length, yi = 0, mt = setTimeout(Ji, 500))) }, Wi = () => { const D = document.getElementById("generate-btn"); if (D && oe) { const ne = oe.value.trim().length > 0; D.disabled = !ne, ne ? (D.style.opacity = "1", D.style.cursor = "pointer") : (D.style.opacity = "0.5", D.style.cursor = "not-allowed") } }, en = document.getElementById("generate-input-clear-btn"), Er = () => { en && oe && (oe.value.trim().length > 0 ? (en.style.display = "flex", en.style.alignItems = "center", en.style.justifyContent = "center") : en.style.display = "none") }; be && Ji(); const rd = () => { oe && Wt && (oe.value = Wt, be && be.classList.add("hidden"), mt && (clearTimeout(mt), mt = null), Wi(), Er(), oe.focus()) }; be && (be.addEventListener("click", rd), be.style.cursor = "pointer"), oe && oe.addEventListener("click", () => { oe.value === "" && Wt && rd() }); const ld = () => { Qe = et(), mt && (clearTimeout(mt), mt = null), mn = 0, Wt = "", yi = 0, (oe == null ? void 0 : oe.value) === "" && document.activeElement !== oe && (be && be.classList.remove("hidden"), Ji()) }; en && (en.addEventListener("click", D => { D.preventDefault(), D.stopPropagation(), oe && (oe.value = "", oe.focus(), be && be.classList.remove("hidden"), Wi(), Er(), mt && (clearTimeout(mt), mt = null), mn = 0, Wt = "", yi = 0, document.activeElement !== oe && Ji()) }), en.addEventListener("mouseenter", () => { en.style.backgroundColor = "var(--input-bg)" }), en.addEventListener("mouseleave", () => { en.style.backgroundColor = "transparent" })); const dd = oe == null ? void 0 : oe.oninput; oe == null || oe.addEventListener("input", () => { be && be.classList.add("hidden"), mt && (clearTimeout(mt), mt = null), Wi(), Er(), dd && dd.call(oe) }), oe == null || oe.addEventListener("blur", () => { (oe == null ? void 0 : oe.value) === "" && be && (be.classList.remove("hidden"), ld()), Wi() }), Wi(), window.updateHomePlaceholders = ld
  }, Is = document.querySelector('.accordion-header[data-accordion="p2d-reference"]'), kl = document.getElementById("p2d-reference-content"); Is && kl && Is.addEventListener("click", () => { const d = Is.getAttribute("data-active") === "true"; Is.setAttribute("data-active", d ? "false" : "true"), kl.setAttribute("data-active", d ? "false" : "true") }); const Ss = document.querySelector('.accordion-header[data-accordion="p2d-library"]'), Rl = document.getElementById("p2d-library-content"); Ss && Rl && Ss.addEventListener("click", () => { const d = Ss.getAttribute("data-active") === "true"; Ss.setAttribute("data-active", d ? "false" : "true"), Rl.setAttribute("data-active", d ? "false" : "true") }); const Ls = document.querySelector('.accordion-header[data-accordion="p2d-fix-icon"]'), Dl = document.getElementById("p2d-fix-icon-content"); Ls && Dl && Ls.addEventListener("click", () => { const d = Ls.getAttribute("data-active") === "true"; Ls.setAttribute("data-active", d ? "false" : "true"), Dl.setAttribute("data-active", d ? "false" : "true") }); const _s = document.querySelector('.accordion-header[data-accordion="3d-reference"]'), Nl = document.getElementById("3d-reference-content"); _s && Nl && _s.addEventListener("click", () => { const d = _s.getAttribute("data-active") === "true"; _s.setAttribute("data-active", d ? "false" : "true"), Nl.setAttribute("data-active", d ? "false" : "true") }); const As = document.querySelector('.accordion-header[data-accordion="3d-library"]'), Pl = document.getElementById("3d-library-content"); As && Pl && As.addEventListener("click", () => { const d = As.getAttribute("data-active") === "true"; As.setAttribute("data-active", d ? "false" : "true"), Pl.setAttribute("data-active", d ? "false" : "true") }); const xs = document.querySelector('.accordion-header[data-accordion="3d-fix"]'), Ml = document.getElementById("3d-fix-content"); xs && Ml && xs.addEventListener("click", () => { const d = xs.getAttribute("data-active") === "true"; xs.setAttribute("data-active", d ? "false" : "true"), Ml.setAttribute("data-active", d ? "false" : "true") }); const Fl = g("#p2d-compare-close-btn"); Fl && zn && Fl.addEventListener("click", () => { zn.classList.add("hidden") }); const Ul = g("#compare-close-btn-3d"), $l = g("#compare-modal-3d"); Ul && $l && Ul.addEventListener("click", () => { $l.classList.add("hidden") }), ro && Lo(ro), Pe && Lo(Pe); const Dn = g("#api-key-modal-overlay"), fn = g("#api-key-display"), ql = g("#api-key-save-btn"), Vl = g("#api-key-delete-btn"), gi = g("#api-key-verify-btn"), Gl = g("#api-key-copy-btn"), Ol = g("#api-key-menu-item"), hi = g("#api-key-validation-status"), Hi = g("#api-key-validation-message"), Bi = g("#api-key-validation-icon"), Hl = g("#api-key-validation-text"), gf = async d => { var m, y, h, C, E; if (!d || d.trim() === "") return { valid: !1, message: "API Key ." }; try { return await new Mc({ apiKey: d.trim() }).models.list(), { valid: !0, message: "API Key ." } } catch (b) { return console.error("[API Key Verification] Error:", b), (m = b == null ? void 0 : b.message) != null && m.includes("API_KEY_INVALID") || (y = b == null ? void 0 : b.message) != null && y.includes("401") ? { valid: !1, message: "API Key  ." } : (h = b == null ? void 0 : b.message) != null && h.includes("403") || (C = b == null ? void 0 : b.message) != null && C.includes("PERMISSION_DENIED") ? { valid: !1, message: "API Key  ." } : (E = b == null ? void 0 : b.message) != null && E.includes("QUOTA_EXCEEDED") ? { valid: !1, message: "API  ." } : { valid: !1, message: ` : ${(b == null ? void 0 : b.message) || "   "}` } } }, vr = (d, m) => { !hi || !Hi || !Bi || !Hl || (hi.style.display = "block", Hl.textContent = m, d ? (Hi.style.backgroundColor = "rgba(76, 175, 80, 0.1)", Hi.style.color = "#4CAF50", Bi.textContent = "check_circle", Bi.style.color = "#4CAF50") : (Hi.style.backgroundColor = "rgba(244, 67, 54, 0.1)", Hi.style.color = "#F44336", Bi.textContent = "error", Bi.style.color = "#F44336")) }; Ol && Dn && Ol.addEventListener("click", () => { if (Dn && (Dn.classList.remove("hidden"), fn)) { const d = localStorage.getItem("geminiApiKey") || localStorage.getItem("GEMINI_API_KEY") || ""; fn.value = d, hi && (hi.style.display = "none") } }), Dn && Dn.addEventListener("click", d => { d.target === Dn && Dn.classList.add("hidden") }), gi && fn && gi.addEventListener("click", async () => { const d = fn.value.trim(); if (!d) { vr(!1, "API Key ."); return } gi.disabled = !0, gi.innerHTML = '<span class="material-symbols-outlined" style="font-size: 18px;">hourglass_empty</span><span> ...</span>'; try { const m = await gf(d); vr(m.valid, m.message) } catch { vr(!1, "   .") } finally { gi.disabled = !1, gi.innerHTML = '<span class="material-symbols-outlined" style="font-size: 18px;">verified</span><span></span>' } }), ql && fn && ql.addEventListener("click", () => { const d = fn.value.trim(); if (!d) { G({ type: "error", title: "", body: "API Key ." }); return } localStorage.setItem("geminiApiKey", d), localStorage.setItem("GEMINI_API_KEY", d), _i = null, G({ type: "success", title: " ", body: "API Key ." }), Dn && Dn.classList.add("hidden") }), Vl && Vl.addEventListener("click", () => { confirm("API Key ?") && (localStorage.removeItem("geminiApiKey"), localStorage.removeItem("GEMINI_API_KEY"), _i = null, fn && (fn.value = ""), hi && (hi.style.display = "none"), G({ type: "success", title: " ", body: "API Key ." })) }), Gl && fn && Gl.addEventListener("click", () => { const d = fn.value.trim(); d && navigator.clipboard.writeText(d).then(() => { G({ type: "success", title: " ", body: "API Key  ." }) }).catch(() => { G({ type: "error", title: " ", body: "  ." }) }) }); const Nn = g("#history-btn"), at = g("#history-modal"), Bl = g("#history-modal-close-btn"), ks = g("#history-modal-content"), Pn = g("#history-detail-modal"), Jl = g("#history-detail-back-btn"), Wl = g("#history-detail-close-btn"), zl = g("#history-detail-content"), Yl = g("#history-detail-title"), pn = () => { if (!Nn) return; window.innerWidth <= 768 ? (Nn.classList.remove("hidden"), Nn.style.display = "flex", Nn.style.visibility = "visible", Nn.style.opacity = "1") : (Nn.classList.add("hidden"), Nn.style.display = "none") }, hf = () => {
    var y; if (!ks) { console.error("[History Modal] historyModalContent not found"); return } const d = (y = document.querySelector(".page:not(.hidden)")) == null ? void 0 : y.id; let m = []; if (console.log("[History Modal] Current page:", d), console.log("[History Modal] imageHistory2d length:", c.length), console.log("[History Modal] imageHistory length:", i.length), d === "page-id-2d" ? m = [...c].reverse() : d === "page-id-3d" ? m = [...i].reverse() : d === "page-icons" ? m = [] : m = [...c, ...i].sort((h, C) => C.timestamp - h.timestamp), console.log("[History Modal] Final history length:", m.length), m.length === 0) {
      ks.innerHTML = `
        <div style="text-align: center; padding: 40px 20px; color: var(--text-secondary);">
          <span class="material-symbols-outlined" style="font-size: 48px; opacity: 0.5; display: block; margin-bottom: 16px;">history</span>
          <p>  .</p>
        </div>
      `; return
    } ks.innerHTML = m.map((h, C) => {
      const b = new Date(h.timestamp).toLocaleDateString("ko-KR", { year: "numeric", month: "short", day: "numeric", hour: "2-digit", minute: "2-digit" }); if (!h.data || !h.mimeType) return console.warn("[History Modal] Item missing data or mimeType:", h), ""; const w = `data:${h.mimeType};base64,${h.data}`; return `
        <div class="history-item" style="display: flex; gap: 16px; padding: 16px; border: 1px solid var(--border-color); border-radius: 8px; cursor: pointer; transition: background-color 0.2s;" data-index="${C}">
          <img src="${w}" alt="${h.subject || "Image"}" style="width: 80px; height: 80px; object-fit: cover; border-radius: 8px; flex-shrink: 0; background-color: var(--input-bg);" onerror="console.error('Image load error:', this.src.substring(0, 50)); this.style.display='none';">
          <div style="flex: 1; display: flex; flex-direction: column; justify-content: center; gap: 8px; min-width: 0;">
            <div style="font-weight: 600; font-size: 16px; color: var(--text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${h.subject || "Untitled"}</div>
            <div style="font-size: 12px; color: var(--text-secondary);">${b}</div>
          </div>
        </div>
      `}).filter(h => h !== "").join(""), ks.querySelectorAll(".history-item").forEach((h, C) => { h.addEventListener("click", () => { const E = m.length - 1 - C, b = m[E]; window.innerWidth <= 768 && b ? vf(b) : d === "page-id-2d" && c[E] ? (f = E, a = c[E], dn(), at == null || at.classList.add("hidden")) : d === "page-id-3d" && i[E] && (r = E, n = i[E], xn(), at == null || at.classList.add("hidden")) }) })
  }, yf = () => { if (!at) { console.error("[History Modal] historyModal not found"); return } console.log("[History Modal] Opening history modal"), hf(), at.classList.remove("hidden") }, Kl = () => { at && at.classList.add("hidden") }, vf = d => {
    if (!Pn || !zl || !Yl) return; at == null || at.classList.add("hidden"), Yl.textContent = d.subject || "History"; const m = `data:${d.mimeType};base64,${d.data}`, h = new Date(d.timestamp).toLocaleDateString("ko-KR", { year: "numeric", month: "short", day: "numeric", hour: "2-digit", minute: "2-digit" }); zl.innerHTML = `
      <div style="display: flex; justify-content: center; align-items: center; min-height: 300px; margin-bottom: 24px;">
        <img src="${m}" alt="${d.subject || "Image"}" style="max-width: 100%; max-height: 60vh; object-fit: contain; border-radius: 8px;">
      </div>
      <div style="display: flex; flex-direction: column; gap: 16px;">
        <div>
          <label style="font-weight: 500; font-size: 14px; color: var(--text-secondary); display: block; margin-bottom: 8px;">Title</label>
          <div style="font-size: 16px; font-weight: 600; color: var(--text-primary);">${d.subject || "Untitled"}</div>
        </div>
        <div>
          <label style="font-weight: 500; font-size: 14px; color: var(--text-secondary); display: block; margin-bottom: 8px;">Created</label>
          <div style="font-size: 14px; color: var(--text-primary);">${h}</div>
        </div>
        ${d.styleConstraints ? `
        <div>
          <label style="font-weight: 500; font-size: 14px; color: var(--text-secondary); display: block; margin-bottom: 8px;">Prompt</label>
          <div class="code-box" style="background: var(--input-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 12px; font-size: 13px; color: var(--text-primary); white-space: pre-wrap; word-break: break-word;">${d.styleConstraints}</div>
        </div>
        `: ""}
      </div>
    `, Pn.classList.remove("hidden")
  }, Xl = () => { Pn && (Pn.classList.add("hidden"), window.innerWidth <= 768 && (at == null || at.classList.remove("hidden"))) }; Nn && Nn.addEventListener("click", yf), Bl && Bl.addEventListener("click", Kl), at && at.addEventListener("click", d => { d.target === at && Kl() }), Jl && Jl.addEventListener("click", Xl), Wl && Wl.addEventListener("click", () => { Pn && Pn.classList.add("hidden") }), Pn && Pn.addEventListener("click", d => { d.target === Pn && Xl() }); const Rs = document.querySelector(".generate-box.has-studio-selected"), Tr = document.querySelector("#page-usages .explore-container"); if (Rs && Tr && window.innerWidth <= 768) { const d = () => { if (window.innerWidth > 768) return; Tr.getBoundingClientRect(), Rs.getBoundingClientRect().top <= 60 + 12 ? Rs.classList.add("is-sticky") : Rs.classList.remove("is-sticky") }; Tr.addEventListener("scroll", d), window.addEventListener("scroll", d), d() } window.addEventListener("resize", () => { pn() }), setTimeout(() => { pn() }, 200), mf()
}); export { yd as _ };
